-- phpMyAdmin SQL Dump
-- version 5.2.0
-- https://www.phpmyadmin.net/
--
-- 主机： localhost
-- 生成日期： 2022-11-27 21:32:23
-- 服务器版本： 5.7.38-log
-- PHP 版本： 7.4.30

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- 数据库： `blog`
--

-- --------------------------------------------------------

--
-- 表的结构 `bcategory`
--

CREATE TABLE `bcategory` (
  `cid` int(11) NOT NULL,
  `cname` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `bcategory`
--

INSERT INTO `bcategory` (`cid`, `cname`) VALUES
(6, '前端基础'),
(7, '前端框架'),
(10, '后端开发');

-- --------------------------------------------------------

--
-- 表的结构 `blog`
--

CREATE TABLE `blog` (
  `bid` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `desc` varchar(255) DEFAULT NULL,
  `content` text NOT NULL,
  `createTime` date NOT NULL,
  `cid` int(11) NOT NULL,
  `tname` varchar(255) DEFAULT NULL,
  `watch` int(11) NOT NULL DEFAULT '0',
  `star` int(11) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `blog`
--

INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(1, 'Vue3快速上手', 'Vue3与Vue2的不同之处和新增', '# Vue3快速上手\n\n<img src=\"https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png\" style=\"width:200px\" />\n\n\n\n## 1.Vue3简介\n\n- 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）\n- 耗时2年多、[2600+次提交](https://github.com/vuejs/vue-next/graphs/commit-activity)、[30+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)、[99位贡献者](https://github.com/vuejs/vue-next/graphs/contributors) \n- github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n## 2.Vue3带来了什么\n\n### 1.性能的提升\n\n- 打包大小减少41%\n\n- 初次渲染快55%, 更新渲染快133%\n\n- 内存减少54%\n\n  ......\n\n### 2.源码的升级\n\n- 使用Proxy代替defineProperty实现响应式\n\n- 重写虚拟DOM的实现和Tree-Shaking\n\n  ......\n\n### 3.拥抱TypeScript\n\n- Vue3可以更好的支持TypeScript\n\n### 4.新的特性\n\n1. Composition API（组合API）\n\n   - setup配置\n   - ref与reactive\n   - watch与watchEffect\n   - provide与inject\n   - ......\n2. 新的内置组件\n   - Fragment \n   - Teleport\n   - Suspense\n3. 其他改变\n\n   - 新的生命周期钩子\n   - data 选项应始终被声明为一个函数\n   - 移除keyCode支持作为 v-on 的修饰符\n   - ......\n\n# 一、创建Vue3.0工程\n\n## 1.使用 vue-cli 创建\n\n官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n\n```bash\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n```\n\n## 2.使用 vite 创建\n\n官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\n\nvite官网：https://vitejs.cn\n\n- 什么是vite？—— 新一代前端构建工具。\n- 优势如下：\n  - 开发环境中，无需打包操作，可快速的冷启动。\n  - 轻量快速的热重载（HMR）。\n  - 真正的按需编译，不再等待整个应用编译完成。\n- 传统构建 与 vite构建对比图\n\n<img src=\"https://cn.vitejs.dev/assets/bundler.37740380.png\" style=\"width:500px;height:280px;float:left\" /><img src=\"https://cn.vitejs.dev/assets/esm.3070012d.png\" style=\"width:480px;height:280px\" />\n\n```bash\n## 创建工程\nnpm init vite-app <project-name>\n## 进入工程目录\ncd <project-name>\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n```\n\n# 二、常用 Composition API\n\n官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n\n## 1.拉开序幕的setup\n\n1. 理解：Vue3.0中一个新的配置项，值为一个函数。\n2. setup是所有<strong style=\"color:#DD5145\">Composition API（组合API）</strong><i style=\"color:gray;font-weight:bold\">“ 表演的舞台 ”</i>。\n4. 组件中所用到的：数据、方法等等，均要配置在setup中。\n5. setup函数的两种返回值：\n   1. 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n   2. <span style=\"color:#aad\">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span>\n6. 注意点：\n   1. 尽量不要与Vue2.x配置混用\n      - Vue2.x配置（data、methos、computed...）中<strong style=\"color:#DD5145\">可以访问到</strong>setup中的属性、方法。\n      - 但在setup中<strong style=\"color:#DD5145\">不能访问到</strong>Vue2.x配置（data、methos、computed...）。\n      - 如果有重名, setup优先。\n   2. setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）\n\n##  2.ref函数\n\n- 作用: 定义一个响应式的数据\n- 语法: ```const xxx = ref(initValue)``` \n  - 创建一个包含响应式数据的<strong style=\"color:#DD5145\">引用对象（reference对象，简称ref对象）</strong>。\n  - JS中操作数据： ```xxx.value```\n  - 模板中读取数据: 不需要.value，直接：```<div>{{xxx}}</div>```\n- 备注：\n  - 接收的数据可以是：基本类型、也可以是对象类型。\n  - 基本类型的数据：响应式依然是靠``Object.defineProperty()``的```get```与```set```完成的。\n  - 对象类型的数据：内部 <i style=\"color:gray;font-weight:bold\">“ 求助 ”</i> 了Vue3.0中的一个新函数—— ```reactive```函数。\n\n## 3.reactive函数\n\n- 作用: 定义一个<strong style=\"color:#DD5145\">对象类型</strong>的响应式数据（基本类型不要用它，要用```ref```函数）\n- 语法：```const 代理对象= reactive(源对象)```接收一个对象（或数组），返回一个<strong style=\"color:#DD5145\">代理对象（Proxy的实例对象，简称proxy对象）</strong>\n- reactive定义的响应式数据是“深层次的”。\n- 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n## 4.Vue3.0中的响应式原理\n\n### vue2.x的响应式\n\n- 实现原理：\n  - 对象类型：通过```Object.defineProperty()```对属性的读取、修改进行拦截（数据劫持）。\n  \n  - 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n  \n    ```js\n    Object.defineProperty(data, \'count\', {\n        get () {}, \n        set () {}\n    })\n    ```\n\n- 存在问题：\n  - 新增属性、删除属性, 界面不会更新。\n  - 直接通过下标修改数组, 界面不会自动更新。\n\n### Vue3.0的响应式\n\n- 实现原理: \n  - 通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n  - 通过Reflect（反射）:  对源对象的属性进行操作。\n  - MDN文档中描述的Proxy与Reflect：\n    - Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n    \n    - Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n    \n      ```js\n      new Proxy(data, {\n      	// 拦截读取属性值\n          get (target, prop) {\n          	return Reflect.get(target, prop)\n          },\n          // 拦截设置属性值或添加新属性\n          set (target, prop, value) {\n          	return Reflect.set(target, prop, value)\n          },\n          // 拦截删除属性\n          deleteProperty (target, prop) {\n          	return Reflect.deleteProperty(target, prop)\n          }\n      })\n      \n      proxy.name = \'tom\'   \n      ```\n\n## 5.reactive对比ref\n\n-  从定义数据角度对比：\n   -  ref用来定义：<strong style=\"color:#DD5145\">基本类型数据</strong>。\n   -  reactive用来定义：<strong style=\"color:#DD5145\">对象（或数组）类型数据</strong>。\n   -  备注：ref也可以用来定义<strong style=\"color:#DD5145\">对象（或数组）类型数据</strong>, 它内部会自动通过```reactive```转为<strong style=\"color:#DD5145\">代理对象</strong>。\n-  从原理角度对比：\n   -  ref通过``Object.defineProperty()``的```get```与```set```来实现响应式（数据劫持）。\n   -  reactive通过使用<strong style=\"color:#DD5145\">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style=\"color:#DD5145\">Reflect</strong>操作<strong style=\"color:orange\">源对象</strong>内部的数据。\n-  从使用角度对比：\n   -  ref定义的数据：操作数据<strong style=\"color:#DD5145\">需要</strong>```.value```，读取数据时模板中直接读取<strong style=\"color:#DD5145\">不需要</strong>```.value```。\n   -  reactive定义的数据：操作数据与读取数据：<strong style=\"color:#DD5145\">均不需要</strong>```.value```。\n\n## 6.setup的两个注意点\n\n- setup执行的时机\n  - 在beforeCreate之前执行一次，this是undefined。\n  \n- setup的参数\n  - props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n  - context：上下文对象\n    - attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 ```this.$attrs```。\n    - slots: 收到的插槽内容, 相当于 ```this.$slots```。\n    - emit: 分发自定义事件的函数, 相当于 ```this.$emit```。\n\n\n## 7.计算属性与监视\n\n### 1.computed函数\n\n- 与Vue2.x中computed配置功能一致\n\n- 写法\n\n  ```js\n  import {computed} from \'vue\'\n  \n  setup(){\n      ...\n  	//计算属性——简写\n      let fullName = computed(()=>{\n          return person.firstName + \'-\' + person.lastName\n      })\n      //计算属性——完整\n      let fullName = computed({\n          get(){\n              return person.firstName + \'-\' + person.lastName\n          },\n          set(value){\n              const nameArr = value.split(\'-\')\n              person.firstName = nameArr[0]\n              person.lastName = nameArr[1]\n          }\n      })\n  }\n  ```\n\n### 2.watch函数\n\n- 与Vue2.x中watch配置功能一致\n\n- 两个小“坑”：\n\n  - 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n  - 监视reactive定义的响应式数据中某个属性时：deep配置有效。\n  \n  ```js\n  //情况一：监视ref定义的响应式数据\n  watch(sum,(newValue,oldValue)=>{\n  	console.log(\'sum变化了\',newValue,oldValue)\n  },{immediate:true})\n  \n  //情况二：监视多个ref定义的响应式数据\n  watch([sum,msg],(newValue,oldValue)=>{\n  	console.log(\'sum或msg变化了\',newValue,oldValue)\n  }) \n  \n  /* 情况三：监视reactive定义的响应式数据\n  			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n  			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n  */\n  watch(person,(newValue,oldValue)=>{\n  	console.log(\'person变化了\',newValue,oldValue)\n  },{immediate:true,deep:false}) //此处的deep配置不再奏效\n  \n  //情况四：监视reactive定义的响应式数据中的某个属性\n  watch(()=>person.job,(newValue,oldValue)=>{\n  	console.log(\'person的job变化了\',newValue,oldValue)\n  },{immediate:true,deep:true}) \n  \n  //情况五：监视reactive定义的响应式数据中的某些属性\n  watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{\n  	console.log(\'person的job变化了\',newValue,oldValue)\n  },{immediate:true,deep:true})\n  \n  //特殊情况\n  watch(()=>person.job,(newValue,oldValue)=>{\n      console.log(\'person的job变化了\',newValue,oldValue)\n  },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n  ```\n\n### 3.watchEffect函数\n\n- watch的套路是：既要指明监视的属性，也要指明监视的回调。\n\n- watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\n- watchEffect有点像computed：\n\n  - 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n  - 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n  ```js\n  //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\n  watchEffect(()=>{\n      const x1 = sum.value\n      const x2 = person.age\n      console.log(\'watchEffect配置的回调执行了\')\n  })\n  ```\n\n## 8.生命周期\n\n<div style=\"border:1px solid black;width:380px;float:left;margin-right:20px;\"><strong>vue2.x的生命周期</strong><img src=\"https://cn.vuejs.org/images/lifecycle.png\" alt=\"lifecycle_2\" style=\"zoom:33%;width:1200px\" /></div><div style=\"border:1px solid black;width:510px;height:985px;float:left\"><strong>vue3.0的生命周期</strong><img src=\"https://v3.cn.vuejs.org/images/lifecycle.svg\" alt=\"lifecycle_2\" style=\"zoom:33%;width:2500px\" /></div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n- Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\n  - ```beforeDestroy```改名为 ```beforeUnmount```\n  - ```destroyed```改名为 ```unmounted```\n- Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\n  - `beforeCreate`===>`setup()`\n  - `created`=======>`setup()`\n  - `beforeMount` ===>`onBeforeMount`\n  - `mounted`=======>`onMounted`\n  - `beforeUpdate`===>`onBeforeUpdate`\n  - `updated` =======>`onUpdated`\n  - `beforeUnmount` ==>`onBeforeUnmount`\n  - `unmounted` =====>`onUnmounted`\n\n## 9.自定义hook函数\n\n- 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。\n\n- 类似于vue2.x中的mixin。\n\n- 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。\n\n\n\n## 10.toRef\n\n- 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。\n- 语法：```const name = toRef(person,\'name\')```\n- 应用:   要将响应式对象中的某个属性单独提供给外部使用时。\n\n\n- 扩展：```toRefs``` 与```toRef```功能一致，但可以批量创建多个 ref 对象，语法：```toRefs(person)```\n\n\n# 三、其它 Composition API\n\n## 1.shallowReactive 与 shallowRef\n\n- shallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n- shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n- 什么时候使用?\n  -  如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。\n  -  如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。\n\n## 2.readonly 与 shallowReadonly\n\n- readonly: 让一个响应式数据变为只读的（深只读）。\n- shallowReadonly：让一个响应式数据变为只读的（浅只读）。\n- 应用场景: 不希望数据被修改时。\n\n## 3.toRaw 与 markRaw\n\n- toRaw：\n  - 作用：将一个由```reactive```生成的<strong style=\"color:orange\">响应式对象</strong>转为<strong style=\"color:orange\">普通对象</strong>。\n  - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n- markRaw：\n  - 作用：标记一个对象，使其永远不会再成为响应式对象。\n  - 应用场景:\n    1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。\n    2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n## 4.customRef\n\n- 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n\n- 实现防抖效果：\n\n  ```vue\n  <template>\n  	<input type=\"text\" v-model=\"keyword\">\n  	<h3>{{keyword}}</h3>\n  </template>\n  \n  <script>\n  	import {ref,customRef} from \'vue\'\n  	export default {\n  		name:\'Demo\',\n  		setup(){\n  			// let keyword = ref(\'hello\') //使用Vue准备好的内置ref\n  			//自定义一个myRef\n  			function myRef(value,delay){\n  				let timer\n  				//通过customRef去实现自定义\n  				return customRef((track,trigger)=>{\n  					return{\n  						get(){\n  							track() //告诉Vue这个value值是需要被“追踪”的\n  							return value\n  						},\n  						set(newValue){\n  							clearTimeout(timer)\n  							timer = setTimeout(()=>{\n  								value = newValue\n  								trigger() //告诉Vue去更新界面\n  							},delay)\n  						}\n  					}\n  				})\n  			}\n  			let keyword = myRef(\'hello\',500) //使用程序员自定义的ref\n  			return {\n  				keyword\n  			}\n  		}\n  	}\n  </script>\n  ```\n\n  \n\n## 5.provide 与 inject\n\n<img src=\"https://v3.cn.vuejs.org/images/components_provide.png\" style=\"width:300px\" />\n\n- 作用：实现<strong style=\"color:#DD5145\">祖与后代组件间</strong>通信\n\n- 套路：父组件有一个 `provide` 选项来提供数据，后代组件有一个 `inject` 选项来开始使用这些数据\n\n- 具体写法：\n\n  1. 祖组件中：\n\n     ```js\n     setup(){\n     	......\n         let car = reactive({name:\'奔驰\',price:\'40万\'})\n         provide(\'car\',car)\n         ......\n     }\n     ```\n\n  2. 后代组件中：\n\n     ```js\n     setup(props,context){\n     	......\n         const car = inject(\'car\')\n         return {car}\n     	......\n     }\n     ```\n\n## 6.响应式数据的判断\n\n- isRef: 检查一个值是否为一个 ref 对象\n- isReactive: 检查一个对象是否是由 `reactive` 创建的响应式代理\n- isReadonly: 检查一个对象是否是由 `readonly` 创建的只读代理\n- isProxy: 检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理\n\n# 四、Composition API 的优势\n\n## 1.Options API 存在的问题\n\n使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。\n\n<div style=\"width:600px;height:370px;overflow:hidden;float:left\">\n    <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image\" style=\"width:600px;float:left\" />\n</div>\n<div style=\"width:300px;height:370px;overflow:hidden;float:left\">\n    <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image\" style=\"zoom:50%;width:560px;left\" /> \n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 2.Composition API 的优势\n\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n<div style=\"width:500px;height:340px;overflow:hidden;float:left\">\n    <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image\"style=\"height:360px\"/>\n</div>\n<div style=\"width:430px;height:340px;overflow:hidden;float:left\">\n    <img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image\"style=\"height:360px\"/>\n</div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 五、新的组件\n\n## 1.Fragment\n\n- 在Vue2中: 组件必须有一个根标签\n- 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n- 好处: 减少标签层级, 减小内存占用\n\n## 2.Teleport\n\n- 什么是Teleport？—— `Teleport` 是一种能够将我们的<strong style=\"color:#DD5145\">组件html结构</strong>移动到指定位置的技术。\n\n  ```vue\n  <teleport to=\"移动位置\">\n  	<div v-if=\"isShow\" class=\"mask\">\n  		<div class=\"dialog\">\n  			<h3>我是一个弹窗</h3>\n  			<button @click=\"isShow = false\">关闭弹窗</button>\n  		</div>\n  	</div>\n  </teleport>\n  ```\n\n## 3.Suspense\n\n- 等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n- 使用步骤：\n\n  - 异步引入组件\n\n    ```js\n    import {defineAsyncComponent} from \'vue\'\n    const Child = defineAsyncComponent(()=>import(\'./components/Child.vue\'))\n    ```\n\n  - 使用```Suspense```包裹组件，并配置好```default``` 与 ```fallback```\n\n    ```vue\n    <template>\n    	<div class=\"app\">\n    		<h3>我是App组件</h3>\n    		<Suspense>\n    			<template v-slot:default>\n    				<Child/>\n    			</template>\n    			<template v-slot:fallback>\n    				<h3>加载中.....</h3>\n    			</template>\n    		</Suspense>\n    	</div>\n    </template>\n    ```\n\n# 六、其他\n\n## 1.全局API的转移\n\n- Vue 2.x 有许多全局 API 和配置。\n  - 例如：注册全局组件、注册全局指令等。\n\n    ```js\n    //注册全局组件\n    Vue.component(\'MyButton\', {\n      data: () => ({\n        count: 0\n      }),\n      template: \'<button @click=\"count++\">Clicked {{ count }} times.</button>\'\n    })\n    \n    //注册全局指令\n    Vue.directive(\'focus\', {\n      inserted: el => el.focus()\n    }\n    ```\n\n- Vue3.0中对这些API做出了调整：\n\n  - 将全局的API，即：```Vue.xxx```调整到应用实例（```app```）上\n\n    | 2.x 全局 API（```Vue```） | 3.x 实例 API (`app`)                        |\n    | ------------------------- | ------------------------------------------- |\n    | Vue.config.xxxx           | app.config.xxxx                             |\n    | Vue.config.productionTip  | <strong style=\"color:#DD5145\">移除</strong> |\n    | Vue.component             | app.component                               |\n    | Vue.directive             | app.directive                               |\n    | Vue.mixin                 | app.mixin                                   |\n    | Vue.use                   | app.use                                     |\n    | Vue.prototype             | app.config.globalProperties                 |\n  \n\n## 2.其他改变\n\n- data选项应始终被声明为一个函数。\n\n- 过度类名的更改：\n\n  - Vue2.x写法\n\n    ```css\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n    }\n    .v-leave,\n    .v-enter-to {\n      opacity: 1;\n    }\n    ```\n\n  - Vue3.x写法\n\n    ```css\n    .v-enter-from,\n    .v-leave-to {\n      opacity: 0;\n    }\n    \n    .v-leave-from,\n    .v-enter-to {\n      opacity: 1;\n    }\n    ```\n\n- <strong style=\"color:#DD5145\">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持```config.keyCodes```\n\n- <strong style=\"color:#DD5145\">移除</strong>```v-on.native```修饰符\n\n  - 父组件中绑定事件\n\n    ```vue\n    <my-component\n      v-on:close=\"handleComponentEvent\"\n      v-on:click=\"handleNativeClickEvent\"\n    />\n    ```\n\n  - 子组件中声明自定义事件\n\n    ```vue\n    <script>\n      export default {\n        emits: [\'close\']\n      }\n    </script>\n    ```\n\n- <strong style=\"color:#DD5145\">移除</strong>过滤器（filter）\n\n  > 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n- ......', '2022-11-27', 7, '[\"vue\"]', 25, 0),
(2, 'React扩展', '在学习react当中存在的一些不足之处加以补充,包括setState的两种写法、懒加载的使用、Hook函数、Fragment、context、组件优化', '## 1. setState\n\n### setState更新状态的2种写法\n\n```\n	(1). setState(stateChange, [callback])------对象式的setState\n            1.stateChange为状态改变对象(该对象可以体现出状态的更改)\n            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\n					\n	(2). setState(updater, [callback])------函数式的setState\n            1.updater为返回stateChange对象的函数。\n            2.updater可以接收到state和props。\n            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\n总结:\n		1.对象式的setState是函数式的setState的简写方式(语法糖)\n		2.使用原则：\n				(1).如果新状态不依赖于原状态 ===> 使用对象方式\n				(2).如果新状态依赖于原状态 ===> 使用函数方式\n				(3).如果需要在setState()执行后获取最新的状态数据, \n					要在第二个callback函数中读取\n```\n\n\n\n------\n\n\n\n## 2. lazyLoad\n\n### 路由组件的lazyLoad\n\n```js\n	//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包\n	const Login = lazy(()=>import(\'@/pages/Login\'))\n	\n	//2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面\n	<Suspense fallback={<h1>loading.....</h1>}>\n        <Switch>\n            <Route path=\"/xxx\" component={Xxxx}/>\n            <Redirect to=\"/login\"/>\n        </Switch>\n    </Suspense>\n```\n\n\n\n------\n\n\n\n## 3. Hooks\n\n#### 1. React Hook/Hooks是什么?\n\n```\n(1). Hook是React 16.8.0版本增加的新特性/新语法\n(2). 可以让你在函数组件中使用 state 以及其他的 React 特性\n```\n\n#### 2. 三个常用的Hook\n\n```\n(1). State Hook: React.useState()\n(2). Effect Hook: React.useEffect()\n(3). Ref Hook: React.useRef()\n```\n\n#### 3. State Hook\n\n```\n(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作\n(2). 语法: const [xxx, setXxx] = React.useState(initValue)  \n(3). useState()说明:\n        参数: 第一次初始化指定的值在内部作缓存\n        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数\n(4). setXxx()2种写法:\n        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值\n        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值\n```\n\n#### 4. Effect Hook\n\n```\n(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)\n(2). React中的副作用操作:\n        发ajax请求数据获取\n        设置订阅 / 启动定时器\n        手动更改真实DOM\n(3). 语法和说明: \n        useEffect(() => { \n          // 在此可以执行任何带副作用操作\n          return () => { // 在组件卸载前执行\n            // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n          }\n        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n    \n(4). 可以把 useEffect Hook 看做如下三个函数的组合\n        componentDidMount()\n        componentDidUpdate()\n    	componentWillUnmount() \n```\n\n#### 5. Ref Hook\n\n```\n(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据\n(2). 语法: const refContainer = useRef()\n(3). 作用:保存标签对象,功能与React.createRef()一样\n```\n\n\n\n------\n\n\n\n## 4. Fragment\n\n### 使用\n\n	<Fragment><Fragment>\n	<></>\n\n### 作用\n\n> 可以不用必须有一个真实的DOM根标签了\n\n\n\n<hr/>\n\n## 5. Context\n\n### 理解\n\n> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n### 使用\n\n```js\n1) 创建Context容器对象：\n	const XxxContext = React.createContext()  \n	\n2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：\n	<xxxContext.Provider value={数据}>\n		子组件\n    </xxxContext.Provider>\n    \n3) 后代组件读取数据：\n\n	//第一种方式:仅适用于类组件 \n	  static contextType = xxxContext  // 声明接收context\n	  this.context // 读取context中的value数据\n	  \n	//第二种方式: 函数组件与类组件都可以\n	  <xxxContext.Consumer>\n	    {\n	      value => ( // value就是context中的value数据\n	        要显示的内容\n	      )\n	    }\n	  </xxxContext.Consumer>\n```\n\n### 注意\n\n	在应用开发中一般不用context, 一般都用它的封装react插件\n\n\n\n<hr/>\n\n\n## 6. 组件优化\n\n### Component的2个问题 \n\n> 1. 只要执行setState(),即使不改变状态数据, 组件也会重新render() ==> 效率低\n>\n> 2. 只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==> 效率低\n\n### 效率高的做法\n\n>  只有当组件的state或props数据发生改变时才重新render()\n\n### 原因\n\n>  Component中的shouldComponentUpdate()总是返回true\n\n### 解决\n\n	办法1: \n		重写shouldComponentUpdate()方法\n		比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false\n	办法2:  \n		使用PureComponent\n		PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true\n		注意: \n			只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  \n			不要直接修改state数据, 而是要产生新数据\n	项目中一般使用PureComponent来优化\n\n\n\n<hr/>\n\n\n## 7. render props\n\n### 如何向组件内部动态传入带内容的结构(标签)?\n\n	Vue中: \n		使用slot技术, 也就是通过组件标签体传入结构  <A><B/></A>\n	React中:\n		使用children props: 通过组件标签体传入结构\n		使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性\n\n### children props\n\n	<A>\n	  <B>xxxx</B>\n	</A>\n	{this.props.children}\n	问题: 如果B组件需要A组件内的数据, ==> 做不到 \n\n### render props\n\n	<A render={(data) => <C data={data}></C>}></A>\n	A组件: {this.props.render(内部state数据)}\n	C组件: 读取A组件传入的数据显示 {this.props.data} \n\n\n\n<hr/>\n\n## 8. 错误边界\n\n#### 理解：\n\n错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面\n\n#### 特点：\n\n只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误\n\n##### 使用方式：\n\ngetDerivedStateFromError配合componentDidCatch\n\n```js\n// 生命周期函数，一旦后台组件报错，就会触发\nstatic getDerivedStateFromError(error) {\n    console.log(error);\n    // 在render之前触发\n    // 返回新的state\n    return {\n        hasError: true,\n    };\n}\n\ncomponentDidCatch(error, info) {\n    // 统计页面的错误。发送请求发送到后台去\n    console.log(error, info);\n}\n```\n## 9. 组件通信方式总结\n\n#### 组件间的关系：\n\n- 父子组件\n- 兄弟组件（非嵌套组件）\n- 祖孙组件（跨级组件）\n\n#### 几种通信方式：\n\n		1.props：\n			(1).children props\n			(2).render props\n		2.消息订阅-发布：\n			pubs-sub、event等等\n		3.集中式管理：\n			redux、dva等等\n		4.conText:\n			生产者-消费者模式\n\n#### 比较好的搭配方式：\n		父子组件：props\n		兄弟组件：消息订阅-发布、集中式管理\n		祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)\n\n', '2022-11-27', 7, '[\"React\"]', 26, 0),
(8, 'react基础', '一些关于react的基础', '## 一、todoList案例相关知识点\n		1.拆分组件、实现静态组件，注意：className、style的写法\n		2.动态初始化列表，如何确定将数据放在哪个组件的state中？\n					——某个组件使用：放在其自身的state中\n					——某些组件使用：放在他们共同的父组件state中（官方称此操作为：状态提升）\n		3.关于父子之间通信：\n				1.【父组件】给【子组件】传递数据：通过props传递\n				2.【子组件】给【父组件】传递数据：通过props传递，要求父提前给子传递一个函数\n		4.注意defaultChecked 和 checked的区别，类似的还有：defaultValue 和 value\n		5.状态在哪里，操作状态的方法就在哪里\n\n## 二、github搜索案例相关知识点\n		1.设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。\n		2.ES6小知识点：解构赋值+重命名\n					let obj = {a:{b:1}}\n					const {a} = obj; //传统解构赋值\n					const {a:{b}} = obj; //连续解构赋值\n					const {a:{b:value}} = obj; //连续解构赋值+重命名\n		3.消息订阅与发布机制\n					1.先订阅，再发布（理解：有一种隔空对话的感觉）\n					2.适用于任意组件间通信\n					3.要在组件的componentWillUnmount中取消订阅\n		4.fetch发送请求（关注分离的设计思想）\n					try {\n						const response= await fetch(`/api1/search/users2?q=${keyWord}`)\n						const data = await response.json()\n						console.log(data);\n					} catch (error) {\n						console.log(\'请求出错\',error);\n					}\n\n\n## 三、路由的基本使用\n			1.明确好界面中的导航区、展示区\n			2.导航区的a标签改为Link标签\n						<Link to=\"/xxxxx\">Demo</Link>\n			3.展示区写Route标签进行路径的匹配\n						<Route path=\'/xxxx\' component={Demo}/>\n			4.<App>的最外侧包裹了一个<BrowserRouter>或<HashRouter>\n\n## 四、路由组件与一般组件\n			1.写法不同：\n						一般组件：<Demo/>\n						路由组件：<Route path=\"/demo\" component={Demo}/>\n			2.存放位置不同：\n						一般组件：components\n						路由组件：pages\n			3.接收到的props不同：\n						一般组件：写组件标签时传递了什么，就能收到什么\n						路由组件：接收到三个固定的属性\n											history:\n														go: ƒ go(n)\n														goBack: ƒ goBack()\n														goForward: ƒ goForward()\n														push: ƒ push(path, state)\n														replace: ƒ replace(path, state)\n											location:\n														pathname: \"/about\"\n														search: \"\"\n														state: undefined\n											match:\n														params: {}\n														path: \"/about\"\n														url: \"/about\"\n\n## 五、NavLink与封装NavLink\n				1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名\n\n## 六、Switch的使用\n				1.通常情况下，path和component是一一对应的关系。\n				2.Switch可以提高路由匹配效率(单一匹配)。\n\n## 七、解决多级路径刷新页面样式丢失的问题\n				1.public/index.html 中 引入样式时不写 ./ 写 / （常用）\n				2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）\n				3.使用HashRouter\n\n## 八、路由的严格匹配与模糊匹配\n				1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）\n				2.开启严格匹配：<Route exact={true} path=\"/about\" component={About}/>\n				3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由\n\n## 九、Redirect的使用	\n				1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由\n				2.具体编码：\n						<Switch>\n							<Route path=\"/about\" component={About}/>\n							<Route path=\"/home\" component={Home}/>\n							<Redirect to=\"/about\"/>\n						</Switch>\n\n## 十、嵌套路由\n				1.注册子路由时要写上父路由的path值\n				2.路由的匹配是按照注册路由的顺序进行的\n\n## 十一、向路由组件传递参数\n				1.params参数\n							路由链接(携带参数)：<Link to=\'/demo/test/tom/18\'}>详情</Link>\n							注册路由(声明接收)：<Route path=\"/demo/test/:name/:age\" component={Test}/>\n							接收参数：this.props.match.params\n				2.search参数\n							路由链接(携带参数)：<Link to=\'/demo/test?name=tom&age=18\'}>详情</Link>\n							注册路由(无需声明，正常注册即可)：<Route path=\"/demo/test\" component={Test}/>\n							接收参数：this.props.location.search\n							备注：获取到的search是urlencoded编码字符串，需要借助querystring解析\n				3.state参数\n							路由链接(携带参数)：<Link to={{pathname:\'/demo/test\',state:{name:\'tom\',age:18}}}>详情</Link>\n							注册路由(无需声明，正常注册即可)：<Route path=\"/demo/test\" component={Test}/>\n							接收参数：this.props.location.state\n							备注：刷新也可以保留住参数\n\n\n\n## 十二、编程式路由导航\n					借助this.prosp.history对象上的API对操作路由跳转、前进、后退\n							-this.prosp.history.push()\n							-this.prosp.history.replace()\n							-this.prosp.history.goBack()\n							-this.prosp.history.goForward()\n							-this.prosp.history.go()\n\n## 十三、BrowserRouter与HashRouter的区别\n			1.底层原理不一样：\n						BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。\n						HashRouter使用的是URL的哈希值。\n			2.path表现形式不一样\n						BrowserRouter的路径中没有#,例如：localhost:3000/demo/test\n						HashRouter的路径包含#,例如：localhost:3000/#/demo/test\n			3.刷新后对路由state参数的影响\n						(1).BrowserRouter没有任何影响，因为state保存在history对象中。\n						(2).HashRouter刷新后会导致路由state参数的丢失！！！\n			4.备注：HashRouter可以用于解决一些路径错误相关的问题。\n\n## 十四、antd的按需引入+自定主题\n			1.安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader\n			2.修改package.json\n					....\n						\"scripts\": {\n							\"start\": \"react-app-rewired start\",\n							\"build\": \"react-app-rewired build\",\n							\"test\": \"react-app-rewired test\",\n							\"eject\": \"react-scripts eject\"\n						},\n					....\n			3.根目录下创建config-overrides.js\n					//配置具体的修改规则\n					const { override, fixBabelImports,addLessLoader} = require(\'customize-cra\');\n					module.exports = override(\n						fixBabelImports(\'import\', {\n							libraryName: \'antd\',\n							libraryDirectory: \'es\',\n							style: true,\n						}),\n						addLessLoader({\n							lessOptions:{\n								javascriptEnabled: true,\n								modifyVars: { \'@primary-color\': \'green\' },\n							}\n						}),\n					);\n				4.备注：不用在组件里亲自引入样式了，即：import \'antd/dist/antd.css\'应该删掉', '2022-11-27', 7, '[\"React\"]', 1, 0),
(9, 'Redux', 'Redux循序渐进,从手动挡到自动挡', '## 1.求和案例_redux精简版\n		(1).去除Count组件自身的状态\n		(2).src下建立:\n						-redux\n							-store.js\n							-count_reducer.js\n	\n		(3).store.js：\n					1).引入redux中的createStore函数，创建一个store\n					2).createStore调用时要传入一个为其服务的reducer\n					3).记得暴露store对象\n	\n		(4).count_reducer.js：\n					1).reducer的本质是一个函数，接收：preState,action，返回加工后的状态\n					2).reducer有两个作用：初始化状态，加工状态\n					3).reducer被第一次调用时，是store自动触发的，\n									传递的preState是undefined,\n									传递的action是:{type:\'@@REDUX/INIT_a.2.b.4}\n	\n		(5).在index.js中监测store中状态的改变，一旦发生改变重新渲染<App/>\n				备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。\n\n\n## 2.求和案例_redux完整版\n		新增文件：\n			1.count_action.js 专门用于创建action对象\n			2.constant.js 放置容易写错的type值\n\n\n\n## 3.求和案例_redux异步action版\n		 (1).明确：延迟的动作不想交给组件自身，想交给action\n		 (2).何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。\n		 (3).具体编码：\n		 			1).yarn add redux-thunk，并配置在store中\n		 			2).创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务。\n		 			3).异步任务有结果后，分发一个同步的action去真正操作数据。\n		 (4).备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。\n\n\n\n\n\n## 4.求和案例_react-redux基本使用\n			(1).明确两个概念：\n						1).UI组件:不能使用任何redux的api，只负责页面的呈现、交互等。\n						2).容器组件：负责和redux通信，将结果交给UI组件。\n			(2).如何创建一个容器组件————靠react-redux 的 connect函数\n							connect(mapStateToProps,mapDispatchToProps)(UI组件)\n								-mapStateToProps:映射状态，返回值是一个对象\n								-mapDispatchToProps:映射操作状态的方法，返回值是一个对象\n			(3).备注1：容器组件中的store是靠props传进去的，而不是在容器组件中直接引入\n			(4).备注2：mapDispatchToProps，也可以是一个对象\n\n\n## 5.求和案例_react-redux优化\n			(1).容器组件和UI组件整合一个文件\n			(2).无需自己给容器组件传递store，给<App/>包裹一个<Provider store={store}>即可。\n			(3).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。\n			(4).mapDispatchToProps也可以简单的写成一个对象\n			(5).一个组件要和redux“打交道”要经过哪几步？\n							(1).定义好UI组件---不暴露\n							(2).引入connect生成一个容器组件，并暴露，写法如下：\n									connect(\n										state => ({key:value}), //映射状态\n										{key:xxxxxAction} //映射操作状态的方法\n									)(UI组件)\n							(4).在UI组件中通过this.props.xxxxxxx读取和操作状态\n\n\n\n## 6.求和案例_react-redux数据共享版\n			(1).定义一个Pserson组件，和Count组件通过redux共享数据。\n			(2).为Person组件编写：reducer、action，配置constant常量。\n			(3).重点：Person的reducer和Count的Reducer要使用combineReducers进行合并，\n					合并后的总状态是一个对象！！！\n			(4).交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”。\n\n## 7.求和案例_react-redux开发者工具的使用\n			(1).yarn add redux-devtools-extension\n			(2).store中进行配置\n					import {composeWithDevTools} from \'redux-devtools-extension\'\n					const store = createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))\n\n## 8.求和案例_react-redux最终版\n			(1).所有变量名字要规范，尽量触发对象的简写形式。\n			(2).reducers文件夹中，编写index.js专门用于汇总并暴露所有的reducer', '2022-11-27', 7, '[\"redux\",\"React\"]', 5, 0),
(10, 'Vue组件间通信方式', '简要概述了Vue不同层级组件之间的通信通信方式', '注意:组件通信在你们将来面试的时候出现频率超级高。、\n\n前面基础的时候：组件通信讲了6种？\n\n\n组件通信方式1：props\n使用场景:[父子通信]\n\n传递数据类型：\n1:可能是函数  -----------实质子组件想给父亲传递数据\n2:可能不是函数-----------实质就是父亲给子组件传递数据\n<TodoList :todos=\"123\"  updateChecked=\"hander\">\n\n特殊情况：路由传递props\n1:布尔值类型，把路由中params参数映射为组件props数据\n2:对象，静态数据，很少用\n3:函数，可以把路由中params|query参数映射为组件props数据\n\n\n\n组件通信方式2:自定义事件   $emit  $on[简写@]\n事件:原生DOM事件----【click|mouseenter........】\n事件：自定义事件-----[子给父传递数据]\n\n\n组件通信方式3：$bus 全局事件总线----【万能】\n组件实例的原型的原型指向的Vue.prototype\n\n\n组件通信方式4：pubsub-js【发布订阅消息】*****在vue中根本不用【React】 ----万能\n\n\n组件通信方式5:Vuex[仓库]  -----数据非持久化----万能的\n\n核心概念：5\nstate \nmutations\nactions \ngetters \nmodules\n\n\n组件通信方式6：插槽-----父子通信【结构】\nslot\n\n默认插槽\n具名插槽\n作用域插槽:子组件的数据来源于父组件，但是子组件的自己的结构有父亲决定。\n\n\n\nwatch|computed|method区别?\n{\n    name:\'王二麻子\',\n    eat:function(){\n\n    }\n\n}\n\n\n\n1:事件相关的深入学习\n\n事件:事件已经学习过两种，第一种原生DOM事件，第二种自定义事件。\n\n<Event1 @click=\"handler1\"></Event1>\n组件绑定原生DOM事件，并非原生DOM事件，而是所谓的自定义事件。\n如果你想把自定义事件变为原生DOM事件，需要加上修饰符.native修饰\n这个修饰符，可以把自定义事件【名字：原生DOM类型的】变为原生DOM事件，\n\n\n7:v-model实现组件通信？\n\nv-model：指令，可以收集表单数据【text、radio、checkbox、range】等等\n切记：v-model收集checkbox需要用数组收集\n\nv-model:实现原理   :value  @input  还可以实现父子数据同步。\n<CustomInput v-model=\"msg\"></CustomInput>\n\n\n\n8:属性修饰符.sync，可以实现父子数据同步。\n以后在elementUI组件中出现，实现父子数据同步。\n\n\n\n\n9：$attrs与$listeners   ----vue-helper  父子组件通信\n$attrs：组件实例的属性，可以获取到父亲传递的props数据（前提子组件没有通过props接受）\n$listeners：组件实例的属性，可以获取到父亲传递自定义事件（对象形式呈现）\n\n\n\n10:$children与$parent       可以实现父子组件通信\nref:可以在父组件内部获取子组件---实现父子通信\n$children:可以在父组件内部获取全部的子组件【返回数组】\n$parent:可以在子组件内部获取唯一的父组件【返回组件实例】\n\n\n\n\n\n\n\n\n\n\n第一种:props ----父子\n1:父子通信，props只读的\n2：写法三种【todos】 {todos：Array} {todos：{type:Arrat,default:[]}}\n3：路由props\n\n\n第二种:自定义事件\n1：子给父传递数据\n2：两种【简单写法|复杂写法】\n<Todos @erha=\"handler\">\n<Todos ref=\'erha\'>\nmounted(){\n  this.$refs.erha.$on(\'xx\',callBack)\n}\n\n\n3:全局事件总线  ---万能\n\n\n4：pubsub-js------万能\n\n\n5：vuex------万能\n\n\n6：v-model\n\n\n7：.sync\n\n\n8:$attrs|$listeners\n\n\n9:$children|$parent    ----ref\n\n\n\n10插槽 ------作用于插槽\n插槽：父子组件通信（HTML结构）\n插槽slot：\n默认插槽|具名插槽|作用于插槽\n\n作用域插槽:子组件的数据来源于父组件，但是子组件决定不了自身结构与外观。\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\"]', 10, 0),
(12, 'JavaScript高级部分01', '简要记录了学习过程,包含声明提升、函数提升、宿主环境（window）、作用域、匿名函数解决全局污染、闭包实现私有变量、arguments、函数重载、浅拷贝', '# JSCORE01\n\n## 声明提升\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>变量 09:30</title>\n  </head>\n  <body>\n    <!-- \n      变量: variable\n      \n      什么是变量: 内存中开辟的一个空间, 起了名字\n     -->\n    <script>\n      // var: 代表在内存上开辟空间\n      // a : 代表为空间起名\n\n      // 此方式称为: 声明变量\n      var a\n\n      // = : 赋值符号\n      // 把 数字10 存储到 名字是a 的内存里\n      a = 10\n      // 用 \'mike\' 覆盖 a中的值\n      a = \'mike\'\n\n      // 语法角度: 合写\n      var a = 20 // 声明a变量, 然后进行赋值操作\n\n      // 升级:\n      // 内存中如何操作??\n      // 前提: 内存中同一个区域内同名变量只能有一个\n      // 如果多次声明, 只有第一次生效, 其他会自动忽略\n      var b\n      var b\n      var b\n    </script>\n  </body>\n</html>\n\n```\n\n\n\n## 声明提升\n\n> 作者为了程序员, 做了很多`自动化`的操作 -- 可以把`错误代码`自动`改对`\n>\n> - 比如: 声明和赋值操作写反了, JS引擎会自动颠倒过来\n>\n> - 比如: `3 * \'12\' +true`\n>\n>   在数学运算中, 表达式中都应该是数字类型; 一旦有非法的类型, JS会隐式做转换 - 尽量猜测用户的意图, 让错误的代码能正确运行\n>\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>声明提升 09:42</title>\n  </head>\n  <body>\n    <script>\n      // 理论上顺序: 先开辟内存空间, 然后把值存到里面去\n\n      // JS的奇葩处理机制: 声明提升\n      // 程序员所见到的JS代码, 并非其运行时的真正样子\n      // JS代码的运行过程\n\n      // 如下: 把10放到a里面,  然后声明内存a\n      a = 10\n      var a\n\n      // log\n      console.log(\'a:\', a)\n    </script>\n  </body>\n</html>\n\n```\n\n\n\n\n\n## 函数提升\n\n> 函数提升时, 如果有同名函数则 `后面`的覆盖`前面`的\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>练习 10:18</title>\n  </head>\n  <body>\n    <script>\n      // 所有编程语言, 只有JS 存在声明提升\n      // JS源代码 -> JS引擎处理 -> 再实际运行\n      function a() {\n        console.log(1)\n      }\n      a()\n\n      function a() {\n        console.log(2)\n      }\n      a()\n    </script>\n  </body>\n</html>\n\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>练习 10:30</title>\n  </head>\n  <body>\n    <script>\n      // var/let/const: 声明变量    var 变量名; 不含赋值操作\n      // function: 函数(函数名+函数体)\n      var a = function () {\n        console.log(1)\n      }\n      a()\n\n      var a = function () {\n        console.log(2)\n      }\n      a()\n    </script>\n  </body>\n</html>\n\n```\n\n\n\n## 面试真题\n\n> 官方说法: 函数比var 提升的优先级更高\n>\n> https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting\n>\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>练习 10:43</title>\n  </head>\n  <body>\n    <script>\n      // 面试真题: 说一说运行后的弹窗都是什么\n      alert(a)\n      a()\n      var a = 3\n      function a() {\n        alert(10)\n      }\n      alert(a)\n      a = 6\n      a()\n    </script>\n  </body>\n</html>\n\n```\n\n\n\n> 总结:\n>\n> - 作者非常贴心做了`自动化功能` -- 为了代码能正常执行, JS v8引擎会自动按照一定的规则来调整代码, 然后再执行\n> - 实际开发时: 要求程序员`最好能`直接书写正确的代码 -- 让所有人阅读代码更轻松\n>   - 即: 书写JS代码时, 把函数写在最开头. 然后书写其他代码\n\n\n\n## 宿主环境 window\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>window 宿主环境 11:21</title>\n  </head>\n  <body>\n    <!-- \n      宿主环境: 寄生关系,  A寄生在B身上, 就说B是A的宿主\n      JS 运行在什么环境中, 这个环境就是其宿主\n      - node.js:  JS在node环境中运行, 就能操作服务器.数据库..\n      - 浏览器: JS在浏览器中运行, 就能操作浏览器的各种功能\n     -->\n    <script>\n      // window: 此变量是对象类型, 由浏览器提供, 其中存储了操作浏览器相关的各种API-接口\n      console.log(window)\n\n      // alert: 弹窗功能\n      window.alert(\'Hello Window!\')\n\n      // 简化: 所有window中的属性都可以直接用, 不用加前缀\n      alert(\'1111\')\n    </script>\n  </body>\n</html>\n\n```\n\n## 作用域\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>作用域 11:35</title>\n  </head>\n  <body>\n    <!-- 作用域: 是对一些具有特殊功能的 对象变量 的称呼 -->\n    <script>\n      // JS具有4大作用域对象:\n      // ES6前: 2015年前, JS第6版本前: 全局作用域 和 局部作用域\n      // ES6后: 脚本作用域 和 块级作用域\n\n      // 全局作用域: 用于存放系统API 的对象\n      // 在浏览器中, 就是 window 对象\n      console.log(window)\n\n      // 请问 变量a 存放在哪里?\n      var a = 10\n\n      // 所有在脚本中用var声明的变量, 会存储在  window 这个全局作用域对象里\n      // 这个现象称为: 全局变量污染\n      // window对象的初衷是 系统提供的用来存放 系统API 的对象\n      // 把自定义的变量, 放在window里, 污染了...\n      // 例如: [\'亮亮\', \'泡泡\', \'小新\', \'涛涛\', \'志远\']\n\n      // 局部作用域: 函数在触发后临时生成的作用域对象\n\n      // 函数有两种状态: 静态 和 动态\n\n      // 静态的:  属于列了一个计划, 还没开始实施\n      function x() {\n        // 问题: 这里的 b 和 c 存放在哪里?\n        // 在函数运行时, `临时` 生成的对象里\n        // 需要借助浏览器的断点调试功能, 才能查看到\n        //\n        // 函数中声明的变量: 存放在函数作用域 而非全局\n        // 所以: 没有全局变量污染\n        var b = 10\n        var c = 20\n        console.log(b, c)\n      }\n\n      // 动态: 调用函数 -- 按照计划开始运行其中内容\n      x()\n    </script>\n  </body>\n</html>\n\n```\n\n\n\n## 断点\n\n\n\n\n\n## 匿名函数解决全局污染\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>匿名函数 12:01</title>\n</head>\n\n<body>\n  <script>\n    // 如果书写JS代码时, 不想污染全局 则 把代码书写在函数里\n    // 匿名函数语法 (function(){})()\n    // 可以快速调用自身, 形成一个 局部作用域\n    (function () {\n      // 这里书写的变量都是局部的, 不会造成全局污染\n      // 所以: 在ES65前, 脚本中基本上都要写个匿名函数, 然后在这里书写代码\n      var a = 10\n      var b = 20\n      console.log(a + b);\n    })()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 回顾\n\n- 书写JS代码时, 应该把函数书写在最上方\n  - 因为 JS引擎会自动调整代码顺序 : `函数在最上, 其次是声明, 最后其他代码`\n- 为了防止JS中代码的全局污染, 最好在脚本中用 `匿名函数` 生成`局部作用域`, 然后在匿名函数中书写代码\n\n\n\n## 闭包\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>closure 闭包 14:04</title>\n</head>\n\n<body>\n  <!-- \n    JS的设定:\n\n    函数对象拥有一个 scopes 属性: 作用域们\n    - 保存了 函数所在的 所有作用域\n    - 其中全局作用域叫 global\n    -- 其中函数/局部作用域 叫 closure 闭包\n\n    为什么要存?\n    - 避免作用域释放/销毁, 导致使用到这个作用域中的变量随之释放\n    - 例如: a函数中使用了name变量, 而 name变量是 displayName作用域的, 为了避免 displayName作用域释放, 导致name变量消失, 所以把 displayName作用域 保存在自身的scopes里\n   -->\n\n\n  <script>\n    function displayName() {\n      // 变量name: 在displayName函数作用域中\n      var name = \'亮亮\'\n\n      function a() {\n        // 作用域链: 如果函数中使用一个变量, 按照就近原则, 使用离的最近的;  顺序 自身->上级 -> 上上级 -> 上上上级....\n        console.log(name)\n      }\n\n      // JS: 万物皆对象, 所以函数也是对象类型\n      // 打印方式: \n      // log: 打印出的是美化后的, 并非对象类型\n      // dir: direct 直接.  打印出函数的本质\n      console.dir(a)\n\n      return a\n    }\n\n    // a函数中的name变量 属于 displayName 的函数作用域\n    // 函数/局部作用域: 临时生成的, 会在执行完毕后释放\n    var a = displayName()\n    a()\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:29</title>\n</head>\n\n<body>\n  <script>\n    // 闭包: 是保存在函数的scopes中的 其他函数作用域\n    // 目的: 防止释放, 导致使用到的 来自这些作用域的变量销毁\n\n    // JS垃圾回收机制: 如果一个对象, 没有被其他代码所使用,就会自动释放\n    // 被闭包存储索引的 作用域, 不会释放\n    function a() {\n      var aa = 10\n\n      function b() {\n        var bb = 20\n\n        function c() {\n          var cc = 30\n\n          function d() {\n            var dd = 40\n\n            function e() {\n              var ee = 50\n              console.log(aa, bb, dd, ee);\n            }\n            console.dir(e)  //猜猜scopes的内容?\n            // 1. 只存储外部的其他作用域\n            // 2. 保存顺序按照就近原则\n            // 3. 智能省内存: 只保存用到的变量所在作用域\n          }\n          d()\n        }\n        c()\n      }\n      b()\n    }\n    a()\n  </script>\n</body>\n\n</html>\n```\n\n## 闭包实现私有变量\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>私有变量 14:45</title>\n</head>\n\n<body>\n  <script>\n    // 公有: 所有函数都能用\n    // var wife = \'泡泡\'\n\n\n    // 制作函数私有变量的固定语法:\n    // var 函数 = (function(){\n    //    声明变量: 均为私有的...\n    //    return function(){}\n    // })()\n\n    var cc = (function () {\n      // wife:在匿名函数里\n      var wife = \'泡泡\'\n\n      // return 函数\n      // 必须返回到外部, 暴露到外部, 才能在外部使用\n      return function () {\n        console.log(\'cc的妻子:\', wife);\n      }\n    })()\n    // cc的scopes属性里, 保存了 wife变量所在的作用域\n    console.dir(cc)\n    cc()\n\n    function aa() {\n      console.log(\'aa媳妇是:\', wife);\n    }\n    aa()\n\n    function bb() {\n      console.log(\'bb媳妇是:\', wife)\n    }\n    bb()\n\n    /////////////////////////////\n    function x() {\n      // return 3\n      return function () { }\n    }\n\n    var z = x()\n\n    // 合写格式 \n    var z = (function x() {\n      // return 3\n      return function () { }\n    })()\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 15:20</title>\n</head>\n\n<body>\n  <script>\n    // 更多的使用场景: 看扩展视频 -- 百度网盘(xin88.top)\n    //\n    // 任务: 制作一个变量 num, 记录函数show的调用次数\n    var show = (function () {\n      var num = 0\n\n      return function () {\n        // var num = 0\n        num++\n        console.log(\'num:\', num);\n      }\n    })()\n\n    show()\n    show()\n    num = 100\n    show()\n    show()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## arguments\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>arguments 15:31</title>\n</head>\n\n<body>\n  <!-- arguments: 参数们  -->\n  <!-- 函数自带的关键词: 其中存放函数收到的所有实参 -->\n  <script>\n    function show() {\n      console.log(arguments);\n    }\n\n    show(\'谦哥\', 42, true, [\'抽烟\', \'喝酒\', \'烫头\'])\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 15:37</title>\n</head>\n\n<body>\n  <script>\n    // 使用场景: 制作不固定参数数量的函数\n    // 最大值 max\n    console.log(Math.max(12, 35, 45))\n\n    console.log(Math.max(132, 435, 45, 123, 435, 4))\n\n    console.log(Math.max(12, 35, 45, 5, 67, 6723))\n\n    // 仿造\n    function max() {\n      // 如果实参个数不固定, 那么无法声明对应的形参, 则只能用arguments\n      console.log(arguments);\n      // 逻辑: 编程的本质就是把人类的思维方式 转为 代码, 告诉计算机如何执行.\n      // 把序号0 作为临时最大的\n      var max = arguments[0]\n\n      // 挨个比较, 有更大的就\n      for (var i = 0; i < arguments.length; i++) {\n        var n = arguments[i]\n        if (n > max) {\n          max = n  //新数字更大, 就替换原值\n        }\n      }\n\n      return max  //返回最大的\n    }\n\n    console.log(max(1, 2));\n    console.log(max(1, 2, 435, 456, 567));\n    console.log(max(1, 2, 4, 56, 6, 87, 7, 432));\n\n    //////////////////////////////////\n    // 制作一个 avg 函数, 求出任意数量个数字的平均数\n    function avg() {\n      var s = 0\n      // 遍历\n      for (var i = 0; i < arguments.length; i++) {\n        s += arguments[i]\n      }\n\n      return s / arguments.length\n    }\n\n    console.log(avg(12, 43, 43))\n    console.log(avg(12, 43, 243, 65, 7, 21))\n    console.log(avg(12, 43, 2, 4, 546, 67, 78, 9))\n  </script>\n</body>\n\n</html>\n```\n\n### 函数重载\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>函数的重载 16:21</title>\n</head>\n\n<body>\n  <script>\n    // 多功能函数制作\n\n    // 商场打折, 有几个方案:\n    // 1. 指定折扣  0.7  0.6 等...\n    // 2. 满减  满2000 -500\n    // 3. vip等级  vip1 9折  vip3 7折...\n\n    function zhekou(money) {\n      // 函数重载: 判断实参的个数 或 类型, 来执行不同的逻辑\n\n      // 如果3个参数: 就是满减\n      if (arguments.length == 3) {\n        var man = arguments[1]\n        var jian = arguments[2]\n        // 满足满减条件, 则减\n        // 语法糖: 通过语法简化后, 像吃糖一样幸福...\n        // if的{}只有一行, 可以不写{}\n        if (money >= man) money -= jian\n\n        console.log(\'满减:\', money)\n      }\n\n      // 如果2个参数\n      if (arguments.length == 2) {\n        // 类型是 number, 就打折\n        if (typeof arguments[1] == \'number\') {\n          money *= arguments[1]\n          console.log(\'折扣:\', money);\n        }\n\n        if (typeof arguments[1] == \'string\') {\n          var vipn = arguments[1]\n\n          if (vipn == \'vip1\') money *= 0.9\n          if (vipn == \'vip2\') money *= 0.8\n          if (vipn == \'vip3\') money *= 0.7\n\n          console.log(\'vip:\', money)\n        }\n      }\n    }\n\n    // 使用: 多功能\n    zhekou(3000, 0.7) // 7折\n    zhekou(3000, 2000, 500) // 满2000 减500\n    zhekou(3000, \'vip3\')  // 7折\n\n  </script>\n</body>\n\n</html>\n```\n\n### 重载练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 16:44</title>\n</head>\n\n<body>\n  <script>\n    // 制作 sum 函数, 能够实现如下效果:\n    function sum() {\n      if (arguments.length == 1) {\n        var s = 0\n        for (var i = 0; i <= arguments[0]; i++) {\n          s += i\n        }\n        console.log(s)\n      }\n\n      if (arguments.length == 2) {\n        var s = 0\n        for (var i = arguments[0]; i <= arguments[1]; i++) {\n          s += i\n        }\n        console.log(s)\n      }\n\n      if (arguments.length == 3) {\n        var s = 0\n\n        for (var i = arguments[0]; i <= arguments[1]; i += arguments[2]) {\n          s += i\n        }\n        console.log(s)\n      }\n    }\n\n    sum(50) // 1275\n    sum(800, 900) //85850\n    sum(1, 100, 5) // 970\n\n    sum(100)  //计算出 1 - 100 数字累加之和  5050\n\n    sum(50, 100) // 计算出 50 - 100 数字累加之和 ????\n\n    sum(100, 200, 3) // 计算出: 100 103 106 ... 199 数字之和, 即间隔3个数字之和 \n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 对象是引用类型\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>对象是引用类型 17:23</title>\n</head>\n\n<body>\n  <!-- \n    JS的数据类型分两类\n    - 基础类型: number string boolean null undefined + symbol bigInt\n    - 引用类型: object\n\n    内存的设计: 栈内存  + 堆内存\n    - 栈内存: 查询速度快, 存储内容少  -- 类似图书的目录\n    - 堆内存: 查询速度慢, 存放大量数据 -- 类似图书中 内容页\n   -->\n  <script>\n    var a = 10\n    var b = a\n    a = 20\n    console.log(b) // 10\n\n\n    var e1 = { age: 19 }\n    var e2 = e1\n    e1.age = 30\n    console.log(e2.age)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 浅拷贝\n\n> 如何真的复制一个对象 `而不是` 简单的引用传递\n\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>对象的克隆 17:44</title>\n</head>\n\n<body>\n  <!-- \n    浅拷贝: 适用于 对象的属性 都是普通数据类型的场景\n    \n    如果对象属性 存在 引用类型, 则需要深拷贝\n    -- 详见扩展视频\n   -->\n\n  <script>\n    var e1 = {\n      ename: \"泡泡\",\n      age: 29,\n      phone: \"10086\"\n    }\n\n    // 1. 制作空对象, 赋值给e2 变量\n    var e2 = {}\n\n    // 2. for..in 遍历e1对象\n    for (var key in e1) {\n      console.log(\'key:\', key);\n      var value = e1[key] // 属性名是变量, 要用方括号语法\n      console.log(\'value:\', value);\n      // 存储到 e2 对象里\n      e2[key] = value\n    }\n\n    console.log(e2)\n    console.log(\'e1==e2:\', e1 == e2) //false: 代表地址不同\n\n    e1.age = 1000\n    console.log(\'e2.age:\', e2.age)\n\n\n    ////////////////////////////\n    // 复习: 对象的访问器语法\n    var c = { x: 10, b: 20 }\n\n    // 点语法\n    console.log(c.x)\n    // 方括号语法: 特色支持变量\n    console.log(c[\'x\'])\n    var b = \'x\'\n\n    console.log(c.b) // 对象.属性名 :属性名写什么是什么\n    console.log(c[b]) // 对象[变量]: 找变量的值, 然后操作\n    // 实际上: 方括号语法就是为了变量做法而生\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 练习\n\n\n猜一猜下方代码的运行结果\n\n```js\n  <script>\n    var a = 10\n\n    function b() {\n      a = 20\n      console.log(a);\n    }\n    b()\n\n    console.log(a);\n  </script>\n```\n\n```js\n  <script>\n    var a = 10\n\n    function b() {\n      var a\n      a = 20\n      console.log(a) //20\n    }\n\n    b()\n    console.log(a);\n  </script>\n```\n\n```js\n  <script>\n    var a = 10\n\n    function b() {\n      a = 20\n      console.log(a);\n      var a\n    }\n\n    b()\n    console.log(a);\n  </script>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"JavaScript\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(13, 'Javascript高级部分02', '对之前的部分进行复习，学习了this指向、构造函数、原型、严格模式、配置对象属性等……', '# JSCORE02\n\n## 复习\n\n> 本阶段的重点: 利用 JS 来操作 DOM 元素\n\n- 代码书写方式: 把声明写到最上面\n\n  - JS引擎会`自动调整`JS代码的结构, 然后再执行\n  - 声明提升: 声明操作会被提升到作用域的顶部\n  - 要求: 不要让系统帮你提升, 而应该直接写出规范的代码 -- 阅读代码时没有歧义\n\n- 宿主环境: JS运行时所在的环境\n\n  - node.js\n  - 浏览器: 提供 window 对象, 其中包含 浏览器提供的各种API\n\n- 作用域: 一类特殊功能的对象类型的 称呼\n\n  - 全局作用域: 存放系统API的对象 -- window\n  - 局部作用域: 函数运行时产生的对象, 临时的--函数运行完会自动释放\n\n- 如何避免 var 声明变量的全局污染\n\n  - 脚本中, 利用 匿名函数自调用 创建一个局部作用域, 在这里书写代码\n\n- 闭包: closure\n\n  - 函数拥有一个 scopes 属性, 这个属性中存储了 函数使用到的变量 所在的作用域\n\n  - 这些外部作用域中, 函数作用域被称为 `闭包`\n\n  - 目的:防止函数作用域自动释放, 导致使用的变量消失的问题\n\n  - 利用闭包能够为函数制作私有变量\n\n    ```js\n    var 函数 = (function(){\n        var 变量= 值\n        \n        return function(){\n            变量\n        }\n    })()\n    ```\n\n- 函数的arguments属性\n\n  - 保存函数运行时, 收到的所有`实参`\n  - 用途\n    - 制作实参个数不固定的函数\n    - 函数重载: 通过if判断 实参的个数 或 类型 不同, 运行不同的代码逻辑\n\n- 对象是引用类型\n\n  - 基础数据类型直接把值存放在 栈内存里\n  - 对象/引用数据类型 把 其内存地址存储在 栈内存.  真正的值存储在堆内存\n\n## this\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>this 09:26</title>\n</head>\n\n<body>\n  <!-- \n    函数的两种用法:\n    1. 通过参数来接收 变化量  -- 最常见\n    2. 把函数放到对象里执行 -- 函数的关键词this 代表所在对象\n   -->\n\n  <script>\n    // 矩形对象, 有宽高属性\n    var r1 = { width: 100, height: 50 }\n    var r2 = { width: 10, height: 20 }\n\n    // 函数area: 算面积\n    function area(r) {\n      console.log(\'面积:\', r.width * r.height)\n    }\n\n    area(r1)\n    area(r2)\n\n    // 案例: 做核酸\n    // 核酸检测员: 会按照固定的流程 对 被检测人员 进行检测\n    // 核酸检测员 -- 函数          被检测人员 -- 实参\n\n    // 案例: 上门做核酸\n    // 核酸检测员 到 被检测人员的家里  进行核酸检测\n    // 函数 到 对象里 执行\n\n    function mian() {\n      // this 这个: 函数自带的一个属性, 代表函数所在的对象\n      // 核酸检测员上门, 检测 这个 住户\n      console.log(\'面积:\', this.width * this.height);\n      console.log(\'this:\', this)\n      console.log(this == r1)\n    }\n\n    // 步骤: 先把 mian 函数放到 对象 r1 里\n    r1.mian = mian\n    console.log(r1)\n    r1.mian()\n\n    // 对象.属性名\n    // 从对象中, 读取执行属性名的值\n    console.log(r1.height);\n    console.log(r1.width);\n    // 函数() 才能触发\n    r1.mian()\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 09:50</title>\n</head>\n\n<body>\n  <script>\n    // 立方体:\n    var c1 = { length: 10, width: 40, height: 50 }\n    var c2 = { length: 15, width: 30, height: 10 }\n\n    // 制作 volume 方法, 能够计算体积:  长x宽x高\n    // 用法: 把volume 方法放到对象里, 然后执行\n    function volume() {\n      // this: 这个对象\n      console.log(\'体积:\', this.length * this.width * this.height);\n    }\n\n    // c1\n    c1.xx = volume\n    console.log(c1)\n    c1.xx()\n\n    // c2\n    c2.yy = volume\n    c2.yy()\n\n    // 函数有一个方法: call -- 短暂拜访\n    // volume函数, 自动到 c2 对象里执行一次\n    volume.call(c2)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 构造函数\n\n![image-20220830110114256](assets/image-20220830110114256.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>构造函数 10:23</title>\n</head>\n\n<body>\n  <!-- 构造函数: 用于 构建创造 对象类型的函数, 称为构造函数 -->\n  <script>\n    // Date: 构造函数, 用来构建创造 日期对象\n    var d = new Date()\n    console.log(d) // log: 打印出美化后的样子\n    console.dir(d) // dir: 输出对象本身\n\n    // Array: 数组的构造函数.  [\'泡泡\', \'亮亮\'] 是语法糖\n    var names = new Array(\'泡泡\', \'亮亮\', \'铭铭\')\n    console.log(names)\n\n    // 函数\n    // 语法糖写法:\n    function a(x, y) { console.log(x + y) }\n    a(10, 20)\n    console.log(a)\n\n    // 函数真正的 构造语法:\n    var b = new Function(\'x\', \'y\', \'console.log(x + y)\')\n    b(40, 50)\n    console.log(b)\n\n    // JS的本质: 所有的数据类型, 都是 构造函数 构建出来的对象\n    new Number(); new Boolean(); new String();\n  </script>\n</body>\n\n</html>\n```\n\n## 自定义构造\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>自定义构造函数 10:37</title>\n</head>\n\n<body>\n  <script>\n    // 构造矩形对象的 构造函数\n\n    // 构造函数命名规范: 大驼峰命名法  - 首字母大写\n    function Rect(length, width) {\n      var obj = {} //1.制作空对象\n\n      obj.length = length //2.添加属性\n      obj.width = width\n\n      // 问题点: 每次构造函数调用, 都需要为对象临时创建 面积和周长的方法,  而这个方法明显可以共享使用\n      // 所以: 可以考虑提取到外部 实现共享, 提升对象的制作效率\n      // 官方解决此问题: 原型理论\n\n      //面积:\n      obj.area = function () {\n        //this: 这个,  运行时所在的这个对象\n        console.log(\'面积:\', this.width * this.length);\n      }\n\n      // 周长\n      obj.zc = function () {\n        console.log(\'周长:\', (this.width + this.length) * 2);\n      }\n\n      return obj // 3. 返回组装完毕的对象\n    }\n\n    // 构造函数: 调用后, 制作对象\n    var r1 = Rect(10, 4)\n    console.log(\'r1:\', r1);\n    r1.area() // area是r1触发的, 所以其this是r1\n    r1.zc()\n\n    var r2 = Rect(20, 55)\n    console.log(\'r2:\', r2);\n    r2.area() // area是r2 触发的, 所以其this是r2\n    r2.zc()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 原型理论\n\n- 构造函数: 用来构建创造对象的函数\n- 对象应该具有一些 公有的方法\n\n![image-20220830112627630](assets/image-20220830112627630.png)\n\n![image-20220830113018696](assets/image-20220830113018696.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>原型理论 11:30</title>\n</head>\n\n<body>\n  <script>\n    // Object是最基础的 对象的构造函数\n\n    // 函数对象拥有一个 prototype 属性: 用于存放共享方法\n\n    // Rect:函数, 构造函数是 Function\n    function Rect(length, width) {\n      var obj = {} //创造新对象 -- 怀胎\n\n      obj.length = length // 添加属性 - 长身体\n      obj.width = width\n\n      // 告知对象, 共享属性存储在哪里, 地址在哪\n      // obj.共享方法所在 = 构造函数.prototype\n      //  __proto__ : 称为 原型链, 即 用于链接到原型的属性\n      obj.__proto__ = Rect.prototype\n\n      return obj // 出生\n    }\n\n    console.dir(Rect) //后台查看\n\n    // 把面积和周长方法, 放到 共享的原型对象里\n    Rect.prototype.area = function () {\n      return this.length * this.width\n    }\n\n    Rect.prototype.zc = function () {\n      return 2 * (this.length + this.width)\n    }\n\n    // 创建对象\n    var r1 = Rect(10, 5)\n    console.log(r1)\n    // 360浏览器的内核比较老, 看到的名字是未美化过的\n    // 每个对象类型都带有 __proto__, 用于保存父/构造函数提供的共享方法所在对象 prototype\n\n    console.log(r1.area());\n    // JS引擎的设定: 当使用对象的一个属性时, 如果找不到, 则会自动到其 原型链 保存的 地址中 查找\n\n    // 原型链机制: 对象自身没有的属性, 就到原型链中找, 按照这个规则, 一层层查找\n    // 类似: 儿子没钱, 找爸爸要, 爸爸没钱找爷爷要, 爷爷没钱则继续向上.... 直到根上..  都没有 就是undefined\n\n    console.log(r1.xxyy) // undefined\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:06</title>\n</head>\n\n<body>\n  <script>\n    // 制作一个构造函数, 用来生成立方体\n    function Cube(length, width, height) {\n      var obj = {}\n\n      obj.length = length\n      obj.height = height\n      obj.width = width\n\n      // 利用 原型链 属性, 链接到 构造函数的原型\n      obj.__proto__ = Cube.prototype\n\n      return obj\n    }\n\n    //原型: prototype\n    Cube.prototype.volume = function () {\n      return this.length * this.width * this.height\n    }\n\n    Cube.prototype.area = function () {\n      return 2 * (this.width * this.length + this.width * this.height + this.length * this.height)\n    }\n\n    Cube.prototype.zc = function () {\n      return (this.width + this.height + this.length) * 4\n    }\n\n    // 使用时:\n    var c1 = Cube(10, 20, 30) // 长, 宽, 高\n\n    console.log(c1)\n\n    // 为对象增加3个方法, 共享的, 要放原型里\n    console.log(c1.volume()) //体积=长x宽x高\n\n    console.log(c1.zc()) // 周长= (长+宽+高)*4\n\n    console.log(c1.area()) // 面积= 2*(长x宽+长x高+宽x高)\n\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:30</title>\n</head>\n\n<body>\n  <script>\n    // 构造函数的三个步骤: \n    // 1. 先完成函数 - 能够生成对象, 包含传入的属性\n    // 2. 在 原型中, 增加共享方法\n    // 3. 对象的原型链 链接到 原型\n\n    // 练习: 完成一个 制作 圆形对象 的构造函数\n    function Circle(radius) {\n      var obj = {}\n\n      obj.radius = radius\n\n      obj.__proto__ = Circle.prototype\n      return obj\n    }\n\n    Circle.prototype.zc = function () {\n      return 2 * 3.14 * this.radius\n    }\n\n    Circle.prototype.area = function () {\n      return 3.14 * this.radius * this.radius\n    }\n\n    var c1 = Circle(10) //半径: radius\n\n    console.log(c1)  // {radius: 10}\n\n    console.log(c1.zc()) //周长= 2*3.14*半径\n    console.log(c1.area()) //面积=3.14*半径*半径\n\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## new运算符\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>new 14:43</title>\n</head>\n\n<body>\n  <script>\n    // 作者提供了 new 运算符, 如果函数被这个运算符触发, 就会自动完成以下操作\n    function Circle(radius) {\n      // 关键词this:  在new运算符下, 代表创建出来的新对象\n      // var this = {}\n\n      this.radius = radius\n\n      // this.__proto__ = Circle.prototype\n      // return this\n    }\n\n    Circle.prototype.zc = function () {\n      return 2 * 3.14 * this.radius\n    }\n\n    Circle.prototype.area = function () {\n      return 3.14 * this.radius * this.radius\n    }\n\n    // new触发函数, 可以让构造函数里少写3行代码\n\n    var c1 = new Circle(10) //半径: radius\n\n    console.log(c1)  // {radius: 10}\n\n    console.log(c1.zc()) //周长= 2*3.14*半径\n    console.log(c1.area()) //面积=3.14*半径*半径\n\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:50</title>\n</head>\n\n<body>\n  <script>\n    // 完成矩形构造函数\n    function Rect(length, width) {\n      this.length = length\n      this.width = width\n    }\n\n    Rect.prototype.area = function () {\n      return this.length * this.width\n    }\n    Rect.prototype.zc = function () {\n      return 2 * (this.length + this.width)\n    }\n\n    var r1 = new Rect(10, 5) // 长 宽\n\n    console.log(r1) // {length:10, width:5}\n\n    console.log(r1.area()) //面积: 长x宽\n    console.log(r1.zc()) //周长: (长+宽)*2\n\n\n    ////////////////////////\n    var nums = [12, 3, 4535]\n\n    console.log(nums);\n    nums.push(333)\n\n    // 数组对象的原型链 是否等于 其构造函数的原型??\n    console.log(nums.__proto__ == Array.prototype);\n\n    console.log(Array.prototype);\n    Array.prototype.xx = function () {\n      alert(\'xxxxx\')\n    }\n    // 可以给系统对象的构造函数的原型里, 添加新的方法--扩展原型\n    // nums.xx()\n  </script>\n</body>\n\n</html>\n```\n\n## 严格模式\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>严格模式 15:21</title>\n</head>\n\n<body>\n  <script>\n    // ES5: JS的第五个版本  在2009年推出, 也称ES2009\n    // 新增了 严格模式 特性\n    // 如何JS开启严格模式, 则会带有更多的报错; 强制程序员书写更加健壮的代码\n\n    // 由于单词拼错: 导致全局污染, 错误的新增了属性\n    // 在脚本的开头增加 \'use strict\' 字符串, 则下方被严格模式管理\n    \'use strict\'\n    // 在严格模式下: 变量必须先声明 后使用\n    // 如果变量名写错, 导致找不到这个变量, 就会报错!\n\n    var servername = \'localhost\'\n    // 修改:\n    servename = \'www.tedu.cn\'\n\n\n    console.log(window) //找一找 servername\n    console.log(servername);\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>严格模式 15:33</title>\n</head>\n\n<body>\n  <script>\n    // 严格模式下: 函数中的this如果指向window, 则改为undefined; 避免全局污染\n    \'use strict\'\n    // 全局中声明, 存放在window里\n    // 问题: 构造函数忘记用new触发, 则会在 全局window中 意外的增加属性 -- 全局污染\n    function Rect(length, width) {\n      console.log(\'this:\', this);\n      this.length = length\n      this.width = width\n    }\n\n    // 理论上: 构造函数 一定要用 new 触发\n    // 一旦忘了呢??\n    var r1 = Rect(10, 30)\n    // window.Rect()\n    console.log(r1)\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>严格模式 15:44</title>\n</head>\n\n<body>\n  <script>\n    // 实际工作中, 各种第三方框架默认都会开启严格模式\n    // 严格模式除了讲解的这三个之外, 还有更多的好处.. 可以慢慢体验\n\n    // 严格模式下: 取消静默失败, 增加更多的报错\n    \'use strict\'\n\n    var emp = { ename: \"泡泡\", age: 19 }\n\n    // 冻结对象: 会导致对象无法增删改\n    Object.freeze(emp)\n    // 静默失败: 修改未成功, 后台不报错 -- 非常难以查找\n    emp.age = 30\n\n    console.log(emp)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 配置对象属性\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>对象属性的配置 16:09</title>\n</head>\n\n<body>\n  <script>\n    \'use strict\'\n\n    var emp = {\n      ename: \"泡泡\",\n      age: 28,\n      eid: \'10020\', //编号\n    }\n    // 希望: 让 eid 属性无法被修改\n    // 所有操作对象的API 都在 Object 中存的\n    console.dir(Object)\n\n    // define定义 Property属性\n    // 参数1: 目标对象   参数2: 配置的属性名\n    // 参数3: 具体的配置项\n    // Object.defineProperty(emp, \'eid\', {\n    //   // ctrl + i :看提示\n    //   writable: false, //是否可以写入新的值 - 可写的\n    // })\n\n    // Object.defineProperty(emp, \'age\', {\n    //   writable: false\n    // })\n\n    // defineProperties: 一次性改多个\n    Object.defineProperties(emp, {\n      // 属性名: 配置项对象\n      eid: { writable: false },\n      age: { writable: false }\n    })\n\n    // emp.eid = true\n    emp.age = 40\n    console.log(emp)\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>配置属性 16:28</title>\n</head>\n\n<body>\n  <script>\n    var emp = {\n      ename: \"泡泡\",\n      age: 18,\n      salary: 20000, //薪资\n      married: true, //婚姻\n      phone: \'18798987778\'\n    }\n\n    // 配置某些属性不要被遍历\n    Object.defineProperties(emp, {\n      // enumerable: 可枚举的\n      // 多数浏览器会把 不可遍历的属性 改为浅色\n      age: { enumerable: false },  //false: 不可\n      married: { enumerable: false },\n      salary: { enumerable: false }\n    })\n\n    console.log(emp)\n\n    for (var key in emp) {\n      console.log(key, emp[key])\n    }\n\n    // 不可遍历针对的是for..in,  不是无法读取\n    console.log(emp.age)\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>定义属性 16:41</title>\n</head>\n\n<body>\n  <script>\n    \'use strict\'\n    // 可重新配置\n    var emp = {\n      ename: \"泡泡\",\n      age: 18,\n      husband: \'铁柱\', //丈夫\n    }\n    // 泡泡希望 丈夫属性的值 无法被修改\n    Object.defineProperty(emp, \'husband\', {\n      writable: false,\n      configurable: false, // 可配置的:  假代表后续无法再次配置\n    })\n\n    // 不可配置的属性 无法被删除\n    delete emp.husband\n\n    // 黑客: 改回可写的  -- 报错: 因为不允许重新配置\n    Object.defineProperty(emp, \'husband\', {\n      writable: true\n    })\n\n    emp.husband = \'杨洋\'\n\n    console.log(emp)\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>配置属性 16:52</title>\n</head>\n\n<body>\n  <script>\n    \'use strict\'\n\n    // 新增属性\n    var emp = { ename: \"泡泡\" }\n\n    // 两种常见的新增属性语法\n    emp.age = 18\n    emp[\'phone\'] = \'16898989777\'\n    // 传统新增属性方案: 新增的属性 权限都是开放的状态\n    // 可写, 可遍历, 可配置\n\n    // 用 define 方式新增不存在的属性, 权限全关: 不可写; 不可遍历; 不可配置\n    Object.defineProperty(emp, \'salary\', {\n      value: 20000, //值\n    })\n\n    // emp.salary = 8000 //没有修改权限\n    // delete emp.salary //没有删除权限\n\n    console.log(emp)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>配置属性 17:20</title>\n</head>\n\n<body>\n  <script>\n    // 语法糖: 作者提供了一些语法, 可以简化一些代码. 让程序员可以偷懒, 像吃糖一样幸福\n    var r1 = {\n      width: 10,\n      height: 20,\n      // 可以省略 :function\n      // area: function () { },\n      // get:关键词 -- 把函数修改成计算属性, 特点是不用() 就能自动触发\n      // 仅适用于 没有参数的函数\n      get area() {\n        return this.width * this.height\n      },\n      get zc() {\n        return (this.width + this.height) * 2\n      }\n    }\n    console.log(r1)\n    console.log(r1.zc) // 算出周长: (长+宽)*2\n\n    // (): 作用是触发函数 和 接收实参\n    console.log(r1.area)\n    console.log(r1.area)\n    console.log(r1.area)\n    console.log(r1.area)\n\n    ////////////////////////////\n    var c1 = { radius: 10 } // 圆形\n\n    // 添加一个 算直径的方法: dia\n    Object.defineProperty(c1, \'dia\', {\n      // 计算属性: get.  不需要() 就能自动触发的函数\n      // get: function () {\n      get() {\n        return this.radius * 2\n      }\n    })\n    console.log(c1)\n    console.log(c1.dia)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 内容回顾\n\n- this关键词: 让函数有了第二种用法\n  - 方式1: 把对象作为参数传递给函数, 进行处理\n  - 方式2: 把函数放到对象里运行 -- 函数的this关键词代表所在对象\n    - 函数.call(对象):  函数会临时放到对象里执行一次\n- 构造函数 和 原型理论\n  - 构造函数: 用于 构建创造 对象的函数, 称为构造函数\n  - 原型理论: 构造函数可以构造出很多个对象, 这些对象公共的方法怎么办\n    - 构造函数带有 `prototype` 原型对象属性, 用来存公共方法\n    - 对象在生成时, 用`__proto__`原型链属性, 链接到 构造函数的prototype\n  - 原型链机制: JS引擎提供的\n    - 当读取/使用 对象的属性时, 如果对象没有 则到 `__proto__` 链接的对象中查找使用\n  - new运算符: 简化构造函数的书写, 省略 3行代码\n    - 1. `this = {}`\n      2. `this.__proto__ = 构造函数.prototype`\n      3. `return this`\n\n- 严格模式:2009年 ES5 出品\n  - 在脚本的开头添加: `\'use strict\'` 即可开启严格模式\n  - 严格模式下, 代码提供更多的报错, 辅助程序员书写出更加健壮的代码\n  - 具体场景\n    - 变量必须先声明, 再使用\n    - 函数的this 是window 则改为undefined\n    - 取消静默失败: 提供更好的报错\n- 属性配置\n  - defineProperty: 配置单个属性;  defineProperties: 配置多个属性\n  - 配置项:\n    - writable: 不可修改值\n    - enumerable: 不可被遍历\n    - configurable: 不可重新配置\n    - value: 默认值\n    - get: 计算属性 -- 不需要() 就能自动触发的函数\n\n- 语法糖:   对象中属性的值是函数, 可以省略 `:function`\n\n  添加 get 前缀: 调用时不用()\n\n  ```js\n  var a ={\n      show: function(){},\n      get show(){}\n  }\n  ```\n\n  \n\n## 练习\n\n\n- 作业: 尝试用 Object.defineProperty 方式, 给矩形的原型里添加 周长和面积方法\n\n  能够自动触发的计算属性\n\n  ```js\n  var r1 = Rect(10, 20)\n  \n  console.log(r1.zc) //60\n  console.log(r2.area) //200\n  ```\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"JavaScript\"]', 0, 0),
(14, 'JavaScript高级部分03', '回顾之前的内容，学习Object.defineProperty、call、apply、bind、ES6新特性', '# JSCORE03\n\n## 内容回顾\n\n- this关键词 -- 支撑了函数的另一种用法\n\n  - 常规方案: 把 对象作为参数 传递到 函数中  -- `大家排队去做核酸检测`\n  - 方案2: 把函数放到对象里执行, this代表函数运行时所在的对象  -- `上门检测`\n    - `函数.call(对象)` : 函数 短暂访问 对象, 在对象中运行一次\n\n- 构造函数: 用于 构建创造 对象类型的 函数\n\n  - prototype: 原型; 属于构造函数的一个属性, 用于存放共享的方法\n\n  - `__proto__`: 原型`链`;  属于对象的属性, 用于链接到 原型`prototype`上\n\n    - 原型链机制: 当使用对象的属性时, 如果对象自身没有, 就会自动到 原型链 中查找\n\n  - new: 简化构造函数的书写, 自动完成3行代码\n\n    ```js\n    this = {}\n    this.__proto__ = 构造函数.prototype\n    return this\n    ```\n\n- ES5新特性 - 严格模式\n\n  - 在严格模式下, 书写的JS代码 将会提供更多的报错, 辅助程序员写出健壮的代码\n  - 开启方式: 脚本的开头书写 `\'use strict\'`\n  - 案例\n    - 变量必须声明后, 才能使用\n    - 函数中的this如果是window, 改为undefined\n    - 阻止静默失败\n\n- ES5 - 配置对象属性\n\n  - defineProperty 或 defineProperties\n  - 配置项\n    - writable: 是否可写\n    - enumerable: 是否可遍历\n    - configurable: 是否可重新配置\n    - value: 值\n    - get: 计算属性- 不用()就能触发的函数\n\n- 语法糖: 作者提供的一些简化语法, 让程序员少写一些, 像吃糖一样\n\n  - 对象中, 如果属性的值是函数\n\n  - get关键词: 函数无需()  自动触发\n\n    ```js\n    var a = {\n        show: function(){},\n        show(){},\n        get show(){}\n    }\n    ```\n\n## 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>作业 09:14</title>\n</head>\n\n<body>\n  <script>\n    function Rect(length, width) {\n      this.length = length\n      this.width = width\n    }\n\n    // 参数1: 目标对象\n    Object.defineProperties(Rect.prototype, {\n      zc: {\n        // get: 代表这个函数不用() 就自动触发\n        get() { return 2 * (this.width + this.length) }\n      },\n      area: {\n        get() { return this.length * this.width }\n      }\n    })\n\n    var r1 = new Rect(10, 20)\n    console.log(r1);\n    // 浏览器后台 展开查看对象内容: 会临时读取一次最新的\n    r1.xx = \'100\'\n\n    console.log(r1.zc);\n    console.log(r1.area);\n\n    console.log(\'8+8=\', 8 + 8);\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 监听器\n\n\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>属性配置 09:31</title>\n</head>\n\n<body>\n  <script>\n    \'use strict\'\n\n    var emp = { ename: \"泡泡\", age: 29 }\n\n    // _age: 是辅助 age 属性的, 在底层负责存储数据. 不应该被用户所察觉\n    // 此方案新增的_age属性: 不可写, 不可遍历, 不可配置\n    // 配置成 可写, 才能完成后续的赋值操作\n    Object.defineProperty(emp, \'_age\', { writable: true })\n\n    Object.defineProperty(emp, \'age\', {\n      // get: 计算属性\n      get() { return this._age },\n      // set: 设置\n      // set: function (value) {\n      set(value) {\n        console.log(\'age收到值:\', value)\n        // 要求: 年龄必须是数字类型\n        if (typeof value != \'number\') {\n          throw Error(\'age的值必须是数字! 传入的是\' + typeof value)\n        }\n\n        // 范围: 1 ~ 120\n        if (value >= 1 && value <= 120) {\n          // 正确的值, 就存起来, 制作一个变量, 负责存储数据\n          // 这种辅助 age 监听器, 用来存值的属性, 用_开头即可\n          // 约定俗成的命名方案, 不强制 但都这么写\n          this._age = value //要求_age可写\n        } else {\n          throw Error(\"age 范围在 1-120之间! \" + value)\n        }\n      }\n    })\n\n    // 对赋值操作进行监听, 确保赋值合理\n    // emp.age = 200\n    // emp.age = true\n    // emp.age = \'哈哈\'\n\n    emp.age = 27\n\n    console.log(emp)\n    // 读取age: 对于用户来说, 会认为 27 存储在 age 变量里\n    // 所以读取时, 也应该从age读\n    console.log(emp.age) //触发计算属性\n\n    // 遍历\n    for (var key in emp) {\n      console.log(key, emp[key])\n    }\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 10:41</title>\n</head>\n\n<body>\n  <script>\n    var emp = { ename: \"泡泡\", married: true }\n\n    // married: 代表婚姻状态,  只能接收布尔类型 boolean\n    Object.defineProperties(emp, {\n      _married: { writable: true }, //辅助存储数据, 要求可写\n      married: {\n        get() { return this._married },\n        set(value) {\n          if (typeof value == \'boolean\') {\n            this._married = value\n          } else {\n            throw Error(\"married赋值类型错误!\" + typeof value)\n          }\n        }\n      }\n    })\n\n    // emp.married = 666  // 报错: 提示类型错误\n    // emp.married = \'啊\' // 报错: 提示类型错误\n    emp.married = false // 正常赋值\n\n    console.log(emp.married) //打印出 false\n  </script>\n</body>\n\n</html>\n```\n\n## 保护对象\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>保护对象的方式 11:22</title>\n</head>\n\n<body>\n  <script>\n    // defineProperty: 用于配置对象中的 单个属性\n    \'use strict\'\n    // 直接配置整个对象\n    var emp = { ename: \"泡泡\", age: 18, married: false }\n\n    // 对象的操作分四种: 增删改查\n\n    // 阻止新增元素\n    // prevent:阻止 Extensions:扩展\n    Object.preventExtensions(emp)\n\n    // 阻止 增删  seal:密封\n    Object.seal(emp)\n\n    // 冻结 freeze : 阻止 增删改\n    Object.freeze(emp)\n\n    // emp.husband = \'铁柱\'\n    // delete emp.age\n    emp.age = 30\n  </script>\n</body>\n\n</html>\n```\n\n## call\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>call 11:35</title>\n</head>\n\n<body>\n  <script>\n    // 函数有两种用法: \n    // 1. 对象作为参数传递给函数\n    // 2. 函数传递到对象里执行 -- this\n    var r1 = { width: 10, length: 20 }\n\n    function area() {\n      return this.width * this.length\n    }\n\n    // 把函数放到 r1 对象里, 执行\n    r1.area = area\n    console.log(r1.area())\n    // 用完, 删掉\n    delete r1.area\n\n    console.log(r1)\n\n    console.dir(area) //看看原型链\n    // 函数的原型提供了 call方法, 能够短暂访问对象, 执行一次\n    // 到对象里, 运行, 撤退\n    console.log(area.call(r1))\n\n    // 体积: 长x宽x高\n    function volume(h) {\n      return this.length * this.width * h\n    }\n    // 把volume 放到 r1 对象里,  额外传递高度\n    // call(要进入的对象, 实参...)\n    console.log(volume.call(r1, 100));\n\n    ///////////////////////\n    var emp = { ename: \"泡泡\", age: 18, salary: 8000 }\n\n    // 计算某人 n年的 年薪总和\n    function total(n) {\n      return this.salary * 12 * n\n    }\n    // 使用: 5年\n    console.log(total.call(emp, 5));\n\n\n    // 函数: 计算出某个人 n 年后的年纪\n    function show(n) {\n      return this.age + n\n    }\n\n    // 在 emp 中执行show方法, 10年后的, 打印出结果  \n    console.log(show.call(emp, 10))\n  </script>\n</body>\n\n</html>\n```\n\n## apply\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>apply 14:01</title>\n</head>\n\n<body>\n  <script>\n    // 与 call 方法相同, apply 也能够让短暂访问对象\n    var r1 = { width: 10, length: 20 }\n\n    function area() {\n      return this.width * this.length\n    }\n    // area.短暂访问(r1)\n    console.log(area.call(r1))\n    // apply: 应用,  效果同call\n    console.log(area.apply(r1))\n\n    // 区别: 带有实参时\n    function volume(h, c) {\n      return this.width * this.length * h * c\n    }\n\n    var x = volume.call(r1, 100, 5)\n    console.log(x)\n    // 参数1: 要放到哪个对象里     参数2: 数组类型, 实参们\n    var x = volume.apply(r1, [100, 5])\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:17</title>\n</head>\n\n<body>\n  <!-- apply的用途: 提供把数组转为1个1个实参的方案-->\n  <script>\n    var x = Math.max(10, 30, 40, 23, 5)\n    console.log(x)\n\n    var nums = [12, 4, 54, 65, 76, 87, 9]\n    // max: 不接收数组作为参数, 只支持 1个1个数字\n    // var x = Math.max(nums)\n\n    // apply(要放哪个对象, 实参数组)\n    // 此场景中: 不需要放在某个对象里\n    var x = Math.max.apply(null, nums)\n\n    // 2015年的 ES6版本, 提供新语法: 展开语法 ...\n    // ...数组:  去掉数组的 [] 包围, 转为1个1个的值\n    var x = Math.max(...nums)\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n## bind\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>bind 14:35</title>\n</head>\n\n<body>\n  <!-- onclick: 按钮被鼠标点击的时候, 自动触发 -->\n  <!-- 有了bind方案: HTML少写点, JS多写点 -->\n  <button onclick=\"vol_bind()\">点我</button>\n  <!-- bind: 绑定而不触发,   call会直接触发 -->\n  <button onclick=\"volume.call(r1, 200)\">点我</button>\n\n  <!-- 解耦合: 最好让代码单纯一些 -->\n  <!-- HTML中不写 style, 用class , 把css写外部 -->\n\n  <script>\n    // bind: 捆绑\n    // 把对象和参数 捆绑到函数上, 生成新的函数, 延时调用\n    var r1 = { width: 10, length: 20 }\n\n    function volume(h) {\n      var x = this.width * this.length * h\n      alert(x)\n    }\n\n    var vol_bind = volume.bind(r1, 100)\n    console.dir(vol_bind) //展开查看 bind 有关的属性\n\n    // 通常和DOM操作的按钮点击捆绑\n  </script>\n</body>\n\n</html>\n```\n\n## ES6\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>ES6 15:05</title>\n</head>\n\n<body>\n  <!-- \n    ES6: JS的第六个版本, 在2015年6月推出, 后续不断在更新\n    ES5: 09年\n\n    推陈出新: 增加了很多新的语法糖, 简化旧版本的复杂语法\n    推荐网站:  https://es6.ruanyifeng.com/\n\n    ES6 : 泛指 下一代 JavaScript 语言,  即ES6 ES7 ES8 ...\n   -->\n</body>\n\n</html>\n```\n\n\n\n## let const\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>let 与 const 15:14</title>\n</head>\n\n<body>\n  <script>\n    // ES6提供 两个新的作用域: 脚本作用域 和 块级作用域\n\n    // var: 声明变量会造成全局污染\n    var a = 10\n\n    // ES6提供的声明变量方案: 声明的变量存储在脚本作用域\n    // let: 声明变量 - 后续可修改值\n    let aa = 20\n    aa = 30  //可修改\n\n    const bb = 30 // const: 声明常量 - 初始化赋值后不可修改\n    bb = 40\n\n    // 声明变量时, 要预判后期会不会有变化\n    // 泡泡的工资\n    let salary = 20000  // -- 预判可变化, 则let\n    // 泡泡的老公\n    const husband = \'铁柱\'  // -- 一辈子不能改, 安全可靠\n\n\n    // 解决污染: 在脚本中用匿名函数自调用,制作局部作用域来写代码\n    console.log(window)\n  </script>\n</body>\n\n</html>\n```\n\n## 声明提升\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>变量提升 15:30</title>\n</head>\n\n<body>\n  <script>\n    // JS引擎设定: 自动按照规矩 把JS代码规范一次, 然后再执行\n    // 如果程序员书写的代码不标准 则会影响阅读 : 因为真正执行的代码和你所写的代码是不同的!!\n    // 要求: 程序员应该规范书写的代码, 把声明放在使用前书写\n    // ES6前: 靠自觉\n\n    console.log(111)\n\n    // 报错: 在声明操作代码执行前, 不能使用变量\n    let a\n    a = 5\n\n    // 声明提升: 是JS的基础设定, 无法变更, 应该改动太大..\n    // 面试问题: let/const 有提升吗?\n    // 答: let/const 有提升;  但是有 暂存死区 的设定. 在声明代码行执行前, 不可使用\n    // 利用报错: 强制程序员书写规范的代码 -- 先声明再使用\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 块级作用域\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>块级作用域 15:46</title>\n</head>\n\n<body>\n  <script>\n    // 新的作用域: 块级作用域,  与 全局 局部 脚本 合称4大作用域\n\n    // {} 中书写 let/const 就会形成块级\n    {\n      let a = 10\n      const b = 20\n\n      console.log(111)\n    }\n\n    // 块级: 用来代替 局部/函数 作用域\n\n    // ES6前: 为了避免全局污染, 必须做一个局部作用域\n    // ; (function () {\n    //   for (var i = 0; i < 10; i++) {\n    //     console.log(\'i:\', i);\n    //   }\n    // })()\n\n    // ES6\n    for (let i = 0; i < 10; i++) {\n      console.log(\'i:\', i);\n    }\n\n    if (true) {\n      let a = 30 //块级\n    }\n\n    // switch, while\n\n    var obj = {\n      // let x = 30; //没有这种语法\n      属性名: \'值\'\n    }\n\n    // 函数的{} : 是局部作用域\n\n    console.log(window)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 模板字符串\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>模板字符串 16:18</title>\n</head>\n\n<body>\n  <ul id=\"box\">\n    <li>泡泡</li>\n    <li>亮亮</li>\n  </ul>\n\n  <script>\n    // 传统字符串使用: 单引号 或 双引号 做定界符\n    var a = \'Hello\'\n    var b = \"world!\"\n\n    // 随着JS和HTML的结合越来越紧密, 传统字符串写法有局限性\n    // 1. 换行问题 - 传统字符串中不支持回车换行\n    // 2. 变量的拼接问题\n    var x = \'涛涛\', y = \'小华\'\n\n    box.innerHTML = \'<li>铭铭</li><li>\' + x + \'</li><li>铭铭</li><li>铭铭</li><li>\' + y + \'</li><li>铭铭</li><li>铭铭</li>\'\n\n    // 模板字符串  -- 模板-代表HTML代码\n    // 符号: 反引号\n    // 利用 ${} 在 模板字符串中随意书写 JS 代码\n    box.innerHTML = `<li>泡泡</li>\n                    <li>${x}</li>\n                    <li>泡泡</li>\n                    <li>${y}</li>\n                    <li>泡泡</li>\n                    `\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 箭头\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>箭头函数 16:32</title>\n</head>\n\n<body>\n  <!-- ES6提供的全新的 匿名函数语法 -->\n  <script>\n    // 传统的匿名函数:  function(){}\n    // 箭头函数:       ()=>{}\n\n    const a = () => { console.log(\'箭头函数!\') }\n    a()\n\n    // 箭头函数提供了两个语法糖\n    // 糖1: 形参只有1个, ()可以省略\n    // const db = (x) => { return x * 2 }\n    // const db = x => { return x * 2 }\n\n    // 糖2: 函数体只有一行代码, 可以省略 {} 和 return\n    const db = x => x * 2\n    console.log(db(10))\n\n    // 尝试简化下方的函数\n    // const c = (y) => { return y + 2 }\n    const c = y => y + 2\n\n    // const d = (x, y) => { return x + y }\n    const d = (x, y) => x + y\n\n    // const e = (y) => { return y * y }\n    const e = y => y * y\n\n    // const f = (a, b, c) => { return a + b * c }\n    const f = (a, b, c) => a + b * c\n\n    // 试试\n    // const g = (a, b) => { return { a: a, b: b } }\n\n    // 坑: 如果返回值是对象类型, 对象的{} 会被错误识别为函数的{}\n    // 解决: 用() 括起来, 避免歧义\n    // {属性名: 值}  -> {属性名: 变量名} \n    // 如果巧合: 变量名和属性名 一样, 可以合写\n    // const g = (a, b) => ({ a: a, b: b })\n    const g = (a, b) => ({ a, b })\n\n    // 例如:\n    var uname = \'泡泡\', age = 18\n\n    // var obj = { uname: uname, age: age }\n    var obj = { uname, age }\n    console.log(obj)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## this\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>箭头函数this 17:18 </title>\n</head>\n\n<body>\n  <script>\n    // 作者把 this 关键词在多个场景中都使用了, 所以其作用需要根据具体场景 来分析\n\n    // function场景:\n    // 对象.函数名() :  this是 对象\n    // 函数名() : this是  window; 没有前缀的函数调用,都是window\n    // ---- 严格模式下是 undefined\n    // new 函数名(): this是 构造出的对象 -- 实例对象\n\n    // 箭头函数场景:\n    // 箭头函数没有构造功能, 不搭配new使用\n    // 箭头函数没有this关键词, 会通过作用域链机制 就近查找\n\n    var emp = {\n      ename: \"泡泡\",\n      show() {\n        // emp.show() : 所以show函数作用域中的this 就是emp\n        console.log(\'show的this:\', this)\n\n        const b = () => {\n          // 箭头函数没有this, 会根据作用域链的就近原则, 到上层作用域查找 - show函数\n          console.log(\'this:\', this)\n        }\n\n        b()\n      }\n    }\n\n    emp.show()\n  </script>\n</body>\n\n</html>\n```\n\n## 展开语法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>展开语法 17:36</title>\n</head>\n\n<body>\n  <script>\n    // 运算符 : ...\n    // ... 可以 `破盾` : 对象 和 数组的 外包围 [] {}\n    var a = [12, 32, 54]\n\n    var b = [88, 99, ...a]\n    console.log(b)\n    // max只接受 1个1个的传参, 用 ... 展开数组\n    var x = Math.max(...b)\n    console.log(x)\n\n    /////////////////////\n    var c = { m: 10, n: 18, x: 20 }\n    // 如果存在同名属性, 则后写的覆盖先写的\n    var d = { ...c, x: 40, y: 50 }\n\n    console.log(d)\n  </script>\n</body>\n\n</html>\n```\n\n## 解构语法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>解构语法 17:46</title>\n</head>\n\n<body>\n  <script>\n    var emps = [\'亮亮\', \'泡泡\', \'铭铭\']\n    // 把数组中的元素保存在单独的变量里\n    // var e0 = emps[0], e1 = emps[1], e2 = emps[2]\n\n    // 解构语法\n    var [e0, e1, e2] = emps\n    console.log(e0, e1, e2)\n\n    // 可选解构 :  不想要的可以不写\n    var [m0, , m1] = emps\n    console.log(m0, m1);\n\n    // 技巧:  巧妙的互换变量的值\n    var x = 10\n    var y = 50;\n    // x 和 y 的值互换\n    // 必须用; 间隔 [] 和上一行代码, 否则会 歧义.误会下标取值语法\n    [x, y] = [y, x]\n    console.log(x, y)\n\n    // 解析:\n    // 首先: 先组合出一个数组 [y,x]  -> [50, 10]\n    // 然后: 解构这个数组  [x, y] = [50, 10]\n  </script>\n</body>\n\n</html>\n```\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"JavaScript\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(15, 'JavaScript高级部分04', '解构赋值、数组方法、class语法', '# JSCORE04\n\n## 复习\n\n- ES5 中各种特性:\n  - 属性配置: defineProperty\n    - writable: 可写\n    - configurable: 可配置\n    - enumerable: 可遍历\n    - value: 默认值\n    - get: 计算属性 - 函数不需要() 能自动触发\n    - `set`: 监听器 - 让属性对赋值进行监听 -- 判断值是否合理 给用户一些提示\n      - 以后学习的各种框架中 大量被采用!   人工智能..\n- 保护对象的方式\n  - preventExtensions: 阻止 `新增` 元素\n  - seal : 阻止 `增删` 元素\n  - freeze : 阻止 `增删改` 元素\n\n- 函数的3个修改this指向的方法\n  - call : `短暂访问`  -- 让函数`临时`放到对象里运行一次\n  - apply : 函数临时放到对象里执行一次, 但是 实参用 数组传递\n  - bind : 把 对象和实参 绑定到函数上, 生成一个新的函数; -- `延时调用`场景\n\nES6: 2015年6月出品 的 JS 第六个版本,  划时代的意义;  后续ES6 泛指 新一代的JavaScript语言\n\n- let 和 const\n\n  - 两个新的声明变量的方案\n\n  - 脚本作用域: 用 let/const 在 脚本中声明的变量, 存储在脚本作用域 而 不是window\n\n  - 块级作用域: 代替 匿名函数自调用 产生的局部作用域\n\n    - 用 `{}` 配合 let/const 使用\n    - 语法中: for, if, while, switch 的 {} 都能实现块级\n\n  - 提升问题: 存在提升 但 有`暂存死区`设定;  通过报错强制必须先声明变量, 再使用变量\n\n    > 历史问题: JS作者`好心` 让JS引擎自动调整代码结构, 隐式调整为最规范的结构再执行 -- 例如: 声明提升, 隐式类型转换\n    >\n    > 但是: 有的用户滥用, 先用变量 后声明 就是错误的做法\n\n- 模板字符串: 专为HTML代码而生\n\n  - 写法: 用反引号做包围\n  - 优点1: 支持换行 -- 让JS中书写的HTML字符串 更容易阅读, 格式更好\n  - 优点2: 提供 `${}` 实现局部的JS代码\n\n- 箭头函数 -- 一种新的 匿名函数 语法\n\n  - `() => {}`\n  - 两个语法糖\n    - 形参只有1个, 省略()\n    - 函数体只有一行, 省略 `{} 和 return`\n  - this\n    - 箭头函数中: 没有this变量 -- 通过作用域链的就近原则 到最近的作用域里找\n\n- 展开语法: `...`\n\n  - ...数组: 去掉[]\n  - ...对象: 去掉{}\n\n- 解构语法:\n\n  - 数组解构:  `var [变量, 变量, ,变量] = [值, 值, 值, 值]`\n\n\n\n## 解构\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>解构语法 09:22</title>\n</head>\n\n<body>\n  <script>\n    var emp = {\n      ename: \"泡泡\",\n      age: 18,\n      phone: \'18798987788\'\n    }\n\n    // 把对象中的属性拿出来, 放变量里存\n    var ename = emp.ename, age = emp.age, phone = emp.phone\n\n    // 解构语法\n    var { ename, age, phone } = emp\n    console.log(ename, age, phone);\n\n    var emp1 = {\n      ename: \"凯凯\",\n      age: 32,\n      phone: \'16898987777\'\n    }\n    // 解构出属性, 打印出来\n    var { phone, ename, age } = emp1\n    console.log(phone, ename, age);\n\n    // 起别名语法\n    var sname = \'欢欢\'\n\n    var stu1 = { sname: \"铁柱\" }\n    // { 属性名: 别名 }\n    var { sname: s1name } = stu1\n\n    console.log(sname, s1name)\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 09:35</title>\n</head>\n\n<body>\n  <script>\n    var r1 = { length: 10, width: 20, height: 30 }\n\n    function volume() {\n      // return this.length * this.width * this.height\n      var { length: l, width: w, height: h } = this\n      return l * w * h\n    }\n\n    // 面积 = (长x宽 + 长x高 + 宽x高)*2\n    function area() {\n      // return (this.width * this.length + this.length * this.width + this.width * this.height) * 2\n\n      const { width: w, length: l, height: h } = this\n      return 2 * (w * l + l * h + w * h)\n\n      // 场景: 对于频繁读取的对象中的属性, 先解构再使用体验更好\n    }\n\n    var x = area.call(r1)\n    console.log(x)\n\n    var x = volume.call(r1)\n    console.log(x)\n\n    //////////////////////////\n    var r2 = { x: 10, y: 20 }\n    // 形参解构语法:  把传入的实参 直接解构\n    function add({ x, y }) {\n      // return r.x + r.y\n      // const { x, y } = r\n      return x + y\n    }\n\n    console.log(add(r2))\n\n    var m = { x: 10, y: 20, z: 30 }\n\n    // 计算出x y z 的乘积\n    function show({ x, y, z }) {\n      return x * y * z\n    }\n\n    console.log(show(m));\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 09:56</title>\n</head>\n\n<body>\n  <script>\n    // 复杂解构\n    var emp = {\n      ename: \"泡泡\",\n      age: 28,\n      married: true,\n      skills: [\'html\', \'css\', \'ajax\', \'scss\'],\n      desc: {\n        phone: \'18787879993\',\n        eid: \'10021\'\n      }\n    }\n\n    var { ename, age,\n      skills: [s1, s2, s3, s4],\n      desc: { phone, eid } } = emp\n\n    console.log(ename, age, s1, s2, s3, s4, phone, eid);\n\n    ///////////////////////\n    var stu = {\n      sname: \"凯凯\",\n      age: 32,\n      tags: [\'吃\', \'喝\', \'玩\', \'乐\'],\n      desc: {\n        gender: \"男\",\n        phone: \"18879798877\",\n      }\n    }\n\n    // 解构出stu中所有的属性,  age要求改为 sage\n    var { age: sage,\n      desc: { gender, phone },\n      sname,\n      tags: [t1, t2, t3, t4] } = stu\n\n    console.log(sage, sname, gender, phone, t1, t2, t3, t4);\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## every\n\n<img src=\"assets/image-20220901103543634.png\" alt=\"image-20220901103543634\" style=\"zoom: 67%;\" />\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>数组高阶函数 10:27</title>\n</head>\n\n<body>\n  <!-- 高阶函数: 函数中 使用了其他函数, 就叫高阶函数 -->\n  <!-- 最常见: 通过参数 接收外来的函数 -- 关联知识点-回调函数 -->\n\n  <script>\n    var nums = [12, 43, -65, 76, 87, 324, 6]\n\n    // 判断: 数组里是否每个数字 都是正数\n    // every: 每一个;  会自动遍历数组, 把每一个元素都传递给箭头函数进行处理\n    var x = nums.every((value, index, array) => {\n      // 固定3个参数: 元素本身, 序号, 所在数组\n      console.log(index, value, array);\n      console.log(\'---------------------\');\n      // 检测结果: 是否为正数\n      return value > 0\n    })\n\n    // every最终结果:  每个元素都满足条件,就是真; 如果有任意1个不满足条件, 则为假\n    console.log(\'x:\', x);\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 10:47</title>\n</head>\n\n<body>\n  <script>\n    var nums = [12, 43, 65, 7, 87, 98, 8]\n\n    // 判断是否都大于10\n    var x = nums.every((value, index, array) => {\n      return value > 10\n    })\n\n    // 简化1: 没有用到的形参, 可以不写\n    var x = nums.every((value) => {\n      return value > 10\n    })\n\n    // 简化2: 箭头函数的形参 只有1个时, 省略()\n    var x = nums.every(value => {\n      return value > 10\n    })\n\n    // 简化3: 箭头函数 函数体只要一行, 省略{} 和 return\n    var x = nums.every(value => value > 10)\n\n    // 简化4: 形参名 可以自定义  value -> v\n    var x = nums.every(v => v > 10)\n    console.log(x ? \'都大于10\' : \'非都大于10\');\n\n    // 练习: 判断是否都是 偶数.     对2取余 是0\n    var x = nums.every((value, index, array) => {\n      return value % 2 == 0\n    })\n\n    var x = nums.every(v => v % 2 == 0)\n    console.log(x ? \'都是偶数\' : \'非都是偶数\');\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 11:01</title>\n</head>\n\n<body>\n  <script>\n    var emps = [\n      { ename: \'泡泡1\', age: 28, married: true, salary: 20000 },\n      { ename: \'泡泡2\', age: 22, married: true, salary: 30000 },\n      { ename: \'泡泡3\', age: 31, married: true, salary: 22000 },\n      { ename: \'泡泡4\', age: 32, married: false, salary: 10000 },\n      { ename: \'泡泡5\', age: 20, married: true, salary: 26000 },\n    ]\n\n    // 任务1: 是否每个人都小于30岁\n    var x = emps.every(v => v.age < 30)\n    console.log(x ? \'都小于30\' : \'非都小于30\');\n    // 任务2: 是否都已婚\n    var x = emps.every(v => v.married)\n    console.log(x ? \'都已婚\' : \'非都已婚\');\n\n    // 任务3: 是否薪资都大于2W\n    var x = emps.every(v => v.salary > 20000)\n    console.log(x ? \'都大于2W\' : \'非都大于2W\')\n\n    // every 与 逻辑与 && 很相似:  全真则真; 有假则假\n  </script>\n</body>\n\n</html>\n```\n\n## some\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>some 11:31</title>\n</head>\n\n<body>\n  <script>\n    // some: 有一些 满足条件的元素\n    var nums = [12, 43, 65, 76, -7, 9, 325, 4]\n\n    // 判断: 是否 有 负数  -- 有就算真\n    var x = nums.some((value, index, array) => {\n      return value < 0\n    })\n\n    var x = nums.some(v => v < 0)\n    // 类似 逻辑或 || : 有真则真,全假为假\n\n    console.log(x ? \'有负数\' : \'没有负数\');\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 11:39</title>\n</head>\n\n<body>\n  <script>\n    var emps = [\n      { ename: \'泡泡1\', age: 28, married: true, salary: 20000 },\n      { ename: \'泡泡2\', age: 22, married: true, salary: 30000 },\n      { ename: \'泡泡3\', age: 31, married: true, salary: 22000 },\n      { ename: \'泡泡4\', age: 32, married: false, salary: 10000 },\n      { ename: \'泡泡5\', age: 20, married: true, salary: 26000 },\n    ]\n\n    // 1. 是否有人年龄超过30\n    var x = emps.some(v => v.age > 30)\n    console.log(x ? \'有人超过30\' : \'没人超过30\');\n\n    // 2. 是否有人未婚\n    var x = emps.some(v => !v.married)\n    console.log(x ? \'有人未婚\' : \'都已婚\');\n\n    // 3. 是否有人薪资小于1W\n    var x = emps.some(v => v.salary < 10000)\n    console.log(x ? \'有人小于1W\' : \'没人小于1W\');\n  </script>\n</body>\n\n</html>\n```\n\n## filter\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>filter 11:50</title>\n</head>\n\n<body>\n  <script>\n    // filter: 过滤器 -- 把满足条件的元素过滤出来, 组合成新数组\n    var nums = [1, 46, 67, 23, 5, 76, 98, 12]\n\n    // 找出所有 大于50 的数字\n    var x = nums.filter((value, index, array) => {\n      return value > 50\n    })\n\n    var x = nums.filter(v => v > 50)\n\n    console.log(x);\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 11:54</title>\n</head>\n\n<body>\n  <script>\n    var emps = [\n      { ename: \'泡泡1\', age: 28, married: true, salary: 20000 },\n      { ename: \'泡泡2\', age: 22, married: true, salary: 30000 },\n      { ename: \'泡泡3\', age: 31, married: true, salary: 22000 },\n      { ename: \'泡泡4\', age: 32, married: false, salary: 10000 },\n      { ename: \'泡泡5\', age: 20, married: true, salary: 26000 },\n    ]\n\n    // 1. 找出所有 年龄>30 的人\n    var x = emps.filter(v => v.age > 30)\n    console.log(x)\n    // 2. 找出所有 已婚 的人\n    var x = emps.filter(v => v.married)\n    console.log(x)\n    // 3. 找出薪资 小于2.5W 的人\n    var x = emps.filter(v => v.salary < 25000)\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n## map\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>map 14:01</title>\n</head>\n\n<body>\n  <!-- 映射: map  按照一定的规矩, 数组的值转换成别的样子 -->\n\n  <script>\n    var nums = [12, 43, 65, 87, 98, 90, 5]\n\n    // 把每个数字x2, 返回结果组成的数组\n    var x = nums.map((value, index, array) => {\n      return value * 2\n    })\n\n    var x = nums.map(v => v * 2)\n\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:08</title>\n</head>\n\n<body>\n  <div id=\"box\"></div>\n\n  <ul id=\"box1\">\n    <!-- 由于JS中写HTML代码没有提示, 习惯上会在HTML中先把 伪代码 写出来, 然后复制到JS里用 -->\n    <li>xx</li>\n  </ul>\n\n  <script>\n    var names = [\'亮亮\', \'泡泡\', \'小新\', \'铭铭\']\n    // 每个元素 转为 按钮标签  <button>xx</button>\n    var x = names.map(v => `<button>${v}</button>`)\n    console.log(x)\n\n    // 数组的元素, 拼接成字符串??\n    var y = x.join(\'\') // 参数代表间隔符号, 默认是逗号\n    console.log(y)\n\n    box.innerHTML = y\n\n    /////////////////////////\n    var x = names.map(v => `<li>${v}</li>`)\n\n    box1.innerHTML = x.join(\'\')\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:26</title>\n  <style>\n    #nav>a {\n      color: #333;\n      text-decoration: none;\n      margin: 10px;\n    }\n  </style>\n</head>\n\n<body>\n  <div id=\"nav\">\n    <a href=\"xxx\" title=\"xxx\">xxx</a>\n  </div>\n\n  <script>\n    var navs = [\n      { title: \"新闻\", href: \'http://www.news.com\' },\n      { title: \"hao123\", href: \'http://www.hao123.com\' },\n      { title: \"地图\", href: \'http://www.map.com\' },\n      { title: \"贴吧\", href: \'http://www.tieba.com\' },\n      { title: \"视频\", href: \'http://www.video.com\' },\n      { title: \"图片\", href: \'http://www.pic.com\' },\n    ]\n\n    var x = navs.map(v => {\n      const { href, title } = v\n\n      return `<a href=\"${href}\" title=\"${title}\">${title}</a>`\n    })\n\n    console.log(x)\n    nav.innerHTML = x.join(\'\')\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:41</title>\n  <style>\n    table {\n      border-collapse: collapse;\n    }\n\n    td {\n      border: 1px solid gray;\n      padding: 10px 20px;\n    }\n\n    thead {\n      background-color: #eee;\n    }\n  </style>\n</head>\n\n<body>\n  <table>\n    <thead>\n      <tr>\n        <td>序号</td>\n        <td>姓名</td>\n        <td>年龄</td>\n        <td>手机号</td>\n      </tr>\n    </thead>\n    <tbody id=\"box\">\n      <tr>\n        <td>1</td>\n        <td>xx</td>\n        <td>xx</td>\n        <td>xx</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <script>\n    var emps = [\n      { ename: \"泡泡\", age: 28, phone: \'18789987787\' },\n      { ename: \"凯凯\", age: 32, phone: \'18789989787\' },\n      { ename: \"梦瑶\", age: 16, phone: \'18767768787\' },\n      { ename: \"露露\", age: 22, phone: \'13489987787\' },\n      { ename: \"凯隐\", age: 26, phone: \'18679987787\' },\n    ]\n\n    // 任务:  数组 转 HTML, 添加到表格里\n    var x = emps.map((v, i) => {\n      const { age, ename, phone } = v\n      return `<tr>\n        <td>${i + 1}</td>\n        <td>${ename}</td>\n        <td>${age}</td>\n        <td>${phone}</td>\n      </tr>`\n    })\n\n    box.innerHTML = x.join(\"\")\n  </script>\n</body>\n\n</html>\n```\n\n## forEach\n\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>forEach 15:18</title>\n</head>\n\n<body>\n  <script>\n    // forEach: 遍历数组\n    var emps = [\'亮亮\', \'铭铭\', \'泡泡\', \'小新\']\n\n    // 1. 传统的for\n    for (let i = 0; i < emps.length; i++) {\n      console.log(i, emps[i]);\n    }\n\n    // 2. for..in : 遍历对象类型的通用方案\n    // 数组是特殊的对象: 属性名都是数字类型\n    for (let key in emps) {\n      console.log(key, emps[key])\n    }\n\n    // 3. ES6提供的 for..of : 专为数组设计\n    for (let value of emps) {\n      // 直接遍历值, 没有序号\n      console.log(value)\n    }\n\n    // 4. forEach : 真数组中具有的遍历方法 - 原型是Array\n    emps.forEach((value, index, array) => {\n      console.log(index, value)\n    })\n\n    // 假数组/伪数组/类数组 : 外观和数组一样, 但是原型不是Array\n    function show() {\n      // 原型不是Array的对象, 属性名是数字 酷似数组, 称为 伪数组\n      console.log(arguments);\n      // arguments.forEach()\n    }\n\n    show(12, 4, 54, 6, 67, 87, 87)\n\n    console.log(emps);\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 15:37</title>\n</head>\n\n<body>\n  <script>\n    var nums = [12, 43, 65, 76, 87, 89, 99]\n    // 要求: 得到所有数字之和\n\n    var s = 0\n    for (const num of nums) {\n      s += num\n    }\n    console.log(s)\n\n    ///////////////////////////\n    var s = 0\n    nums.forEach(num => s += num)\n    console.log(s)\n\n    /////////////////////////////////////\n    var emps = [\n      { ename: \"泡泡1\", salary: 18000, age: 23 },\n      { ename: \"泡泡2\", salary: 28000, age: 29 },\n      { ename: \"泡泡3\", salary: 8000, age: 30 },\n      { ename: \"泡泡4\", salary: 22000, age: 33 },\n    ]\n\n    // 1. 计算出 所有人, 1个月的 总薪资\n    var s = 0\n    emps.forEach(emp => s += emp.salary)\n    console.log(s)\n\n    // 2. 计算年龄小于30岁的人的年薪总和\n    var s = 0\n    emps.forEach(emp => {\n      if (emp.age < 30) s += emp.salary * 12\n    })\n    console.log(s)\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 15:55</title>\n</head>\n\n<body>\n  <script>\n    var products = [\n      { pname: \"iPhone14\", price: 6999, num: 4, checked: true },\n      { pname: \"iPhone14 pro\", price: 8999, num: 3, checked: true },\n      { pname: \"iPhone14 pro max\", price: 10999, num: 1, checked: true },\n      { pname: \"Mate50\", price: 7999, num: 3, checked: false },\n    ]\n\n    // 1. 计算所有商品的总价格\n    var s = 0\n    products.forEach(p => s += p.price * p.num)\n\n    console.log(s)\n\n    // 2. 计算出 选中(checked真) 的商品总价格\n    var s = 0\n    // products.forEach(p => {\n    //   if (p.checked) s += p.price * p.num\n    // })\n\n    // 利用隐式转换: true->1  false->0\n    // 利用小学知识: 任何数字*0 = 0;  任何数字*1 =数字本身\n    // 非勾选的, false, 就是 乘0,  即 s += 0\n    products.forEach(p => s += p.price * p.num * p.checked)\n\n    console.log(s)\n\n    // 3. 每个商品价格 -500\n    products.forEach(p => p.price -= 500)\n    console.log(products)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## reduce\n\n<img src=\"assets/image-20220901163328835.png\" alt=\"image-20220901163328835\" style=\"zoom:67%;\" />\n\nreduce的思想\n\n![image-20220901163547697](assets/image-20220901163547697.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>reduce 16:27</title>\n</head>\n\n<body>\n  <script>\n    // reduce: 合并 - 把数组中的元素合并成 1个值\n    var nums = [12, 4, 45, 765, 67, 87, 89, 9]\n\n    // 算出所有元素总和\n    // 参数2: box盒子中, 初始时的默认值, 如果不写则是数组的第一个值\n    var s = nums.reduce((box, value) => {\n      return box + value\n    }, 0)\n\n    var s = nums.reduce((box, value) => box + value, 0)\n\n    console.log(s)\n  </script>\n</body>\n\n</html>\n```\n\n练习\n\n````html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>16:45</title>\n</head>\n\n<body>\n  <script>\n    var products = [\n      { pname: \"iPhone14\", price: 6999, num: 4, checked: true },\n      { pname: \"iPhone14 pro\", price: 8999, num: 3, checked: true },\n      { pname: \"iPhone14 pro max\", price: 10999, num: 1, checked: true },\n      { pname: \"Mate50\", price: 7999, num: 3, checked: false },\n    ]\n\n    // 1. 计算出所有商品总价格\n    var s = products.reduce((box, v) => {\n      return box + v.price * v.num\n    }, 0)\n\n    console.log(s)\n\n    // 2. 计算出 选中 的商品总价格\n    var s = products.reduce((box, v) => {\n      if (v.checked) {\n        return box + v.price * v.num\n      }\n\n      return box  //如果没有勾选, 应该把箱子传递给下一个\n    }, 0)\n\n    var s = products.reduce((box, v) => {\n      return box + v.price * v.num * v.checked\n    }, 0)\n\n    console.log(s)\n  </script>\n</body>\n\n</html>\n````\n\n\n\n## 函数增强\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>函数扩展功能 17:22</title>\n</head>\n\n<body>\n  <script>\n    // 函数的默认值语法\n    // 通过 形参=值 的语法, 给形参设定默认值\n    // 当调用函数时, 如果没有传递实参, 则采用默认值\n    function show(name = \'泡泡\') {\n      console.log(\'name:\', name)\n    }\n\n    show(\'亮亮\')\n    show()\n\n    // 剩余参数: 类似arguments\n    // 不要和 展开符搞混, 语境不同 含义不同\n    // ...形参: \n    function add(m, n, ...suibian) {\n      console.log(m, n)\n      console.log(suibian)\n      // 特点1: 原型是Array, 真数组. 可以用数组的方法\n      // 特点2: 剩余 没有形参接收的实参, 存储在这里\n    }\n\n    add(11, 22, true, \'lucy\')\n  </script>\n</body>\n\n</html>\n```\n\n## class语法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>class 17:36</title>\n</head>\n\n<body>\n  <!-- \n    class: 来自 JAVA 的面向对象语法, 属于JAVA的核心语法\n    特别擅长制作 构造函数\n\n    JS诞生初期: 初衷是制作一个小型的语言, 操作网页. 作者独创了 原型语法 -- prototype 和 __proto__\n\n    随着时代发展, JS要称为 企业级开发语言, 就必须引入class语法\n   -->\n\n  <script>\n    // 矩形构造函数, 原型添加 area 和 zc 方法\n    function Rect(length, width) {\n      this.length = length\n      this.width = width\n    }\n\n    Object.defineProperties(Rect.prototype, {\n      area: {\n        value() {\n          return this.length * this.width\n        }\n      },\n      zc: {\n        value() {\n          return (this.length + this.width) * 2\n        }\n      }\n    })\n\n    console.dir(Rect);\n\n    var r1 = new Rect(10, 5)\n    console.log(r1);\n\n    console.log(r1.area())\n\n\n    /////////////////////////////////\n    // JAVA的class语法会自动完成原型的操作, 用户不可见\n    class Rect1 {\n      // 所有在这里书写的代码, 都会自动存储在原型里\n      // 固定名称的方法: 称为 构造函数/构造方法\n      // 会被new运算符触发, 制作出 实例对象\n      constructor(length, width) {\n        this.length = length\n        this.width = width\n      }\n      // 函数不用 function, 省略了\n      area() {\n        return this.width * this.length\n      }\n\n      zc() {\n        return (this.width + this.length) * 2\n      }\n    }\n\n    console.dir(Rect1) // 后台展开 看prototype\n\n    // new运算符, 会自动触发名字是 constructor 的方法-固定设置\n    var r2 = new Rect1(10, 50)\n\n    console.log(r2.area())\n  </script>\n</body>\n\n</html>\n```\n\n\n\n\n\n`作业1`\n\n用class语法完成一个 立方体的构造函数  -- 可以参考之前讲构造函数的代码\n\n- 名称 Cube\n- 使用时  new Cube(10, 20, 30)   参数是 长, 宽, 高\n- 原型中有:  area面积, volume 体积,  zc 周长3个方法\n\n\n\n`作业2`\n\n```js\nvar emps = [\n    {ename:\"凯凯1\", age: 23, salary:7000, married:true},\n    {ename:\"凯凯2\", age: 33, salary:17000, married:true},\n    {ename:\"凯凯3\", age: 44, salary:9000, married:false},\n    {ename:\"凯凯4\", age: 28, salary:12000, married:true},\n    {ename:\"凯凯5\", age: 35, salary:33000, married:false},\n]\n\n// 判断是否所有人都大于30岁\n// 判断是否有人工资超过3w\n// 找出所有已婚的人\n// 数组元素显示在表格里, 已婚和未婚 添加不同的背景色\n// 把数组中每个人的薪资 +1000\n// 统计年龄超过30岁的人 的年薪总和\n```\n\n![image-20220901180737497](assets/image-20220901180737497.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"JavaScript\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(16, ' JavaScript高级部分05', 'class继承、方法重写、回调地狱、Promise、正则', '# JSCORE05\n\n## 复习\n\n- 展开语法: `...`\n\n  - ...数组\n  - ...对象\n\n- 解构语法\n\n  - 数组解构: `var [变量, 变量, , 变量] = 数组`\n  - 对象解构\n    - `var { 属性名, 属性名:别名 } = 对象 ` \n    - 形参解构: `function xx({属性名, 属性名}){}`\n\n- 数组高阶函数: 函数中使用了其他函数\n\n  - every: 每一个都满足条件\n  - some: 有至少一个满足条件\n  - map: 映射 -- 把数组数据 转为 HTML代码组成的数组\n    - 配合 `join` 拼接成字符串, 最终配合`innerHTML`显示到页面上\n  - filter: 满足条件的元素过滤出来, 组成新的数组\n  - forEach: 遍历\n    - for...of: 专为遍历数组而生的语法\n  - reduce: 数组合并\n\n- 函数增强语法\n\n  - 形参默认值: `function xx(参数=值){}`\n  - 剩余参数: `function xx(...参数){}`\n    - 把没有形参接收的实参, 统一存储在 ...后面的参数里, 参数是数组类型\n    - `注意`: `...` 和 展开符无关, 使用场景不同\n\n- class语法: 来自JAVA的构造函数语法 -- 称为: `类`\n\n  所有`{}`中的函数, 都会`自动存储`在原型里\n\n  ```js\n  class 类名{\n      // 固定名称: new运算符时触发\n      constructor(){}\n      \n      函数(){}\n      \n      函数(){}\n  }\n  ```\n\n## 作业\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>作业 09:16</title>\n</head>\n\n<body>\n  <script>\n    class Cube {\n      // 固定名称: new自动触发\n      constructor(length, width, height) {\n        this.width = width\n        this.height = height\n        this.length = length\n      }\n\n      // 函数不用function前缀; 会自动加到原型里\n      area() {\n        const { length: l, width: w, height: h } = this\n        return 2 * (l * h + l * w + h * w)\n      }\n\n      volume() {\n        return this.width * this.height * this.length\n      }\n\n      get zc() {\n        return 4 * (this.width + this.length + this.height)\n      }\n    }\n\n    console.dir(Cube)\n\n    var c1 = new Cube(10, 30, 40)\n    console.log(c1)\n    console.log(c1.zc);\n    console.log(c1.area())\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>作业 09:32</title>\n  <style>\n    table {\n      border-collapse: collapse;\n    }\n\n    td {\n      padding: 10px 25px;\n      border: 1px solid gray;\n    }\n\n    thead {\n      background-color: #eee;\n    }\n\n    .yi {\n      background-color: orange;\n    }\n\n    .wei {\n      background-color: #abc;\n    }\n  </style>\n</head>\n\n<body>\n  <table>\n    <thead>\n      <tr>\n        <td>序号</td>\n        <td>姓名</td>\n        <td>年龄</td>\n        <td>薪资</td>\n        <td>婚姻状态</td>\n      </tr>\n    </thead>\n    <tbody id=\"box\">\n      <tr>\n        <td>1</td>\n        <td>xx</td>\n        <td>xx</td>\n        <td>xx</td>\n        <td>xx</td>\n      </tr>\n    </tbody>\n  </table>\n\n\n  <script>\n    // 开发流程中: 前端通过请求获取的数据通常都是数组类型\n    // 前端人员在 处理数组 的场景中, 需要大量使用高阶函数!!\n\n    var emps = [\n      { ename: \"凯凯1\", age: 23, salary: 7000, married: true },\n      { ename: \"凯凯2\", age: 33, salary: 17000, married: true },\n      { ename: \"凯凯3\", age: 44, salary: 9000, married: false },\n      { ename: \"凯凯4\", age: 28, salary: 12000, married: true },\n      { ename: \"凯凯5\", age: 35, salary: 33000, married: false },\n    ]\n\n    // 判断是否所有人都大于30岁 : every\n    var x = emps.every(emp => emp.age > 30)\n    console.log(x ? \'都大于30\' : \'非都大于30\');\n\n    // 判断是否有人工资超过3w : some\n    var x = emps.some(emp => emp.salary > 30000)\n    console.log(x ? \'有超过3W\' : \'没有超过3W\');\n\n    // 找出所有已婚的人 : filter\n    var x = emps.filter(emp => emp.married)\n    console.log(x)\n\n    // 数组元素显示在表格里, 已婚和未婚 添加不同的背景色\n\n    // 把数组中每个人的薪资 +1000 : 遍历修改每个元素forEach\n    emps.forEach(emp => emp.salary += 1000)\n    console.log(emps)\n\n    // 统计年龄超过30岁的人 的年薪总和\n    var x = emps.reduce((box, emp) => {\n      // 满足条件, 就累加到box上;  不满足不做操作\n      if (emp.age > 30) box += emp.salary * 12\n\n      return box //返回box 给下一个\n    }, 0)\n\n    console.log(x)\n\n\n    // 步骤1: 数据 -> HTML 代码\n    var x = emps.map((emp, i) => {\n      const { age, ename, married, salary } = emp\n\n      return `<tr class=\"${married ? \'yi\' : \'wei\'}\">\n        <td>${i + 1}</td>\n        <td>${ename}</td>\n        <td>${age}</td>\n        <td>${salary}</td>\n        <td>${married ? \'已婚\' : \'未婚\'}</td>\n      </tr>`\n    })\n    // 步骤2: HTML代码 添加到 box 里\n    box.innerHTML = x.join(\'\')\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## class\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>class 10:41</title>\n</head>\n\n<body>\n  <script>\n    // 来自 Java 的class 语法\n\n    // JS代码: 制作对象\n    var e1 = { ename: \"泡泡\", age: 19 }\n    console.log(e1)\n    console.log(e1.ename, e1.age)\n\n    // 同效果: java\n    class e2 {\n      // static: 静态属性 -- 代表不存到原型里\n      // 直接存储在 函数对象里, 与构造无关\n      static ename = \'泡泡\'\n      static age = 19\n    }\n\n    console.dir(e2)\n    console.log(e2.age, e2.ename)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 继承\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>extends 继承 10:51</title>\n</head>\n\n<body>\n  <script>\n    // 面向对象 三大特征: 封装 继承 多态\n    // - 封装: 用{}把很多代码封在一起, 起个名字. 以后能复用\n    //   -- 具体表现: 函数\n    // - 继承: 自己没有的东西, 可以找爸爸要\n    //   -- 具体表现: 原型链 __proto__\n    // - 多态: 由重写操作导致\n\n    class Father {\n      show() {\n        console.log(\'我是 F 的show\');\n      }\n    }\n\n    // extends: 继承 - 当Son 构造对象时, Father的原型将会成为 对象的原型的原型\n    class Son extends Father {\n      zc() { }\n    }\n\n    var s = new Son()\n    console.log(s)\n\n    // 特亮: Father\n    // 亮亮: Son\n    // 小亮: s\n    // 亮亮生的小亮,  小亮可以用 特亮的方法\n    // s.__proto__ =  Son.prototype \n    // 小亮.爸爸 = 亮亮\n\n    // Son.prototype.__proto__ = Father.prototype\n    // 亮亮.爸爸 = 特亮\n\n\n    // 原型链/继承机制: 当对象使用一个属性时, 如果属性自身没有, 就到原型链中找, 原型链中没有, 则到 原型链的原型链里找...  直到最后,  如果最终也没有, 则为 undefined\n    s.show()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 重写\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>重写 11:27</title>\n</head>\n\n<body>\n  <script>\n    class TeLiang {\n      show() {\n        console.log(\"成特亮的show\");\n      }\n    }\n    // 亮亮 继承 特亮\n    class Liang extends TeLiang {\n      zc() { }\n      //重写: 在子中, 书写一个与父元素相同名称的方法\n      show() {\n        console.log(\'亮亮的show\');\n\n        // 关键词super :来自C语言 -- 在C语言中 父类 也叫 超类\n        // super关键词代表父类;  此处代表 TeLiang\n        super.show()\n      }\n\n      // 多态: 触发同一个方法, 可能存在多种状态; 重写导致\n    }\n\n    // 亮亮 生 小亮\n    var xl = new Liang()\n    console.log(xl)\n    // 小亮 调用 show 方法: 亮亮没有show, 则到 特亮 中查找\n    xl.show()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 小技巧\n\n搜狗输入法的设置中, 开启 `中文时使用英文标点`\n\n<img src=\"assets/image-20220902101855834.png\" alt=\"image-20220902101855834\" style=\"zoom:50%;\" />\n\n\n\n\n\n<img src=\"assets/image-20220902113509957.png\" alt=\"image-20220902113509957\" style=\"zoom:33%;\" />\n\n## 回调地狱\n\n![image-20220902115553146](assets/image-20220902115553146.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>回调地狱 11:43</title>\n</head>\n\n<body>\n  <script>\n    // 回调地狱: 如果有多个 回调函数 嵌套使用时, 代码的结构 会非常混乱, 难以阅读 和 维护\n\n    // 注册场景:\n    // 假设: 在点击注册按钮后 -> 发请求检查用户名是否正确\n    // -> 正确->发请求 检查手机号是否正确 -> 正确 -> 发请求 检查邮箱是否正确 -> 正确-> 发注册请求\n\n    // 用 定时器 模拟异步操作, 间隔 1s 一次\n    // 用 随机数0~1 模拟结果  >0.3算成功\n\n    function register() {\n      // 检验用户名\n      console.log(\'检查用户名...\')\n      setTimeout(() => {\n        var n = Math.random()\n        if (n > 0.3) {\n          console.log(\'用户名正确, 开始检查邮箱...\');\n\n          setTimeout(() => {\n            var n = Math.random()\n            if (n > 0.3) {\n              console.log(\'邮箱正确! 开始检查手机号...\');\n              setTimeout(() => {\n                var n = Math.random()\n                if (n > 0.3) {\n                  console.log(\'手机号正确! 开始注册...\');\n                  setTimeout(() => {\n                    var n = Math.random()\n                    if (n > 0.3) {\n                      console.log(\'注册成功\');\n                    } else {\n                      console.log(\'注册失败\');\n                    }\n                  }, 1000);\n                } else {\n                  console.log(\'手机号错误!\');\n                }\n              }, 1000);\n\n            } else {\n              console.log(\'邮箱错误!\');\n            }\n          }, 1000);\n        } else {\n          console.log(\'用户名错误!\');\n        }\n      }, 1000);\n    }\n\n    register()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## promise\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>promise 11:57</title>\n</head>\n\n<body>\n  <!-- Promise: ES6中提供的构造函数, 用来从语法上解决回调地狱问题 -->\n  <script>\n    // 官方提供的纯概念: Promise有三种状态\n    // 1. pending(待定): 刚new完, 还没执行具体方法\n    // 2. fulfilled(成功): 触发 resolve 后\n    // 3. rejected(失败) : 触发 reject 后\n    // 状态只能从 pending 转为其他两种\n\n    new Promise((resolve, reject) => {\n      // resolve 和 reject 不允许同时触发, 只能二选一\n      // resolve() //触发then, 代表成功\n      reject()  //触发 catch, 代表失败\n    })\n      .then(res => {\n        console.log(\'res: resolve触发\');\n      })\n      .catch(err => {\n        console.log(\'err: reject触发\');\n      })\n  </script>\n</body>\n\n</html>\n```\n\n## Promise\n\n<img src=\"assets/image-20220902140509536.png\" alt=\"image-20220902140509536\" style=\"zoom:87%;\" />\n\n### 面试必考理论: 3种状态\n\n<img src=\"assets/image-20220902141911959.png\" alt=\"image-20220902141911959\" style=\"zoom:50%;\" />\n\n\n\n\n\n![image-20220902145147015](assets/image-20220902145147015.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:21</title>\n</head>\n\n<body>\n  <!-- Promise实战 -->\n  <script>\n    // 模拟用户名的验证操作\n    // 定时器模拟延时, 随机数模拟成功率>0.3\n    function checkUname() {\n      return new Promise((resolve, reject) => {\n        console.log(\'验证用户名...\')\n\n        setTimeout(() => {\n          var n = Math.random()\n          // 参数{n} 会传递给回调函数\n          n > 0.3 ? resolve({ n, msg: \"用户名正确\" }) : reject({ n, msg: \'用户名错误\' })\n        }, 1000)\n      })\n      // return x\n    }\n\n    // 检查邮箱:\n    function checkEmail() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'检查邮箱...\')\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"邮箱正确\" }) : reject({ n, msg: \"邮箱错误\" })\n        }, 1000)\n      });\n    }\n\n    // 检验手机号\n    function checkPhone() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始验证手机号...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"手机号正确\" }) : reject({ n, msg: \"手机号错误\" })\n        }, 1000);\n      });\n    }\n\n    // 注册\n    function register() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始注册...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \'注册成功\' }) : reject({ n, msg: \'注册失败\' })\n        }, 1000);\n      });\n    }\n\n    // then: 然后; 接着\n    checkUname()\n      .then(res => {\n        console.log(\'res:\', res);\n        // 继续调用: 检查邮箱\n        return checkPhone()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n        return checkEmail()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n        return register()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n      })\n      .catch(err => {\n        console.log(\'err:\', err);\n      })\n\n\n    /////////////////////////////////////////\n    // 如果用语法糖\n    checkUname()\n      .then(res => checkEmail())\n      .then(res => checkPhone())\n      .then(res => register())\n      .then(res => console.log(res))\n      .catch(err => console.log(err))\n\n    // 回调嵌套: 为了把异步操作改成同步的\n    // 操作完毕后, 再通知执行下一次\n  </script>\n</body>\n\n</html>\n```\n\n## async和await\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>async 与 await 15:31</title>\n</head>\n\n<body>\n  <!-- 因为有些人不喜欢 .then().then().then() .. 这种链式语法 -->\n  <script>\n    // 作者提供了 await 和 async 语法\n    function checkUname() {\n      return new Promise((resolve, reject) => {\n        console.log(\'验证用户名...\')\n\n        setTimeout(() => {\n          var n = Math.random()\n          // 参数{n} 会传递给回调函数\n          n > 0.3 ? resolve({ n, msg: \"用户名正确\" }) : reject({ n, msg: \'用户名错误\' })\n        }, 1000)\n      })\n      // return x\n    }\n\n    // 检查邮箱:\n    function checkEmail() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'检查邮箱...\')\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"邮箱正确\" }) : reject({ n, msg: \"邮箱错误\" })\n        }, 1000)\n      });\n    }\n\n    // 检验手机号\n    function checkPhone() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始验证手机号...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"手机号正确\" }) : reject({ n, msg: \"手机号错误\" })\n        }, 1000);\n      });\n    }\n\n    // 注册\n    function register() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始注册...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \'注册成功\' }) : reject({ n, msg: \'注册失败\' })\n        }, 1000);\n      });\n    }\n\n\n    //////\n    // async: 异步 -- 代表 doReg 函数中的操作要异步执行\n    async function doReg() {\n      // await: 等待异步操作完成, 再执行下一个 -- 实现同步效果\n\n      // await: 等待,等候 -- 等 resolve的结果\n      var a = await checkUname() //reject会直接报错\n      console.log(\'a:\', a)\n\n      var a = await checkPhone()\n      console.log(\'a:\', a)\n\n      var a = await checkEmail()\n      console.log(\'a:\', a)\n\n      var a = await register()\n      console.log(\'a:\', a)\n    }\n\n    doReg()\n  </script>\n</body>\n\n</html>\n```\n\n## 正则\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>正则表达式 15:50</title>\n</head>\n\n<body>\n  <!-- 正则表达式: Regular Expression -->\n  <!-- 简称: RegExp -->\n  <!-- 什么是正则? 一套通用的字符串格式匹配方案;  -->\n  <!-- 不是JS专有的 -->\n  <!-- 使用正则, 必须了解正则元字符 表格 -->\n  <!-- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions -->\n\n  <script>\n    // \\d: 匹配一个数字\n    var words = \'Hello123 You456\'\n\n    // 从字符串中找出所有的数字\n    // 制作正则对象, 字面量语法: /元字符/\n    var r = /\\d/\n    console.dir(r) //后台看\n\n    // match: 匹配\n    // 字符串.match(正则对象): 自动在字符串中查找到符合正则要求的字符\n    var x = words.match(r)\n    console.log(\'x:\', x)\n\n    // 正则修饰符: g  -- global 全局: 代表查所有符合的 不再是1个\n    // 语法  /元字符/修饰符\n    var x = words.match(/\\d/g)\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 16:26</title>\n</head>\n\n<body>\n  <script>\n    // 正则匹配的用途: 查找字符串中是否含有 某种字符\n    var words = prompt(\'请输入密码\')\n    console.log(\'words:\', words)\n\n    // 1. 验证是否含有数字\n    var x = words.match(/\\d/)\n    console.log(\'x:\', x)\n    console.log(x ? \'含有数字\' : \'不含数字\');\n\n    // 2. 验证是否有中文  [\\u4e00-\\u9fa5]\n    // 大全: http://www.codece.com/archives/273\n    var x = words.match(/[\\u4e00-\\u9fa5]/)\n    console.log(x ? \'有中文\' : \'无中文\');\n  </script>\n</body>\n\n</html>\n```\n\n## 替换\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>replace 16:40</title>\n</head>\n\n<body>\n  <script>\n    var phone = prompt(\"请输入手机号\")\n    console.log(\'phone:\', phone)\n\n    // {n} : 代表连续 n 个\n    // () : 捕获组 - 把正则表达式分成多个段落\n    var r = /(\\d{3})(\\d{4})(\\d{4})/\n    // 编号     1      2      3\n\n    // 按照正则匹配到相关的字符组合, 替换成\n    // $n: 第n个捕获组 捕捉的字符\n    var x = phone.replace(r, \'$1****$3\')\n    console.log(\'x:\', x)\n\n    // 转为: 188-4444-4444  这种格式\n    var x = phone.replace(r, \'$1-$2-$3\')\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n## 验证\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>test 正则验证 16:53</title>\n</head>\n\n<body>\n  <script>\n    // 验证字符串是否符合正则表达式的要求\n    var phone = prompt(\'输入手机号\')\n    console.log(\'phone:\', phone);\n\n    // ^ : 输入的开始\n    // ^1 : 1是第一个字符\n    // [3-9] : 3 4 5 6 7 8 9 这个集合\n    // \\d{9} : 数字 有9个\n    // $ : 输入的结束\n    var r = /^1[3-9]\\d{9}$/\n\n    var x = r.test(phone) //正则.验证(手机号)\n    console.log(x ? \'是手机号\' : \'不是手机号\');\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 正则元字符\n\n| 字符                                                         | 含义                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [`\\`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backslash) | 依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 \"\\\" 的 \"b\" 通常匹配小写字母 \"b\"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 \"\\\"，它将不再匹配任何字符，而是表示一个[字符边界](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note)。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 \"转义（Escaping）\" 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。`/[a-z]\\s/i` 和 `new RegExp(\"[a-z]\\\\s\", \"i\")` 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（`\\s` 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 `/[a-z]:\\\\/i` 和 `new RegExp(\"[a-z]:\\\\\\\\\",\"i\")` 会创建相同的表达式，即匹配类似 \"C:\\\" 字符串。 |\n| [`^`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-caret) | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。例如，`/^A/` 并不会匹配 \"an A\" 中的 \'A\'，但是会匹配 \"An E\" 中的 \'A\'。当 \'`^`\' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。[反向字符集合](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set) 一节有详细介绍和示例。 |\n| [`$`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dollar) | 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。例如，`/t$/` 并不会匹配 \"eater\" 中的 \'t\'，但是会匹配 \"eat\" 中的 \'t\'。 |\n| [`*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-asterisk) | 匹配前一个表达式 0 次或多次。等价于 `{0,}`。例如，`/bo*/` 会匹配 \"A ghost boooooed\" 中的 \'booooo\' 和 \"A bird warbled\" 中的 \'b\'，但是在 \"A goat grunted\" 中不会匹配任何内容。 |\n| [`+`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-plus) | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`。例如，`/a+/` 会匹配 \"candy\" 中的 \'a\' 和 \"caaaaaaandy\" 中所有的 \'a\'，但是在 \"cndy\" 中不会匹配任何内容。 |\n| [`?`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-questionmark) | 匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`。例如，`/e?le?/` 匹配 \"angel\" 中的 \'el\'、\"angle\" 中的 \'le\' 以及 \"oslo\' 中的 \'l\'。如果**紧跟在任何量词 \\*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。例如，对 \"123abc\" 使用 `/\\d+/` 将会匹配 \"123\"，而使用 `/\\d+?/` 则只会匹配到 \"1\"。还用于先行断言中，如本表的 `x(?=y)` 和 `x(?!y)` 条目所述。 |\n| [`.`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dot) | （小数点）默认匹配除换行符之外的任何单个字符。例如，`/.n/` 将会匹配 \"nay, an apple is on the tree\" 中的 \'an\' 和 \'on\'，但是不会匹配 \'nay\'。如果 `s` (\"dotAll\") 标志位被设为 true，它也会匹配换行符。 |\n| [`(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses) | 像下面的例子展示的那样，它会匹配 \'x\' 并且记住匹配项。其中括号被称为*捕获括号*。模式 `/(foo) (bar) \\1 \\2/` 中的 \'`(foo)`\' 和 \'`(bar)`\' 匹配并记住字符串 \"foo bar foo bar\" 中前两个单词。模式中的 `\\1` 和 `\\2` 表示第一个和第二个被捕获括号匹配的子字符串，即 `foo` 和 `bar`，匹配了原字符串中的后两个单词。注意 `\\1`、`\\2`、...、`\\n` 是用在正则表达式的匹配环节，详情可以参阅后文的 [\\n](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference) 条目。而在正则表达式的替换环节，则要使用像 `$1`、`$2`、...、`$n` 这样的语法，例如，`\'bar foo\'.replace(/(...) (...)/, \'$2 $1\')`。`$&` 表示整个用于匹配的原字符串。 |\n| [`(?:x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses) | 匹配 \'x\' 但是不记住匹配项。这种括号叫作*非捕获括号*，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 `/(?:foo){1,2}/`。如果表达式是 `/foo{1,2}/`，`{1,2}` 将只应用于 \'foo\' 的最后一个字符 \'o\'。如果使用非捕获括号，则 `{1,2}` 会应用于整个 \'foo\' 单词。更多信息，可以参阅下文的 [Using parentheses](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses) 条目。 |\n| [`x(?=y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead) | 匹配\'x\'仅仅当\'x\'后面跟着\'y\'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到\'Jack\'仅当它后面跟着\'Sprat\'。/Jack(?=Sprat\\|Frost)/匹配‘Jack’仅当它后面跟着\'Sprat\'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 |\n| [`(?<=y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead)x | 匹配\'x\'仅当\'x\'前面是\'y\'.这种叫做后行断言。例如，/(?<=Jack)Sprat/会匹配到\' Sprat \'仅仅当它前面是\' Jack \'。/(?<=Jack\\|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是\'Jack\'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。 |\n| [`x(?!y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-look-ahead) | 仅仅当\'x\'后面不跟着\'y\'时匹配\'x\'，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!\\.)/ 匹配一个数字。正则表达式/\\d+(?!\\.)/.exec(\"3.141\") 匹配‘141’而不是‘3.141’ |\n| `(?<!*y*)*x*`                                                | 仅仅当\'x\'前面不是\'y\'时匹配\'x\'，这被称为反向否定查找。例如，仅仅当这个数字前面没有负号的时候，`/(?<!-)\\d+/` 匹配一个数字。 `/(?<!-)\\d+/.exec(\'3\')` 匹配到 \"3\". `/(?<!-)\\d+/.exec(\'-3\')` 因为这个数字前有负号，所以没有匹配到。 |\n| [`x|y`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-or) | 匹配‘x’或者‘y’。例如，/green\\|red/匹配“green apple”中的‘green’和“red apple”中的‘red’ |\n| [`{n}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier) | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的\'a\',但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个\'a\'。 |\n| [`{n,}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier) | n 是一个正整数，匹配前一个字符至少出现了 n 次。例如，/a{2,}/ 匹配 \"aa\", \"aaaa\" 和 \"aaaaa\" 但是不匹配 \"a\"。 |\n| [`{n,m}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier-range) | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。 |\n| [`[xyz\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-character-set) | 一个字符集合。匹配方括号中的任意字符，包括[转义序列](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types)。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和 [a-d] 是一样的。他们都匹配\"brisket\"中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。 |\n| [`[^xyz\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set) | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配\"brisket\"中的‘r’，也匹配“chop”中的‘h’。 |\n| [`[\\b\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backspace) | 匹配一个退格 (U+0008)。（不要和\\b混淆了。）                  |\n| [`\\b`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word-boundary) | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\\b] 混淆了）使用\"moon\"举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配\"moon\"中的\'oo\'，因为\'oo\'被一个“字”字符\'n\'紧跟着。 /oon\\b/匹配\"moon\"中的\'oon\'，因为\'oon\'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。**备注：** JavaScript 的正则表达式引擎将[特定的字符集](https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6)定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 |\n| [`\\B`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word-boundary) | 匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，/\\B../匹配\"noonday\"中的\'oo\', 而/y\\B../匹配\"possibly yesterday\"中的’yes‘ |\n| [`\\c*X*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-control) | 当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。例如，`/\\cM/` 匹配字符串中的 control-M (U+000D)。 |\n| [`\\d`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-digit) | 匹配一个数字`。``等价于 [0-9]`。例如， `/\\d/` 或者 `/[0-9]/` 匹配\"B2 is the suite number.\"中的\'2\'。 |\n| [`\\D`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-digit) | 匹配一个非数字字符`。``等价于 [^0-9]`。例如， `/\\D/` 或者 `/[^0-9]/` 匹配\"B2 is the suite number.\"中的\'B\' 。 |\n| [`\\f`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-form-feed) | 匹配一个换页符 (U+000C)。                                    |\n| [`\\n`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-line-feed) | 匹配一个换行符 (U+000A)。                                    |\n| [`\\r`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-carriage-return) | 匹配一个回车符 (U+000D)。                                    |\n| [`\\s`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space) | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，`/\\s\\w*/` 匹配\"foo bar.\"中的\' bar\'。经测试，\\s不匹配\"[\\u180e](https://unicode-table.com/cn/180E/)\"，在当前版本 Chrome(v80.0.3987.122) 和 Firefox(76.0.1) 控制台输入/\\s/.test(\"\\u180e\") 均返回 false。 |\n| [`\\S`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-white-space) | 匹配一个非空白字符。等价于 `[^ `\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff`]`。例如，`/\\S\\w*/` 匹配\"foo bar.\"中的\'foo\'。 |\n| [`\\t`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-tab) | 匹配一个水平制表符 (U+0009)。                                |\n| [`\\v`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-vertical-tab) | 匹配一个垂直制表符 (U+000B)。                                |\n| [`\\w`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word) | 匹配一个单字字符（字母、数字或者下划线）。等价于 `[A-Za-z0-9_]`。例如，`/\\w/` 匹配 \"apple,\" 中的 \'a\'，\"$5.28,\"中的 \'5\' 和 \"3D.\" 中的 \'3\'。 |\n| [`\\W`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word) | 匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`。例如，`/\\W/` 或者 `/[^A-Za-z0-9_]/` 匹配 \"50%.\" 中的 \'%\'。 |\n| [`\\*n*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference) | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。比如 `/apple(,)\\sorange\\1/` 匹配\"apple, orange, cherry, peach.\"中的\'apple, orange,\' 。 |\n| [`\\0`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-null) | 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 `\\0<digits>` 是一个八进制转义序列。 |\n| [`\\xhh`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-hex-escape) | 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。              |\n| [`\\uhhhh`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-unicode-escape) | 匹配一个四位十六进制数表示的 UTF-16 代码单元。               |\n| `\\u{hhhh}或\\u{hhhhh}`                                        | （仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。 |\n\n## 构造\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>RegExp 17:21</title>\n</head>\n\n<body>\n  <script>\n    // 正则表达式的构造方式:  RegExp\n    var words = \'Hello123 World456\'\n\n    // 字面量语法  /\\d/g\n    // 参数1: 元字符    参数2: 修饰符\n    // JS中 \\ 是转义符;  需要用 \\\\ 把转成普通 \\\n    var r = new RegExp(\'\\\\d\', \'g\')\n    console.dir(r)\n\n    console.log(words.match(r))\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 总结\n\nJS高级的内容 主要是为 后期的DOM 而服务!\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"JavaScript\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(17, 'Vue基础01', '插值语法、绑定事件、事件参数、$event、属性绑定、动态类名、动态style、显示与隐藏、脚手架环境', '# JSCORE05\n\n## 复习\n\n- 展开语法: `...`\n\n  - ...数组\n  - ...对象\n\n- 解构语法\n\n  - 数组解构: `var [变量, 变量, , 变量] = 数组`\n  - 对象解构\n    - `var { 属性名, 属性名:别名 } = 对象 ` \n    - 形参解构: `function xx({属性名, 属性名}){}`\n\n- 数组高阶函数: 函数中使用了其他函数\n\n  - every: 每一个都满足条件\n  - some: 有至少一个满足条件\n  - map: 映射 -- 把数组数据 转为 HTML代码组成的数组\n    - 配合 `join` 拼接成字符串, 最终配合`innerHTML`显示到页面上\n  - filter: 满足条件的元素过滤出来, 组成新的数组\n  - forEach: 遍历\n    - for...of: 专为遍历数组而生的语法\n  - reduce: 数组合并\n\n- 函数增强语法\n\n  - 形参默认值: `function xx(参数=值){}`\n  - 剩余参数: `function xx(...参数){}`\n    - 把没有形参接收的实参, 统一存储在 ...后面的参数里, 参数是数组类型\n    - `注意`: `...` 和 展开符无关, 使用场景不同\n\n- class语法: 来自JAVA的构造函数语法 -- 称为: `类`\n\n  所有`{}`中的函数, 都会`自动存储`在原型里\n\n  ```js\n  class 类名{\n      // 固定名称: new运算符时触发\n      constructor(){}\n      \n      函数(){}\n      \n      函数(){}\n  }\n  ```\n\n## 作业\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>作业 09:16</title>\n</head>\n\n<body>\n  <script>\n    class Cube {\n      // 固定名称: new自动触发\n      constructor(length, width, height) {\n        this.width = width\n        this.height = height\n        this.length = length\n      }\n\n      // 函数不用function前缀; 会自动加到原型里\n      area() {\n        const { length: l, width: w, height: h } = this\n        return 2 * (l * h + l * w + h * w)\n      }\n\n      volume() {\n        return this.width * this.height * this.length\n      }\n\n      get zc() {\n        return 4 * (this.width + this.length + this.height)\n      }\n    }\n\n    console.dir(Cube)\n\n    var c1 = new Cube(10, 30, 40)\n    console.log(c1)\n    console.log(c1.zc);\n    console.log(c1.area())\n  </script>\n</body>\n\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>作业 09:32</title>\n  <style>\n    table {\n      border-collapse: collapse;\n    }\n\n    td {\n      padding: 10px 25px;\n      border: 1px solid gray;\n    }\n\n    thead {\n      background-color: #eee;\n    }\n\n    .yi {\n      background-color: orange;\n    }\n\n    .wei {\n      background-color: #abc;\n    }\n  </style>\n</head>\n\n<body>\n  <table>\n    <thead>\n      <tr>\n        <td>序号</td>\n        <td>姓名</td>\n        <td>年龄</td>\n        <td>薪资</td>\n        <td>婚姻状态</td>\n      </tr>\n    </thead>\n    <tbody id=\"box\">\n      <tr>\n        <td>1</td>\n        <td>xx</td>\n        <td>xx</td>\n        <td>xx</td>\n        <td>xx</td>\n      </tr>\n    </tbody>\n  </table>\n\n\n  <script>\n    // 开发流程中: 前端通过请求获取的数据通常都是数组类型\n    // 前端人员在 处理数组 的场景中, 需要大量使用高阶函数!!\n\n    var emps = [\n      { ename: \"凯凯1\", age: 23, salary: 7000, married: true },\n      { ename: \"凯凯2\", age: 33, salary: 17000, married: true },\n      { ename: \"凯凯3\", age: 44, salary: 9000, married: false },\n      { ename: \"凯凯4\", age: 28, salary: 12000, married: true },\n      { ename: \"凯凯5\", age: 35, salary: 33000, married: false },\n    ]\n\n    // 判断是否所有人都大于30岁 : every\n    var x = emps.every(emp => emp.age > 30)\n    console.log(x ? \'都大于30\' : \'非都大于30\');\n\n    // 判断是否有人工资超过3w : some\n    var x = emps.some(emp => emp.salary > 30000)\n    console.log(x ? \'有超过3W\' : \'没有超过3W\');\n\n    // 找出所有已婚的人 : filter\n    var x = emps.filter(emp => emp.married)\n    console.log(x)\n\n    // 数组元素显示在表格里, 已婚和未婚 添加不同的背景色\n\n    // 把数组中每个人的薪资 +1000 : 遍历修改每个元素forEach\n    emps.forEach(emp => emp.salary += 1000)\n    console.log(emps)\n\n    // 统计年龄超过30岁的人 的年薪总和\n    var x = emps.reduce((box, emp) => {\n      // 满足条件, 就累加到box上;  不满足不做操作\n      if (emp.age > 30) box += emp.salary * 12\n\n      return box //返回box 给下一个\n    }, 0)\n\n    console.log(x)\n\n\n    // 步骤1: 数据 -> HTML 代码\n    var x = emps.map((emp, i) => {\n      const { age, ename, married, salary } = emp\n\n      return `<tr class=\"${married ? \'yi\' : \'wei\'}\">\n        <td>${i + 1}</td>\n        <td>${ename}</td>\n        <td>${age}</td>\n        <td>${salary}</td>\n        <td>${married ? \'已婚\' : \'未婚\'}</td>\n      </tr>`\n    })\n    // 步骤2: HTML代码 添加到 box 里\n    box.innerHTML = x.join(\'\')\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## class\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>class 10:41</title>\n</head>\n\n<body>\n  <script>\n    // 来自 Java 的class 语法\n\n    // JS代码: 制作对象\n    var e1 = { ename: \"泡泡\", age: 19 }\n    console.log(e1)\n    console.log(e1.ename, e1.age)\n\n    // 同效果: java\n    class e2 {\n      // static: 静态属性 -- 代表不存到原型里\n      // 直接存储在 函数对象里, 与构造无关\n      static ename = \'泡泡\'\n      static age = 19\n    }\n\n    console.dir(e2)\n    console.log(e2.age, e2.ename)\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 继承\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>extends 继承 10:51</title>\n</head>\n\n<body>\n  <script>\n    // 面向对象 三大特征: 封装 继承 多态\n    // - 封装: 用{}把很多代码封在一起, 起个名字. 以后能复用\n    //   -- 具体表现: 函数\n    // - 继承: 自己没有的东西, 可以找爸爸要\n    //   -- 具体表现: 原型链 __proto__\n    // - 多态: 由重写操作导致\n\n    class Father {\n      show() {\n        console.log(\'我是 F 的show\');\n      }\n    }\n\n    // extends: 继承 - 当Son 构造对象时, Father的原型将会成为 对象的原型的原型\n    class Son extends Father {\n      zc() { }\n    }\n\n    var s = new Son()\n    console.log(s)\n\n    // 特亮: Father\n    // 亮亮: Son\n    // 小亮: s\n    // 亮亮生的小亮,  小亮可以用 特亮的方法\n    // s.__proto__ =  Son.prototype \n    // 小亮.爸爸 = 亮亮\n\n    // Son.prototype.__proto__ = Father.prototype\n    // 亮亮.爸爸 = 特亮\n\n\n    // 原型链/继承机制: 当对象使用一个属性时, 如果属性自身没有, 就到原型链中找, 原型链中没有, 则到 原型链的原型链里找...  直到最后,  如果最终也没有, 则为 undefined\n    s.show()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 重写\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>重写 11:27</title>\n</head>\n\n<body>\n  <script>\n    class TeLiang {\n      show() {\n        console.log(\"成特亮的show\");\n      }\n    }\n    // 亮亮 继承 特亮\n    class Liang extends TeLiang {\n      zc() { }\n      //重写: 在子中, 书写一个与父元素相同名称的方法\n      show() {\n        console.log(\'亮亮的show\');\n\n        // 关键词super :来自C语言 -- 在C语言中 父类 也叫 超类\n        // super关键词代表父类;  此处代表 TeLiang\n        super.show()\n      }\n\n      // 多态: 触发同一个方法, 可能存在多种状态; 重写导致\n    }\n\n    // 亮亮 生 小亮\n    var xl = new Liang()\n    console.log(xl)\n    // 小亮 调用 show 方法: 亮亮没有show, 则到 特亮 中查找\n    xl.show()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 小技巧\n\n搜狗输入法的设置中, 开启 `中文时使用英文标点`\n\n<img src=\"assets/image-20220902101855834.png\" alt=\"image-20220902101855834\" style=\"zoom:50%;\" />\n\n\n\n\n\n<img src=\"assets/image-20220902113509957.png\" alt=\"image-20220902113509957\" style=\"zoom:33%;\" />\n\n## 回调地狱\n\n![image-20220902115553146](assets/image-20220902115553146.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>回调地狱 11:43</title>\n</head>\n\n<body>\n  <script>\n    // 回调地狱: 如果有多个 回调函数 嵌套使用时, 代码的结构 会非常混乱, 难以阅读 和 维护\n\n    // 注册场景:\n    // 假设: 在点击注册按钮后 -> 发请求检查用户名是否正确\n    // -> 正确->发请求 检查手机号是否正确 -> 正确 -> 发请求 检查邮箱是否正确 -> 正确-> 发注册请求\n\n    // 用 定时器 模拟异步操作, 间隔 1s 一次\n    // 用 随机数0~1 模拟结果  >0.3算成功\n\n    function register() {\n      // 检验用户名\n      console.log(\'检查用户名...\')\n      setTimeout(() => {\n        var n = Math.random()\n        if (n > 0.3) {\n          console.log(\'用户名正确, 开始检查邮箱...\');\n\n          setTimeout(() => {\n            var n = Math.random()\n            if (n > 0.3) {\n              console.log(\'邮箱正确! 开始检查手机号...\');\n              setTimeout(() => {\n                var n = Math.random()\n                if (n > 0.3) {\n                  console.log(\'手机号正确! 开始注册...\');\n                  setTimeout(() => {\n                    var n = Math.random()\n                    if (n > 0.3) {\n                      console.log(\'注册成功\');\n                    } else {\n                      console.log(\'注册失败\');\n                    }\n                  }, 1000);\n                } else {\n                  console.log(\'手机号错误!\');\n                }\n              }, 1000);\n\n            } else {\n              console.log(\'邮箱错误!\');\n            }\n          }, 1000);\n        } else {\n          console.log(\'用户名错误!\');\n        }\n      }, 1000);\n    }\n\n    register()\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## promise\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>promise 11:57</title>\n</head>\n\n<body>\n  <!-- Promise: ES6中提供的构造函数, 用来从语法上解决回调地狱问题 -->\n  <script>\n    // 官方提供的纯概念: Promise有三种状态\n    // 1. pending(待定): 刚new完, 还没执行具体方法\n    // 2. fulfilled(成功): 触发 resolve 后\n    // 3. rejected(失败) : 触发 reject 后\n    // 状态只能从 pending 转为其他两种\n\n    new Promise((resolve, reject) => {\n      // resolve 和 reject 不允许同时触发, 只能二选一\n      // resolve() //触发then, 代表成功\n      reject()  //触发 catch, 代表失败\n    })\n      .then(res => {\n        console.log(\'res: resolve触发\');\n      })\n      .catch(err => {\n        console.log(\'err: reject触发\');\n      })\n  </script>\n</body>\n\n</html>\n```\n\n## Promise\n\n<img src=\"assets/image-20220902140509536.png\" alt=\"image-20220902140509536\" style=\"zoom:87%;\" />\n\n### 面试必考理论: 3种状态\n\n<img src=\"assets/image-20220902141911959.png\" alt=\"image-20220902141911959\" style=\"zoom:50%;\" />\n\n\n\n\n\n![image-20220902145147015](assets/image-20220902145147015.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 14:21</title>\n</head>\n\n<body>\n  <!-- Promise实战 -->\n  <script>\n    // 模拟用户名的验证操作\n    // 定时器模拟延时, 随机数模拟成功率>0.3\n    function checkUname() {\n      return new Promise((resolve, reject) => {\n        console.log(\'验证用户名...\')\n\n        setTimeout(() => {\n          var n = Math.random()\n          // 参数{n} 会传递给回调函数\n          n > 0.3 ? resolve({ n, msg: \"用户名正确\" }) : reject({ n, msg: \'用户名错误\' })\n        }, 1000)\n      })\n      // return x\n    }\n\n    // 检查邮箱:\n    function checkEmail() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'检查邮箱...\')\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"邮箱正确\" }) : reject({ n, msg: \"邮箱错误\" })\n        }, 1000)\n      });\n    }\n\n    // 检验手机号\n    function checkPhone() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始验证手机号...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"手机号正确\" }) : reject({ n, msg: \"手机号错误\" })\n        }, 1000);\n      });\n    }\n\n    // 注册\n    function register() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始注册...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \'注册成功\' }) : reject({ n, msg: \'注册失败\' })\n        }, 1000);\n      });\n    }\n\n    // then: 然后; 接着\n    checkUname()\n      .then(res => {\n        console.log(\'res:\', res);\n        // 继续调用: 检查邮箱\n        return checkPhone()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n        return checkEmail()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n        return register()\n      })\n      .then(res => {\n        console.log(\'res:\', res)\n      })\n      .catch(err => {\n        console.log(\'err:\', err);\n      })\n\n\n    /////////////////////////////////////////\n    // 如果用语法糖\n    checkUname()\n      .then(res => checkEmail())\n      .then(res => checkPhone())\n      .then(res => register())\n      .then(res => console.log(res))\n      .catch(err => console.log(err))\n\n    // 回调嵌套: 为了把异步操作改成同步的\n    // 操作完毕后, 再通知执行下一次\n  </script>\n</body>\n\n</html>\n```\n\n## async和await\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>async 与 await 15:31</title>\n</head>\n\n<body>\n  <!-- 因为有些人不喜欢 .then().then().then() .. 这种链式语法 -->\n  <script>\n    // 作者提供了 await 和 async 语法\n    function checkUname() {\n      return new Promise((resolve, reject) => {\n        console.log(\'验证用户名...\')\n\n        setTimeout(() => {\n          var n = Math.random()\n          // 参数{n} 会传递给回调函数\n          n > 0.3 ? resolve({ n, msg: \"用户名正确\" }) : reject({ n, msg: \'用户名错误\' })\n        }, 1000)\n      })\n      // return x\n    }\n\n    // 检查邮箱:\n    function checkEmail() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'检查邮箱...\')\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"邮箱正确\" }) : reject({ n, msg: \"邮箱错误\" })\n        }, 1000)\n      });\n    }\n\n    // 检验手机号\n    function checkPhone() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始验证手机号...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \"手机号正确\" }) : reject({ n, msg: \"手机号错误\" })\n        }, 1000);\n      });\n    }\n\n    // 注册\n    function register() {\n      // prom\n      return new Promise((resolve, reject) => {\n        console.log(\'开始注册...\');\n        setTimeout(() => {\n          var n = Math.random()\n          n > 0.3 ? resolve({ n, msg: \'注册成功\' }) : reject({ n, msg: \'注册失败\' })\n        }, 1000);\n      });\n    }\n\n\n    //////\n    // async: 异步 -- 代表 doReg 函数中的操作要异步执行\n    async function doReg() {\n      // await: 等待异步操作完成, 再执行下一个 -- 实现同步效果\n\n      // await: 等待,等候 -- 等 resolve的结果\n      var a = await checkUname() //reject会直接报错\n      console.log(\'a:\', a)\n\n      var a = await checkPhone()\n      console.log(\'a:\', a)\n\n      var a = await checkEmail()\n      console.log(\'a:\', a)\n\n      var a = await register()\n      console.log(\'a:\', a)\n    }\n\n    doReg()\n  </script>\n</body>\n\n</html>\n```\n\n## 正则\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>正则表达式 15:50</title>\n</head>\n\n<body>\n  <!-- 正则表达式: Regular Expression -->\n  <!-- 简称: RegExp -->\n  <!-- 什么是正则? 一套通用的字符串格式匹配方案;  -->\n  <!-- 不是JS专有的 -->\n  <!-- 使用正则, 必须了解正则元字符 表格 -->\n  <!-- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions -->\n\n  <script>\n    // \\d: 匹配一个数字\n    var words = \'Hello123 You456\'\n\n    // 从字符串中找出所有的数字\n    // 制作正则对象, 字面量语法: /元字符/\n    var r = /\\d/\n    console.dir(r) //后台看\n\n    // match: 匹配\n    // 字符串.match(正则对象): 自动在字符串中查找到符合正则要求的字符\n    var x = words.match(r)\n    console.log(\'x:\', x)\n\n    // 正则修饰符: g  -- global 全局: 代表查所有符合的 不再是1个\n    // 语法  /元字符/修饰符\n    var x = words.match(/\\d/g)\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n### 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>练习 16:26</title>\n</head>\n\n<body>\n  <script>\n    // 正则匹配的用途: 查找字符串中是否含有 某种字符\n    var words = prompt(\'请输入密码\')\n    console.log(\'words:\', words)\n\n    // 1. 验证是否含有数字\n    var x = words.match(/\\d/)\n    console.log(\'x:\', x)\n    console.log(x ? \'含有数字\' : \'不含数字\');\n\n    // 2. 验证是否有中文  [\\u4e00-\\u9fa5]\n    // 大全: http://www.codece.com/archives/273\n    var x = words.match(/[\\u4e00-\\u9fa5]/)\n    console.log(x ? \'有中文\' : \'无中文\');\n  </script>\n</body>\n\n</html>\n```\n\n## 替换\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>replace 16:40</title>\n</head>\n\n<body>\n  <script>\n    var phone = prompt(\"请输入手机号\")\n    console.log(\'phone:\', phone)\n\n    // {n} : 代表连续 n 个\n    // () : 捕获组 - 把正则表达式分成多个段落\n    var r = /(\\d{3})(\\d{4})(\\d{4})/\n    // 编号     1      2      3\n\n    // 按照正则匹配到相关的字符组合, 替换成\n    // $n: 第n个捕获组 捕捉的字符\n    var x = phone.replace(r, \'$1****$3\')\n    console.log(\'x:\', x)\n\n    // 转为: 188-4444-4444  这种格式\n    var x = phone.replace(r, \'$1-$2-$3\')\n    console.log(x)\n  </script>\n</body>\n\n</html>\n```\n\n## 验证\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>test 正则验证 16:53</title>\n</head>\n\n<body>\n  <script>\n    // 验证字符串是否符合正则表达式的要求\n    var phone = prompt(\'输入手机号\')\n    console.log(\'phone:\', phone);\n\n    // ^ : 输入的开始\n    // ^1 : 1是第一个字符\n    // [3-9] : 3 4 5 6 7 8 9 这个集合\n    // \\d{9} : 数字 有9个\n    // $ : 输入的结束\n    var r = /^1[3-9]\\d{9}$/\n\n    var x = r.test(phone) //正则.验证(手机号)\n    console.log(x ? \'是手机号\' : \'不是手机号\');\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 正则元字符\n\n| 字符                                                         | 含义                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [`\\`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backslash) | 依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 \"\\\" 的 \"b\" 通常匹配小写字母 \"b\"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 \"\\\"，它将不再匹配任何字符，而是表示一个[字符边界](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note)。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 \"转义（Escaping）\" 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。`/[a-z]\\s/i` 和 `new RegExp(\"[a-z]\\\\s\", \"i\")` 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（`\\s` 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 `/[a-z]:\\\\/i` 和 `new RegExp(\"[a-z]:\\\\\\\\\",\"i\")` 会创建相同的表达式，即匹配类似 \"C:\\\" 字符串。 |\n| [`^`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-caret) | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。例如，`/^A/` 并不会匹配 \"an A\" 中的 \'A\'，但是会匹配 \"An E\" 中的 \'A\'。当 \'`^`\' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。[反向字符集合](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set) 一节有详细介绍和示例。 |\n| [`$`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dollar) | 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。例如，`/t$/` 并不会匹配 \"eater\" 中的 \'t\'，但是会匹配 \"eat\" 中的 \'t\'。 |\n| [`*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-asterisk) | 匹配前一个表达式 0 次或多次。等价于 `{0,}`。例如，`/bo*/` 会匹配 \"A ghost boooooed\" 中的 \'booooo\' 和 \"A bird warbled\" 中的 \'b\'，但是在 \"A goat grunted\" 中不会匹配任何内容。 |\n| [`+`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-plus) | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`。例如，`/a+/` 会匹配 \"candy\" 中的 \'a\' 和 \"caaaaaaandy\" 中所有的 \'a\'，但是在 \"cndy\" 中不会匹配任何内容。 |\n| [`?`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-questionmark) | 匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`。例如，`/e?le?/` 匹配 \"angel\" 中的 \'el\'、\"angle\" 中的 \'le\' 以及 \"oslo\' 中的 \'l\'。如果**紧跟在任何量词 \\*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。例如，对 \"123abc\" 使用 `/\\d+/` 将会匹配 \"123\"，而使用 `/\\d+?/` 则只会匹配到 \"1\"。还用于先行断言中，如本表的 `x(?=y)` 和 `x(?!y)` 条目所述。 |\n| [`.`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-dot) | （小数点）默认匹配除换行符之外的任何单个字符。例如，`/.n/` 将会匹配 \"nay, an apple is on the tree\" 中的 \'an\' 和 \'on\'，但是不会匹配 \'nay\'。如果 `s` (\"dotAll\") 标志位被设为 true，它也会匹配换行符。 |\n| [`(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses) | 像下面的例子展示的那样，它会匹配 \'x\' 并且记住匹配项。其中括号被称为*捕获括号*。模式 `/(foo) (bar) \\1 \\2/` 中的 \'`(foo)`\' 和 \'`(bar)`\' 匹配并记住字符串 \"foo bar foo bar\" 中前两个单词。模式中的 `\\1` 和 `\\2` 表示第一个和第二个被捕获括号匹配的子字符串，即 `foo` 和 `bar`，匹配了原字符串中的后两个单词。注意 `\\1`、`\\2`、...、`\\n` 是用在正则表达式的匹配环节，详情可以参阅后文的 [\\n](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference) 条目。而在正则表达式的替换环节，则要使用像 `$1`、`$2`、...、`$n` 这样的语法，例如，`\'bar foo\'.replace(/(...) (...)/, \'$2 $1\')`。`$&` 表示整个用于匹配的原字符串。 |\n| [`(?:x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses) | 匹配 \'x\' 但是不记住匹配项。这种括号叫作*非捕获括号*，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 `/(?:foo){1,2}/`。如果表达式是 `/foo{1,2}/`，`{1,2}` 将只应用于 \'foo\' 的最后一个字符 \'o\'。如果使用非捕获括号，则 `{1,2}` 会应用于整个 \'foo\' 单词。更多信息，可以参阅下文的 [Using parentheses](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses) 条目。 |\n| [`x(?=y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead) | 匹配\'x\'仅仅当\'x\'后面跟着\'y\'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到\'Jack\'仅当它后面跟着\'Sprat\'。/Jack(?=Sprat\\|Frost)/匹配‘Jack’仅当它后面跟着\'Sprat\'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 |\n| [`(?<=y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead)x | 匹配\'x\'仅当\'x\'前面是\'y\'.这种叫做后行断言。例如，/(?<=Jack)Sprat/会匹配到\' Sprat \'仅仅当它前面是\' Jack \'。/(?<=Jack\\|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是\'Jack\'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。 |\n| [`x(?!y)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-look-ahead) | 仅仅当\'x\'后面不跟着\'y\'时匹配\'x\'，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!\\.)/ 匹配一个数字。正则表达式/\\d+(?!\\.)/.exec(\"3.141\") 匹配‘141’而不是‘3.141’ |\n| `(?<!*y*)*x*`                                                | 仅仅当\'x\'前面不是\'y\'时匹配\'x\'，这被称为反向否定查找。例如，仅仅当这个数字前面没有负号的时候，`/(?<!-)\\d+/` 匹配一个数字。 `/(?<!-)\\d+/.exec(\'3\')` 匹配到 \"3\". `/(?<!-)\\d+/.exec(\'-3\')` 因为这个数字前有负号，所以没有匹配到。 |\n| [`x|y`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-or) | 匹配‘x’或者‘y’。例如，/green\\|red/匹配“green apple”中的‘green’和“red apple”中的‘red’ |\n| [`{n}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier) | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的\'a\',但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个\'a\'。 |\n| [`{n,}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier) | n 是一个正整数，匹配前一个字符至少出现了 n 次。例如，/a{2,}/ 匹配 \"aa\", \"aaaa\" 和 \"aaaaa\" 但是不匹配 \"a\"。 |\n| [`{n,m}`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier-range) | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。 |\n| [`[xyz\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-character-set) | 一个字符集合。匹配方括号中的任意字符，包括[转义序列](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types)。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和 [a-d] 是一样的。他们都匹配\"brisket\"中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。 |\n| [`[^xyz\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set) | 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配\"brisket\"中的‘r’，也匹配“chop”中的‘h’。 |\n| [`[\\b\\]`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backspace) | 匹配一个退格 (U+0008)。（不要和\\b混淆了。）                  |\n| [`\\b`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word-boundary) | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\\b] 混淆了）使用\"moon\"举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配\"moon\"中的\'oo\'，因为\'oo\'被一个“字”字符\'n\'紧跟着。 /oon\\b/匹配\"moon\"中的\'oon\'，因为\'oon\'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。**备注：** JavaScript 的正则表达式引擎将[特定的字符集](https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6)定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 |\n| [`\\B`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word-boundary) | 匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，/\\B../匹配\"noonday\"中的\'oo\', 而/y\\B../匹配\"possibly yesterday\"中的’yes‘ |\n| [`\\c*X*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-control) | 当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。例如，`/\\cM/` 匹配字符串中的 control-M (U+000D)。 |\n| [`\\d`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-digit) | 匹配一个数字`。``等价于 [0-9]`。例如， `/\\d/` 或者 `/[0-9]/` 匹配\"B2 is the suite number.\"中的\'2\'。 |\n| [`\\D`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-digit) | 匹配一个非数字字符`。``等价于 [^0-9]`。例如， `/\\D/` 或者 `/[^0-9]/` 匹配\"B2 is the suite number.\"中的\'B\' 。 |\n| [`\\f`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-form-feed) | 匹配一个换页符 (U+000C)。                                    |\n| [`\\n`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-line-feed) | 匹配一个换行符 (U+000A)。                                    |\n| [`\\r`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-carriage-return) | 匹配一个回车符 (U+000D)。                                    |\n| [`\\s`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space) | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，`/\\s\\w*/` 匹配\"foo bar.\"中的\' bar\'。经测试，\\s不匹配\"[\\u180e](https://unicode-table.com/cn/180E/)\"，在当前版本 Chrome(v80.0.3987.122) 和 Firefox(76.0.1) 控制台输入/\\s/.test(\"\\u180e\") 均返回 false。 |\n| [`\\S`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-white-space) | 匹配一个非空白字符。等价于 `[^ `\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff`]`。例如，`/\\S\\w*/` 匹配\"foo bar.\"中的\'foo\'。 |\n| [`\\t`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-tab) | 匹配一个水平制表符 (U+0009)。                                |\n| [`\\v`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-vertical-tab) | 匹配一个垂直制表符 (U+000B)。                                |\n| [`\\w`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word) | 匹配一个单字字符（字母、数字或者下划线）。等价于 `[A-Za-z0-9_]`。例如，`/\\w/` 匹配 \"apple,\" 中的 \'a\'，\"$5.28,\"中的 \'5\' 和 \"3D.\" 中的 \'3\'。 |\n| [`\\W`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word) | 匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`。例如，`/\\W/` 或者 `/[^A-Za-z0-9_]/` 匹配 \"50%.\" 中的 \'%\'。 |\n| [`\\*n*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference) | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。比如 `/apple(,)\\sorange\\1/` 匹配\"apple, orange, cherry, peach.\"中的\'apple, orange,\' 。 |\n| [`\\0`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-null) | 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 `\\0<digits>` 是一个八进制转义序列。 |\n| [`\\xhh`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-hex-escape) | 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。              |\n| [`\\uhhhh`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-unicode-escape) | 匹配一个四位十六进制数表示的 UTF-16 代码单元。               |\n| `\\u{hhhh}或\\u{hhhhh}`                                        | （仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。 |\n\n## 构造\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>RegExp 17:21</title>\n</head>\n\n<body>\n  <script>\n    // 正则表达式的构造方式:  RegExp\n    var words = \'Hello123 World456\'\n\n    // 字面量语法  /\\d/g\n    // 参数1: 元字符    参数2: 修饰符\n    // JS中 \\ 是转义符;  需要用 \\\\ 把转成普通 \\\n    var r = new RegExp(\'\\\\d\', \'g\')\n    console.dir(r)\n\n    console.log(words.match(r))\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## 总结\n\nJS高级的内容 主要是为 后期的DOM 而服务!\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\"]', 0, 0),
(18, 'Vue基础02', 'Vue配置项、双向绑定等……', '# Vue02\n\n> 注意: Tmooc 的 Vue01 在 jQuery04 绑定的\n\n## 复习\n\nVue: `由中国人 尤雨溪 开发, 属于前端三大框架之一; 在国内占有率No.1`\n\n- 理念: `自动化` -- 全自动托管所有的DOM操作, 用户只要关注数据的变更即可\n- 缺点: 让程序员变`傻`..\n- 本质是一款生产力工具, 学会使用 就能开发网站\n\n创建Vue对象时, 相关的配置项:\n\n- el: 代表vue管理的DOM元素, 值是id选择器\n- data: 存储数据 -- 可以在页面上使用, 保存在vue对象中\n- methods: 存储函数 - 可以在页面上使用, 保存在vue对象里\n\n`指令`:由vue提供的一些属性\n\n- v-show: 根据值决定是否隐藏元素, 本质是修改 css 的 display:none\n- v-on : 事件绑定\n  - v-on:事件名=\"\"\n  - @事件名=\"\"\n  - 关于方法的()\n    - `@事件名=\"方法名\"` : 默认传递 `事件参数` 作为实参\n    - `@事件名=\"方法名()\"`: 自定义传参模式, 需要用 `$event`关键词来代表事件参数进行传递\n- v-bind: 属性绑定\n  - `v-bind:属性名=\"JS代码\"`\n  - `:属性名=\"JS代码\"`\n- v-once: 一次性渲染\n  - 初次渲染后, 不再更新自身\n\n插值语法: `{{}}`\n\n- 类似JS中的 模板字符串的 `${}`,  可以在html的标签内容部分书写JS代码\n\n动态样式:\n\n- `:class=\"{样式类: true/false}\"`: true添加样式  false不添加样式\n  - 场景: 根据条件来切换`固定`的样式\n- `:style=\"{属性名: 值}\"`\n  - 场景: 适合动态调整CSS样式\n\n---\n\n脚手架: 真正做项目时使用的 `工程化` 的方案\n\n- 按照脚手架软件, 然后利用此软件生成项目包\n\n- 安装软件的注意事项:\n\n  - node版本 12-16\n  - npm: 必须中国镜像!!!\n\n- 生成项目包: 注意事项特别多\n\n  - 项目包所在目录路径中, 不允许有特殊字符(`除了字母 数字 _`)\n  - 生成包, 必须按照教程一模一样的生成\n\n- 启动项目包:\n\n  - 在`项目目录下`执行: `npm run serve`\n\n    <img src=\"assets/image-20220916092412900.png\" alt=\"image-20220916092412900\" style=\"zoom:67%;\" />\n\n  - <img src=\"assets/image-20220916092506503.png\" alt=\"image-20220916092506503\" style=\"zoom:60%;\" />\n\n  - 浏览器中访问服务器, 地址看cmd ↑\n\n    <img src=\"assets/image-20220916092609069.png\" alt=\"image-20220916092609069\" style=\"zoom:67%;\" />\n\n## 项目包的使用\n\n> 项目包非常专业, 必须用`单独的`vscode窗口来开启\n>\n> - 多开vscode的技巧: \n>\n>   ![image-20220916092954127](assets/image-20220916092954127.png)\n>\n> - 把项目包 文件夹拖拽到 开启的vscode窗口里\n>\n>   <img src=\"assets/image-20220916093131280.png\" alt=\"image-20220916093131280\" style=\"zoom:47%;\" />\n>\n>   <img src=\"assets/image-20220916093234480.png\" alt=\"image-20220916093234480\" style=\"zoom:67%;\" />\n\n插件:\n\n<img src=\"assets/image-20220916093342555.png\" alt=\"image-20220916093342555\" style=\"zoom: 67%;\" />\n\n`注意`: 首次打开 .vue 文件,  vscode会`智障`推荐一款vue插件 -- 是vue3 的插件\n\n<img src=\"assets/image-20220916093544332.png\" alt=\"image-20220916093544332\" style=\"zoom: 33%;\" />\n\n- 不兼容目前学习的vue2, 会各种报错,  代码会有各种波浪线提示\n\n- 不小心安装, 到插件里禁用即可\n\n  ![image-20220916093751291](assets/image-20220916093751291.png)\n\n## 项目目录\n\n<img src=\"assets/image-20220916094053220.png\" alt=\"image-20220916094053220\" style=\"zoom:50%;\" />\n\n\n\n## 完整的插件\n\n![image-20220916104247540](assets/image-20220916104247540.png)\n\n\n\n## 关于key\n\n没有key的场景\n\n- 尽量复用已有的元素, 把元素上的值进行修改\n\n<img src=\"assets/image-20220916115044230.png\" alt=\"image-20220916115044230\" style=\"zoom:50%;\" />\n\n有key的场景\n\n- 尽量复用之前相同 key值的DOM元素, 最大程度减少修改DOM的次数\n\n  > 这种性能的提升, 仅在 数组元素有 `增删` 的场景中才效果\n  >\n  > `所以`: 在后续的vue版本中, 不再强制用户书写key属性, 而是按需书写\n\n![image-20220916115553652](assets/image-20220916115553652.png)\n\n\n\n## 入门\n\n```html\n<template>\n  <!-- 仅限1个根元素 -->\n  <div>\n    <!-- 快捷生成基础代码: < 或 vbase  前提要安装插件,详见笔记 -->\n    <h1>Hello Vue!</h1>\n    <div>名字: {{ name }}</div>\n    <div>地址: {{ address }}</div>\n    <button @click=\"num++\">{{ num }}</button>\n    <!-- 图片的使用: 用public目录下的 -->\n    <!-- /代表根路径.  public是静态托管目录, 要通过根路径访问 -->\n    <img src=\"/img/banner1.png\" alt=\"\" />\n    <!-- 完整格式: -->\n    <img src=\"http://localhost:8080/img/banner1.png\" alt=\"\" />\n\n    <!-- src/assets 目录, 也可以存储静态文件; 需要用相对路径调用 -->\n    <img src=\"./assets/logo.png\" alt=\"\" />\n\n    <!-- \n      存放静态文件有两个目录: public 和 assets\n\n      真正的大型项目, 在交付时需要进行打包处理, 留下主要代码\n      - webpack工具: 在扩展课程 6阶段中有\n\n      - public: 简单粗暴-所有放在此目录下的文件都会打包到最终项目文件夹里\n      - assets: 智能分辨-会自动识别项目中用到的文件 再打包到最终代码里\n      \n      假设文件夹里有100张图: 我的项目中使用了其中40张, 另外60个没用上\n      - 放public下: 会都被保留下来\n      - 放assets里: 会保留40张用到的, 其他60个会被删除\n     -->\n\n    <!-- 由于项目包默认会运行 App.vue 的代码 -->\n    <!-- 所以: 练习阶段, 哪个文件叫 App.vue 就会运行哪个文件 -->\n  </div>\n\n  <!-- <div></div> -->\n</template>\n\n<script>\n// ES6的导出语法, 导出到 main.js 中, 被放到 new Vue 里了\n// 在 {} 中书写的代码, 就相当于是在 new Vue({}) 中书写的\nexport default {\n  // ctrl+i : 查看所有选项\n  // vdata\n  // 脚手架项目包中, data必须是函数, 返回一个数据对象\n  // 原因与 复用有关 -- 以后详细说\n  data() {\n    return {\n      num: 1,\n      name: \'阿斌\',\n      address: \'郑州芯互联大厦\',\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## text html prev\n\n```html\n<template>\n  <div>\n    <!-- 指令: vue提供的一些属性 -->\n    <!-- v-html: 快速设置 innerHTML 属性的值, 被解析成HTML -->\n    <p v-html=\"words\"></p>\n    <!-- v-text: 快速设置 innerText 属性的值, 纯文本展示 -->\n    <p v-text=\"words\"></p>\n    <hr />\n    <!-- {{}}: 是vue的语法 -->\n    <div>{{ 8 + 8 }}</div>\n    <!-- v-pre: 不解析vue语法 -->\n    <div v-pre>{{ 8 + 8 }}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      words: \'<h1>Hello World!</h1>\',\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n\n\n## for\n\n```html\n<template>\n  <div>\n    <!-- 核心操作: 数组数据 转 HTML 代码 -->\n    <ul>\n      <!-- 作者借鉴了 JS的 for...in 遍历语法, 融入到HTML -->\n      <!-- JS中:  for(const x in names){} -->\n      <!-- v-for: 自动遍历数组, 生成元素 -->\n      <li v-for=\"x in names\">{{ x }}</li>\n    </ul>\n\n    <!-- for..of 语法同效果, 无差异 -->\n    <!-- 在vue中 of 和in 没有区别, 选你喜欢的 -->\n    <button v-for=\"bin of names\">{{ bin }}</button>\n\n    <!-- 下标语法 -->\n    <hr />\n    <!-- (值, 序号) in/of 数组 -->\n    <!-- 注意: in/of 左右的空格是必须的 -->\n    <button v-for=\"(x, i) in names\">{{ i }} - {{ x }}</button>\n\n    <!-- 支持遍历数字 -->\n    <hr />\n    <button v-for=\"n in 10\">{{ n }}</button>\n    <hr />\n    <button v-for=\"n in 10\">{{ n * 5 }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      names: [\'泡泡\', \'铭铭\', \'亮亮\', \'小新\'],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## key\n\n```html\n<template>\n  <div>\n    <ul>\n      <!-- 当前报错: 是旧版本的vue中, 强制要求写 key 属性 -->\n      <!-- 新版本vue不再强制, 但是插件没更新, 所以依然报错 -->\n\n      <!-- 解决办法 -->\n      <!-- 1. 这不是真的报错, 可以忍着... -->\n      <!-- 2. 关闭插件报错功能 -- 影响太大 -->\n      <!-- 3. 补充key属性 -->\n      <!-- 为了避免key重复, 用 序号做标识更好一点 -->\n      <li v-for=\"(x, i) in names\" :key=\"i\">{{ x }}</li>\n\n      <!-- key: 是唯一标识, 提高数组元素增删时的重复渲染效率 -->\n\n      <!-- 案例: 参加运动会, 每个人都会带矿泉水, 走方阵时会留在座位附近;  回来以后如何分辨哪瓶水是谁的?\n      方案: 做记号; 可以通过记号找到之前的水瓶\n      -->\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      names: [\'泡泡\', \'泡泡\', \'亮亮\', \'铭铭\'],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## for练习\n\n```html\n<template>\n  <div>\n    <ul>\n      <li v-for=\"(skill, i) in skills\" :key=\"i\">\n        {{ skill }}\n      </li>\n    </ul>\n\n    <table border=\"1\">\n      <thead>\n        <tr>\n          <td>姓名</td>\n          <td>年龄</td>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"(emp, i) in emps\" :key=\"i\">\n          <td>{{ emp.name }}</td>\n          <td>{{ emp.age }}</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      skills: [\'dom\', \'jQuery\', \'vue\', \'express\'],\n      emps: [\n        { name: \'泡泡0\', age: 18 },\n        { name: \'泡泡1\', age: 19 },\n        { name: \'泡泡2\', age: 29 },\n        { name: \'泡泡3\', age: 30 },\n      ],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n// 如果页面报错: 关键词 sass-loader, 说明生成项目包时没有勾选css预编译选项, 需要重新按照教程生成项目包 或 下载老师提供的压缩包\n// 支持scss语法\ntable {\n  border-collapse: collapse;\n  thead {\n    background-color: #eee;\n  }\n\n  td {\n    border: 1px solid gray;\n    padding: 10px 20px;\n  }\n}\n</style>\n\n```\n\n\n\n## 购物车完整版\n\n```html\n<template>\n  <div>\n    <table>\n      <thead>\n        <tr>\n          <td>\n            <label>\n              <!-- checked: 用于设定勾选状态 -->\n              <input\n                @change=\"checkAll\"\n                type=\"checkbox\"\n                :checked=\"isCheckAll\"\n              />\n              全选\n            </label>\n          </td>\n          <td>序号</td>\n          <td>商品名</td>\n          <td>单价</td>\n          <td>数量</td>\n          <td>小计</td>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"(food, i) in foods\" :key=\"i\">\n          <td>\n            <!-- 推荐单标签闭合, 以前版本会报错, 如果不闭合 -->\n            <input type=\"checkbox\" v-model=\"food.checked\" />\n            {{ food.checked }}\n          </td>\n          <td>{{ i + 1 }}</td>\n          <td>{{ food.name }}</td>\n          <td>¥{{ food.price }}</td>\n          <td>\n            <button\n              @click=\"food.count--\"\n              :disabled=\"food.count == 1\"\n            >\n              -\n            </button>\n            <span>{{ food.count }}</span>\n            <button @click=\"food.count++\">+</button>\n          </td>\n          <td>¥{{ food.price * food.count }}</td>\n        </tr>\n      </tbody>\n      <tfoot>\n        <tr>\n          <td colspan=\"5\">总价格: ¥{{ getTotal }}</td>\n          <!-- vue的自动化特色: 只要数据有变化, 相关的所有DOM元素都会刷新 -->\n        </tr>\n      </tfoot>\n    </table>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 事件触发的方法: methods\n  methods: {\n    // 如果事件在调用时,没写(), 则默认的参数1 是事件参数\n    checkAll(e) {\n      console.log(e.target.checked) //查看 checked 属性\n      // 读取全选框的值, 赋值给每个商品的checked属性\n      this.foods.forEach(\n        food => (food.checked = e.target.checked)\n      )\n    },\n  },\n\n  computed: {\n    //判断是否全选: 每一个的checked都是true\n    isCheckAll() {\n      return this.foods.every(food => food.checked)\n    },\n    getTotal() {\n      // reduce: 让数组元素合并出一个值\n      var a = this.foods.reduce((sum, food) => {\n        const { price, count, checked } = food\n        // *true 相当于 *1\n        // *false 相当于 *0 = 0\n        // 没有勾选, 就是 sum + 0, 即不累加\n        return sum + price * count * checked\n      }, 0)\n\n      return a\n    },\n  },\n\n  data() {\n    return {\n      foods: [\n        { name: \'茶碗蒸蛋\', price: 9, count: 1, checked: true },\n        { name: \'小笼包\', price: 12, count: 4, checked: false },\n        { name: \'豆腐脑\', price: 6, count: 10, checked: true },\n        { name: \'豆浆\', price: 4, count: 1, checked: false },\n        { name: \'油条\', price: 2, count: 7, checked: true },\n      ],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\ntable {\n  border-collapse: collapse;\n\n  thead {\n    background-color: #eee;\n  }\n  td {\n    padding: 10px 20px;\n    border: 1px solid gray;\n\n    span {\n      display: inline-block;\n      width: 40px;\n      text-align: center;\n    }\n  }\n}\n</style>\n\n```\n\n\n\n## 计算属性\n\n```html\n<template>\n  <div>\n    <!-- 计算属性：get   一个函数如果是计算属性，则使用时不需要（）就能触发 -->\n    <button @click=\"showThis\">显示vue对象</button>\n    <p>{{ getTotal() }}</p>\n    <!-- 总结: 如果一个函数 需要自动触发 && 不需要传参, 就可以制作成计算属性 -->\n    <!-- 注意: 事件绑定的函数不能是计算属性, 因为是通过事件触发的 -->\n    <p>{{ getSum }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 放在这里的函数, 会自动转换为 计算属性, 使用时不需要()调用\n  computed: {\n    getSum() {\n      return 10 + 20\n    },\n  },\n\n  methods: {\n    getTotal() {\n      return 10 + 20\n    },\n    showThis() {\n      console.log(this)\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 双向绑定 v-model\n\n```html\n<template>\n  <div>\n    <!-- 表单元素专属: 双向数据绑定 -->\n    <!-- 单向: 把数据 显示到 DOM元素 -->\n    <div>{{ kw }}</div>\n    <!-- 双向: 表单元素- 输入框,单选框,多选框,下拉框... -->\n    <!-- 这些元素 用户可以操作,可以修改其值 -->\n\n    <!-- v-model: 做了两件事 -->\n    <!-- 1. kw变量的值 绑定在DOM元素上 -->\n    <!-- 2. 当输入框的值被用户修改, 同步更新到kw变量中 -->\n    <input type=\"text\" v-model=\"kw\" />\n    <!-- 作用: 把变量 和 输入框的值 实时绑定在一起, 可以用来收集输入框的值 -->\n\n    <table>\n      <tbody>\n        <tr>\n          <td>用户名:</td>\n          <td><input type=\"text\" v-model=\"uname\" /></td>\n        </tr>\n        <tr>\n          <td>密码:</td>\n          <td><input type=\"password\" v-model=\"upwd\" /></td>\n        </tr>\n        <tr>\n          <td>邮箱:</td>\n          <td><input type=\"email\" v-model=\"email\" /></td>\n        </tr>\n        <tr>\n          <td>手机号:</td>\n          <td><input type=\"text\" v-model=\"phone\" /></td>\n        </tr>\n        <tr>\n          <td></td>\n          <td><button @click=\"login\">提交注册信息</button></td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 双向绑定: 就是把变量和表单元素绑定在一起, 可以实时收集表单元素的值\n  methods: {\n    login() {\n      console.log(this.uname, this.upwd, this.email, this.phone)\n    },\n  },\n  data() {\n    return {\n      kw: \'123456\',\n      // 设置4个变量, 和输入框双向绑定在一起\n      uname: \'\',\n      upwd: \'\',\n      email: \'\',\n      phone: \'\',\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n```html\n<template>\n  <div>\n    <!-- 双向数据绑定: 把变量和表单元素绑定在一起, 表单元素的值变化, 会同步更新变量 -->\n    <table>\n      <tbody>\n        <tr>\n          <td>性别: {{ gender }}</td>\n          <td>\n            <input\n              type=\"radio\"\n              v-model=\"gender\"\n              name=\"sex\"\n              value=\"0\"\n            />男\n            <br />\n            <input\n              type=\"radio\"\n              v-model=\"gender\"\n              name=\"sex\"\n              value=\"1\"\n            />女\n          </td>\n        </tr>\n\n        <tr>\n          <td>阿斌的特长:{{ specs }}</td>\n          <td>\n            <input v-model=\"specs\" type=\"checkbox\" value=\"0\" />吃\n            <br />\n            <input v-model=\"specs\" type=\"checkbox\" value=\"1\" />喝\n            <br />\n            <input v-model=\"specs\" type=\"checkbox\" value=\"2\" />唱\n            <br />\n            <input v-model=\"specs\" type=\"checkbox\" value=\"3\" />跳\n            <br />\n            <input\n              v-model=\"specs\"\n              type=\"checkbox\"\n              value=\"4\"\n            />打篮球 <br />\n          </td>\n        </tr>\n\n        <tr>\n          <td>是否同意阿斌的交往请求: {{ agree }}</td>\n          <td>\n            <input type=\"checkbox\" v-model=\"agree\" />\n          </td>\n        </tr>\n        <tr>\n          <td>阿斌的座驾:{{ tool }}</td>\n          <td>\n            <select v-model=\"tool\">\n              <option value=\"0\">雅迪</option>\n              <option value=\"1\">小牛</option>\n              <option value=\"2\">共享单车</option>\n              <option value=\"3\">公交车</option>\n            </select>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      gender: 0,\n      // 多选的值, 用数组来存储\n      specs: [],\n      // 是否勾选: 值是布尔类型\n      agree: true,\n      // 工具\n      tool: 0,\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(19, 'Vue基础03', '自定义指令、axios', '# Vue03\n\n## 复习\n\nVue: `生产力工具` - 背Api 学会使用即可\n\n- 选项: 创建Vue对象时可`选`的配置`项`\n  - DOM\n    - el: 设置vue对象管理的元素\n    - render: 渲染 `.vue` 文件到 vue对象里 -- 详见`main.js`\n  - 数据\n    - data : 用于存放数据\n      - 在脚手架项目包中, data需要是`函数类型`, 通过返回值来返回数据\n    - methods\n      - 存储`函数`, 这些函数需要用()来触发, 适合于事件捆绑\n      - 事件:\n        - @事件名=\"方法名\" : 默认实参是 事件参数\n        - @事件名=\"方法名()\" : 自定义传参模式, 需要使用`$event` 关键词来传递事件参数\n    - computed\n      - 计算属性: `函数`放在这个对象里, 会自动改为计算属性, 使用时不需要()就能自动触发\n      - 注意事项: 不适合与事件捆绑使用\n- 指令: vue提供的一些属性\n  - v-text: 本质是 innerText, 用于设置文本\n  - v-html: 本质是 innerHTML, 用于设置HTML代码, 会被解析\n  - v-pre: 让vue的`{{}}`语法不被解析\n  - v-show: 根据值来决定是否隐藏元素\n  - v-once:一次性渲染\n  - v-on:事件绑定,  语法糖 `@`\n  - v-bind: 属性绑定, 语法糖 `:`\n  - v-for: 遍历数据 生成DOM元素\n    - v-for=\"值 in/of 数组\"\n    - v-for=\"(值, 序号) in/of 数组\"\n    - v-for=\"值 in/of 数字\"\n    - `key`: 为 for生成的DOM元素添加唯一标识\n      - 当数组元素有 增删时, DOM元素会尽量复用之前已有的同样唯一标识的元素\n  - v-model: 双向数据绑定\n    - 适用于用户可修改值的元素:  表单元素 --`输入框,单选框,多选框,勾选,下拉框...`\n    - 方向1: 变量捆绑到DOM元素上显示\n    - 方向2: DOM元素的值变化, 同步更新到变量中\n    - 最终效果: 变量的值 和 DOM元素的值必然相同\n\n## class操作\n\n```html\n<template>\n  <div>\n    <div id=\"nav\">\n      <!-- 如果不理解, 可以看前天的代码 -->\n      <span\n        :class=\"{ active: now == i }\"\n        @click=\"now = i\"\n        v-for=\"(nav, i) in navs\"\n        :key=\"i\"\n      >\n        {{ i }}-{{ nav }}\n      </span>\n    </div>\n    <h3>now:{{ now }}</h3>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      navs: [\'首页\', \'关于净美仕\', \'公司动态\', \'产品中心\', \'联系我们\'],\n      now: 0, // 当前激活的序号\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n#nav {\n  background-color: #002c69;\n  display: flex;\n\n  span {\n    padding: 10px 25px;\n    color: white;\n    user-select: none;\n\n    // & :并且;  相当于 span.active\n    &.active {\n      background-color: orange;\n    }\n  }\n}\n</style>\n\n```\n\n练习\n\n```html\n<template>\n  <div>\n    <ul>\n      <li\n        @click=\"now = i\"\n        :class=\"{ active: i == now }\"\n        v-for=\"(item, i) in items\"\n        :key=\"i\"\n      >\n        {{ item }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      now: 0,\n      items: [\n        \'双核i5/8GB内存/128GB闪存\',\n        \'双核i5/8GB内存/256GB闪存\',\n        \'定制款: 双核i5/8GB内存/128GB闪存\',\n        \'定制款: 双核i5/8GB内存/256GB闪存\',\n      ],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\nul,\nli {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n}\n\nul {\n  display: flex;\n  flex-wrap: wrap;\n\n  li {\n    margin: 5px;\n    border: 3px solid gray;\n    color: gray;\n    padding: 5px;\n    white-space: nowrap;\n    user-select: none;\n\n    &.active {\n      border-color: blue;\n    }\n  }\n}\n</style>\n\n```\n\n## 自定义指令\n\n```html\n<template>\n  <div>\n    <!-- 自定义指令: 用户可以制作自己的指令 -->\n    <ul>\n      <!-- 指令必须是 v- 开头 -->\n      <li v-blue>泡泡</li>\n      <li>铭铭</li>\n      <!-- 练习: v-green 让元素颜色变绿 green -->\n      <li v-green>亮亮</li>\n      <li v-blue>阿斌</li>\n      <!-- 带有值的指令 -->\n      <li v-color=\"\'orange\'\">欣怡</li>\n      <li v-color=\"\'yellow\'\">凯凯</li>\n      <!-- 值true就隐藏  css的display = \'none\' -->\n      <li v-hide=\"true\">梦瑶11</li>\n      <!-- 值false就不隐藏 css的display=\'\' -->\n      <li v-hide=\"false\">梦瑶22</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  // directive: 指令\n  directives: {\n    hide(el, bindings) {\n      el.style.display = bindings.value ? \'none\' : \'\'\n      console.dir(el)\n    },\n\n    color(el, bindings) {\n      // 参数1: DOM元素\n      // 参数2: 指令携带的信息, 包括名称和值 等...\n      console.log(arguments)\n      el.style.color = bindings.value\n    },\n\n    green(el) {\n      el.style.color = \'green\'\n    },\n    // v-blue: v- 是标识;  blue 是指令名\n    blue(el) {\n      // 参数1: 指令所在的DOM元素\n      // console.log(arguments)\n      console.log(el)\n      el.style.color = \'blue\'\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n高级配置\n\n```html\n<template>\n  <div>\n    <!-- 自定义指令的高级用法 -->\n    <input type=\"text\" /><br />\n    <input type=\"text\" /><br />\n    <!-- 系统的autofocus属性, 可以让元素自动获得焦点 -->\n    <!-- 自制 v-focus 指令, 实现相同的操作 -->\n    <input type=\"text\" v-focus /><br />\n    <input type=\"text\" /><br />\n  </div>\n</template>\n\n<script>\nexport default {\n  directives: {\n    // 指令的精确配置模式:  指令名:{配置项...}\n    focus: {\n      // inserted:嵌入;  指令所在的元素 嵌入到 页面中展示出来\n      // DOM元素的生命周期: 内存中创建->渲染到页面->更新->销毁\n      // 让元素获得焦点在哪个周期?  必须是元素呈现到页面上以后\n      // inserted: 会在DOM元素 呈现到页面上后 自动触发\n      inserted(el) {\n        el.focus()\n      },\n    },\n\n    // 此写法: 默认是在DOM元素 内存创建阶段触发的, 获取焦点会失败\n    // focus(el) {\n    //   // focus(): 元素自带的方法, 调用后会获得焦点\n    //   el.focus()\n    // },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## axios\n\n网络请求的基础模块: `XHR 或 fetch`\n\n由于原生的请求代码较为复杂, 所以会进行封装后使用\n\n- jQuery: `$.get(请求地址, data=>{})`\n\n  - 利用封装 - 回调函数方案\n  - 缺点: 存在`回调地狱`风险,  在ES6中的 Promise 方案被解决\n\n- axios: 一款专业的用 `Promise` 封装而来的 网络请求模块, 不存在回调地狱风险\n\n  官网: http://www.axios-js.com/\n\n  vue版本: http://www.axios-js.com/docs/vue-axios.html\n\n  项目中默认不具有此模块, 需要单独安装\n\n  - 在`项目包目录`下执行安装命令: `npm i axios vue-axios`\n\n    > 考虑到有些同学网络问题可能无法安装:  之前在FTP和百度网盘提供的包,已经安装过此模块\n\n    ![image-20220917112503284](Vue03.assets/image-20220917112503284.png)\n\n## 网络请求\n\n```html\n<template>\n  <div>\n    <button @click=\"getData\">获取数据</button>\n\n    <!-- <div>网络数据: {{ data }}</div> -->\n\n    <!-- 由于网络请求是异步操作, 所以数据项 data的值 -->\n    <!-- 初始时是null, 请求到数据以后 才被赋予真正的数据 -->\n    <!-- 使用时, 必须判断 data 不是null 再使用, 才不会报错 -->\n\n    <!-- v-if: 如果值是真的, 才会加载这个DOM元素; -->\n    <div v-if=\"data\">\n      <div>message: {{ data.message }}</div>\n      <!-- 遍历展示 list -->\n      <div v-for=\"(x, i) in data.data.list\" :key=\"i\">\n        {{ x.title }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n// axios: 网络请求模块, 前提要先安装  npm i axios vue-axios\n// 使用方式分两种: 局部  全局\n// 局部用法: 在 .vue 文件中, 引入axios模块\n\n// ES6的模块导入语法, 对应的旧语法  const axios = require(\'axios\')\nimport axios from \'axios\' //页面没报错,说明已安装\nexport default {\n  // 页面上只能显示 data 选项中的数据\n  data() {\n    return {\n      // 提前准备一个变量, 用于存储请求到的数据\n      // 属性名随意, data更专业 - 数据\n      data: null, // 初始值为空\n    }\n  },\n\n  methods: {\n    getData() {\n      const url = \'http://api.xin88.top/car/news.json\'\n      // get(接口地址)\n      // then: 然后; 请求完毕后执行这里的箭头函数\n      axios.get(url).then(res => {\n        // res: response响应; 代表服务器响应的数据\n        console.log(\'res:\', res)\n        // 把请求到的数据 保存到 本地准备的 data 变量\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 常见错误\n\n无法对null读取属性: `\'xxx\'`\n\n![image-20220917115203497](Vue03.assets/image-20220917115203497.png)\n\n<img src=\"Vue03.assets/image-20220917115102948.png\" alt=\"image-20220917115102948\" style=\"zoom: 25%;\" />\n\n\n\n\n\n## if\n\n```html\n<template>\n  <div>\n    <!-- v-if 指令: 当条件为真的时候 才会触发相关的代码 -->\n    <!-- 真:加载元素  假:不加载元素 -->\n    <div v-if=\"true\">Hello</div>\n    <div v-if=\"false\">Vue</div>\n    <hr />\n    <!-- 面试常问: v-if 和 v-show 都可以让元素不显示, 区别? -->\n    <!-- v-if: 不加载元素 -->\n    <!-- v-show: 加载元素但是用 css来隐藏 -->\n\n    <!-- v-if 和 v-show 的取舍? -->\n    <!-- v-show: 把元素准备好, 随时可以展示; 适合元素频繁切换显示 -->\n    <!-- v-if: 如果满足条件再展示; 适合元素切换不频繁的场景 -->\n    <!--    -- 网络请求: 请求的数据 未完成前不展示, 完成后再显示 -->\n    <div v-show=\"false\">world</div>\n\n    <h3>阿斌的好感度得分: {{ score }}</h3>\n    <button @click=\"score -= 10\">-10</button>\n    <button @click=\"score += 10\">+10</button>\n\n    <p v-if=\"score < 60\">避而不见</p>\n    <p v-else-if=\"score < 80\">一起吃饭</p>\n    <p v-else-if=\"score < 90\">一起看电影</p>\n    <p v-else>一起逛街</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      score: 60,\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 练习\n\n```html\n<template>\n  <div>\n    <!-- http://www.codeboy.com:9999/mfresh/data/news_select.php -->\n    <!-- 1. 引入axios模块 -->\n    <!-- 2. 在methods选项中, 制作一个 getData 方法, 绑定在按钮点击事件 -->\n    <!-- 3. getData中书写 axios 请求, 点击后后台查看数据 -->\n    <!-- 4. data选项中, 制作 data属性, 把请求到的数据保存到这里 -->\n    <!-- 5. 页面上用 div 配合 v-if 判断data存在, 在进行数据的使用 -->\n    <!-- 6. 利用 div + v-for 完成数据的展示, 添加css -->\n    <button @click=\"getData\">获取数据</button>\n    <!-- 判断数据存在, 再使用数据来创建DOM -->\n    <!-- vue底层规定: v-if 不能和 v-for 写在一个标签, 会形成遍历+判断, 影响性能 -->\n    <div v-if=\"data\" class=\"box\">\n      <div v-for=\"x in data.data\" :key=\"x.nid\">{{ x.title }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\n\nexport default {\n  data() {\n    return {\n      data: null,\n    }\n  },\n\n  methods: {\n    getData() {\n      const url = \'http://www.codeboy.com:9999/mfresh/data/news_select.php\'\n\n      axios.get(url).then(res => {\n        console.log(res)\n\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  div {\n    padding: 10px;\n    border-bottom: 1px dashed gray;\n  }\n}\n</style>\n\n```\n\n\n\n\n\n ```html\n<template>\n  <div>\n    <!-- https://api.xin88.top/youku/footer.json -->\n    <!-- 1. 引入axios模块 -->\n    <!-- 2. 在methods选项中, 制作一个 getData 方法, 绑定在按钮点击事件 -->\n    <!-- 3. getData中书写 axios 请求, 点击后后台查看数据 -->\n    <!-- 4. data选项中, 制作 data属性, 把请求到的数据保存到这里 -->\n    <!-- 5. 页面上用 div 配合 v-if 判断data存在, 在进行数据的使用 -->\n    <!-- 6. 利用 div + v-for 完成数据的展示, 添加css -->\n    <button @click=\"getData\">获取数据</button>\n\n    <div v-if=\"data\">\n      <h3>关于我们</h3>\n      <a v-for=\"x in data.footer.aboutUs.data\" :key=\"x.id\" :href=\"x.url\">\n        {{ x.name }}\n      </a>\n\n      <h3>协议声明</h3>\n      <a v-for=\"x in data.footer.userAgreement.data\" :key=\"x.id\" :href=\"x.url\">\n        {{ x.name }}\n      </a>\n\n      <h3>服务合作</h3>\n      <a v-for=\"x in data.footer.newService.data\" :href=\"x.url\" :key=\"x.id\">\n        {{ x.name }}\n      </a>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  data() {\n    return {\n      data: null,\n    }\n  },\n\n  methods: {\n    getData() {\n      const url = \'https://api.xin88.top/youku/footer.json\'\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\na {\n  color: #333;\n  text-decoration: none;\n  margin: 4px;\n}\n</style>\n\n ```\n\n\n\n```html\n<template>\n  <div>\n    <!-- https://api.xin88.top/douban/movies.json -->\n    <!-- 此接口中的图片带有防盗功能,需要在index.html中解除防盗 -->\n    <button @click=\"getData\">获取数据</button>\n\n    <div v-if=\"data\" class=\"box\">\n      <!-- 支持解构语法 -->\n      <div\n        v-for=\"{ cover, id, is_new, rate, title } in data.subjects\"\n        :key=\"id\"\n      >\n        <img :src=\"cover\" alt=\"\" />\n        <div>\n          <span class=\"xin\" v-if=\"is_new\">新</span>\n          <span>{{ title }}</span>\n          <span>{{ rate }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  // 钩子函数: 一类特殊功能的函数, 会在特殊的时间自动被触发\n  mounted() {\n    // 当DOM元素显示到页面上时, 自动触发\n    console.log(\'mounted: 被安装到页面上\')\n    // 当前 .vue 文件创建完成后 显示到页面上后, 立刻自动触发获取数据\n    this.getData()\n  },\n\n  data() {\n    return {\n      data: null,\n    }\n  },\n\n  methods: {\n    getData() {\n      const url = \'https://api.xin88.top/douban/movies.json\'\n\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  display: flex;\n  flex-wrap: wrap;\n\n  > div {\n    display: flex;\n    flex-direction: column;\n    margin: 0 10px 10px 0;\n    width: 170px;\n\n    > img {\n      width: 100%;\n    }\n\n    > div {\n      display: flex;\n      justify-content: center;\n      margin-top: 5px;\n\n      > .xin {\n        background-color: #66c559;\n        padding: 0 2px;\n        color: white;\n      }\n      > span:last-child {\n        color: goldenrod;\n      }\n    }\n  }\n}\n</style>\n\n```\n\n\n\n```html\n<template>\n  <div>\n    <!-- https://api.xin88.top/game/items.json -->\n    <div v-if=\"data\" class=\"box\">\n      <div\n        v-for=\"{ name, price, itemId, iconPath } in data.items\"\n        :key=\"itemId\"\n      >\n        <img :src=\"iconPath\" alt=\"\" />\n        <span>{{ name }}</span>\n        <span>{{ price }}</span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  // 存本地\n  data() {\n    return {\n      data: null,\n    }\n  },\n\n  // 自动触发\n  mounted() {\n    this.getData()\n  },\n\n  // 发请求\n  methods: {\n    getData() {\n      const url = \'https://api.xin88.top/game/items.json\'\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  display: flex;\n  flex-wrap: wrap;\n  padding: 20px;\n  background-color: #1e2128;\n\n  > div {\n    display: flex;\n    flex-direction: column;\n    background-color: #14151a;\n    margin: 0 10px 10px 0;\n    border: 1px solid #777;\n    padding: 20px;\n    align-items: center;\n    color: white;\n\n    > img {\n      width: 100px;\n      height: 100px;\n    }\n\n    > span:nth-child(2) {\n      margin: 10px 0;\n      width: 100px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n      text-align: center;\n    }\n\n    > span:last-child {\n      color: #ab965d;\n    }\n  }\n}\n</style>\n\n```\n\n\n\n```html\n<template>\n  <div>\n    <!-- https://api.xin88.top/bilibili/recommend.json -->\n\n    <div v-if=\"data\" class=\"box\">\n      <div\n        v-for=\"{\n          title,\n          season_id,\n          new_ep: { cover, index_show },\n          stat: { danmaku, view },\n        } in data.data.season\"\n        :key=\"season_id\"\n      >\n        <img :src=\"cover\" alt=\"\" />\n        <div>\n          <span>{{ title }}</span>\n          <div>\n            <span>{{ index_show }}</span>\n            <!-- 过滤器: {{ 值 | 过滤器 }} 自动把值改成别的样子 -->\n            <span>{{ view | wan }}次播放 · {{ danmaku | wan }}弹幕</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  // {{ danmaku | wan }} : 此语法会触发过滤器\n  // 过滤器选项\n  filters: {\n    wan(value) {\n      if (value >= 10000) {\n        value = (value / 10000).toFixed(1) + \'万\'\n      }\n      return value\n    },\n  },\n\n  data() {\n    return {\n      data: null,\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  methods: {\n    getData() {\n      const url = \'https://api.xin88.top/bilibili/recommend.json\'\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  width: 400px;\n\n  > div {\n    display: flex;\n    margin-bottom: 10px;\n\n    > img {\n      width: 130px;\n      height: 80px;\n    }\n\n    > div {\n      margin-left: 10px;\n      display: flex;\n      flex-direction: column;\n      justify-content: space-between;\n\n      > div {\n        display: flex;\n        flex-direction: column;\n        color: #777;\n        font-size: 0.8em;\n      }\n    }\n  }\n}\n</style>\n\n```\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"axios\",\"vue\"]', 0, 0),
(20, 'Vue基础04', '过滤器、自定义组件、插槽、props属性、生命周期、监听器、', '# Vue04\n\n> 提前准备好项目包 并 启动\n\n## 复习\n\n- v-for 与 class 的联动\n\n  ```js\n  <li \n  v-for=\"(value, index) in 数组\"  \n  @click=\"now=i\"  \n  :class=\"{active: now == i}\"> \n  ```\n\n- 自定义指令: 用户可以制作自己的指令\n\n  - 指令以 `v-` 开头\n\n  - 书写在 `directives` 配置项中\n\n  - 高级用法\n\n    inserted: 指令所在的元素 显示到页面上之后 再触发\n\n    ```js\n    directives:{\n        指令名:{\n            inserted(el, bindings){}\n        }\n    }\n    ```\n\n- v-if 指令\n\n  - 根据条件的真假, 来决定是否加载对应的DOM元素\n  - `适用于`: 网络请求得到数据之后, 再加载DOM元素的场景\n\n- axios: 利用 `promise` 封装而来的 第三方网络请求模块\n\n  - 使用前需要安装: `npm i axios vue-axios`\n\n  - 使用时:\n\n    先引入: `import axios from \'axios\'`\n\n    发请求: `axios.get(接口地址).then(res=>{})`\n\n- 组件生命周期\n\n  - mounted: `.vue`文件显示到页面上之后, 自动触发\n\n- 过滤器 \n\n  - `{{ 值 | 过滤器 }}`: 通过过滤器把值进行修改\n\n## 过滤器\n\n```html\n<template>\n  <div>\n    <!-- 过滤器: 把{{}}中的值进行处理, 返回新的值 -->\n\n    <!-- abs: 绝对值 -->\n    <div>{{ 9 | abs }}</div>\n    <div>{{ -9 | abs }}</div>\n    <div>{{ 9 | sqrt }}</div>\n    <!-- 双倍 -->\n    <div>{{ 9 | double }}</div>\n    <!-- 求次幂 -->\n    <div>{{ 2 | pow(2) }}</div>\n    <div>{{ 2 | pow(10) }}</div>\n\n    <!-- 过滤器可以顺序使用 -->\n    <div>{{ -2 | abs | double | pow(5) }}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // filters： 用于存放过滤器， 配合 {{ value | 过滤器 }} 语法\n  filters: {\n    // {{ x | pow(y) }}\n    pow(x, y) {\n      return Math.pow(x, y)\n    },\n    double(value) {\n      return value * 2\n    },\n    // {{ value | abs}}\n    abs(value) {\n      return value > 0 ? value : -value\n    },\n    sqrt(value) {\n      return Math.sqrt(value)\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n练习\n\n```html\n<template>\n  <div>\n    <table>\n      <thead>\n        <tr>\n          <td>姓名</td>\n          <td>年龄</td>\n          <td>婚姻</td>\n          <td>手机号</td>\n          <td>学历</td>\n        </tr>\n      </thead>\n      <tbody>\n        <tr\n          v-for=\"{\n            ename,\n            eid,\n            married,\n            phone,\n            age,\n            edu,\n          } in emps\"\n          :key=\"eid\"\n        >\n          <td>{{ ename }}</td>\n          <td>{{ age }}</td>\n          <td>{{ married | marry }}</td>\n          <td>{{ phone | ph }}</td>\n          <td>{{ edu | edu_name }}</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script>\nexport default {\n  filters: {\n    edu_name(value) {\n      // 通过序号 从数组里取值\n      // 数组[序号]\n      // 选项通常存数字, 就是为了配合数组使用\n      return [\'文盲\', \'小学\', \'中学\', \'大学\', \'研究生\'][value]\n    },\n    marry(value) {\n      return value ? \'已婚\' : \'未婚\'\n    },\n    ph(value) {\n      const reg = /^(\\d{3})(\\d{4})(\\d{4})$/\n      //               1      2      3\n      return value.replace(reg, \'$1****$3\')\n    },\n  },\n\n  data() {\n    return {\n      emps: [\n        {\n          eid: 1,\n          ename: \'泡泡1\',\n          age: 23,\n          married: true,\n          phone: \'18833445555\',\n          edu: 0, //学历\n        },\n        {\n          edu: 1,\n          eid: 2,\n          ename: \'泡泡2\',\n          age: 18,\n          married: false,\n          phone: \'18878985555\',\n        },\n        {\n          edu: 2,\n          eid: 3,\n          ename: \'泡泡3\',\n          age: 30,\n          married: false,\n          phone: \'18833445555\',\n        },\n        {\n          edu: 3,\n          eid: 4,\n          ename: \'泡泡4\',\n          age: 34,\n          married: true,\n          phone: \'18833454555\',\n        },\n        {\n          edu: 4,\n          eid: 5,\n          ename: \'泡泡5\',\n          age: 43,\n          married: true,\n          phone: \'18889745555\',\n        },\n      ],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\ntable {\n  border-collapse: collapse;\n}\nthead {\n  background-color: #eee;\n}\ntd {\n  border: 1px solid gray;\n  padding: 10px 20px;\n}\n</style>\n\n```\n\n## 组件\n\n```html\n<template>\n  <div>\n    <!-- 组件: component -->\n    <!-- 组成页面的零件 -->\n    <!-- 系统组件: div span h1 hr img... -->\n    <!-- 自定义组件: 利用系统组件组合出自己的组件, 可以复用 -->\n    <!-- components: 此目录专门用于存放自定义组件 -->\n\n    <!-- 作者满足所有人的习惯, 提供多种用法 -->\n    <my-nav></my-nav>\n    <my-nav />\n\n    <!-- 小众: 使用较少 -->\n    <MyNav></MyNav>\n    <MyNav />\n\n    <!-- 别名 -->\n    <mynav />\n    <mynav></mynav>\n  </div>\n</template>\n\n<script>\n// 使用自定义组件: 先引入 再使用\n// 注意:  路由带 波浪线\n// 1.路径错误 - 检查目录中的名字\n// 2.vscode卡了 - 重启\nimport MyNav from \'./components/MyNav.vue\' //引入\n\nexport default {\n  // 外来的组件: 注册到 组件选项中\n  // 别名写法:  {别名: 组件名}\n  components: { MyNav, mynav: MyNav },\n  // 默认大驼峰 会自动兼容 破折号语法  my-nav 和 MyNav\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\nmynav\n\n```html\n<template>\n  <!-- 自定义组件的名称: 至少两个单词; 依赖大驼峰命名法区分单词 -->\n  <!-- 大驼峰: XiAn  每个单词首字母大写 -->\n  <!-- 因为: 系统组件/标签 都是1个单词; 自定义的组件为了区分, 所以要求至少两个单词 -->\n\n  <!--(非强制): 根组件的class 和标签名相同, 但是class应该全小写\n  用 - 破折号分割 -->\n  <div class=\"my-nav\">\n    <ul>\n      <li\n        v-for=\"(item, i) in items\"\n        :key=\"i\"\n        @click=\"now = i\"\n        :class=\"{ active: now == i }\"\n      >\n        {{ item }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 为什么data是函数?\n  // 因为 组件需要复用, 每次使用会触发data函数生成 独立的作用域, 这里的变量 是独立的, 不会互相影响\n  data() {\n    return {\n      now: 0,\n      items: [\n        \'首页\',\n        \'关于净美仕\',\n        \'公司动态\',\n        \'产品中心\',\n        \'联系我们\',\n      ],\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\nul,\nli {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\n\nul {\n  display: flex;\n  background-color: #002c69;\n\n  li {\n    user-select: none;\n    cursor: pointer;\n    color: white;\n    padding: 10px 25px;\n\n    &.active {\n      background-color: orange;\n    }\n  }\n}\n</style>\n\n```\n\n## 组件属性和插槽\n\n插槽\n\n```html\n<template>\n  <div>\n    <!-- 1. 制作一个 MyBtn 组件 -->\n    <!-- 2. 结构 -->\n    <!-- 3. 样式 -->\n    <!-- 4. 引入 注册 使用-->\n    <!-- <my-btn /> -->\n    <!-- <my-btn /> -->\n\n    <!-- 插槽: slot 预留位 -->\n    <my-btn>登录</my-btn>\n    <my-btn>注册</my-btn>\n\n    <button>登录</button>\n    <button>注册</button>\n\n    <hr />\n    <my-tag>阿斌相亲记</my-tag>\n    <my-tag>单身汉</my-tag>\n    <my-tag>重生之我在学WEB</my-tag>\n  </div>\n</template>\n\n<script>\nimport MyBtn from \'./components/MyBtn.vue\'\nimport MyTag from \'./components/MyTag.vue\'\nexport default {\n  components: { MyBtn, MyTag },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n属性\n\n```html\n<template>\n  <div>\n    <!-- 组件属性 -->\n    <!-- 标签拥有两类重要的设置 -->\n    <!-- 1. 双标签的值 -->\n    <!-- 2. 属性: 各种各样的其他设定 -->\n    <button id=\"b1\" disabled class=\"xxx\">注册</button>\n\n    <!-- 期望: -->\n    <my-alert type=\"success\" sui=\"09.19\" bian=\"!!!\"\n      >阿斌今天迟到了!</my-alert\n    >\n    <!-- 带: 是vue语法, 值为JS代码 -->\n    <!-- 不带: 是html语法, 值是字符串 -->\n    <my-alert type=\"warning\" :sui=\"8 + 8\" bian=\"8+8\"\n      >阿斌今天迟到了!</my-alert\n    >\n\n    <my-alert type=\"error\">阿斌?</my-alert>\n    <my-alert type=\"info\">阿斌?</my-alert>\n  </div>\n</template>\n\n<script>\nimport MyAlert from \'./components/MyAlert.vue\'\nexport default {\n  components: { MyAlert },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n属性\n\n```html\n<template>\n  <div>\n    <!-- 如果属性没有传参,可以设置默认值 -->\n    <my-btn>默认按钮</my-btn>\n    <my-btn type=\"primary\">主要按钮</my-btn>\n    <my-btn type=\"success\">成功按钮</my-btn>\n    <my-btn type=\"info\">信息按钮</my-btn>\n    <my-btn type=\"warning\">警告按钮</my-btn>\n    <my-btn type=\"danger\">危险按钮</my-btn>\n  </div>\n</template>\n\n<script>\nimport MyBtn from \'./components/MyBtn.vue\'\nexport default {\n  components: { MyBtn },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n练习\n\n```html\n<template>\n  <div>\n    <my-tag>标签一</my-tag>\n    <my-tag bin=\"success\">标签二</my-tag>\n    <my-tag bin=\"info\">标签三</my-tag>\n    <my-tag bin=\"danger\">标签四</my-tag>\n    <my-tag bin=\"warning\">标签五</my-tag>\n  </div>\n</template>\n\n<script>\nimport MyTag from \'./components/MyTag.vue\'\nexport default {\n  components: { MyTag },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n组件们\n\n```html\n<template>\n  <div :class=\"`my-btn ${type}`\">\n    <span>\n      <!-- slot:插槽组件, 虚拟的占位符 -->\n      <!-- 会在组件使用时, 替换成其双标签中的内容 -->\n      <slot />\n    </span>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 简单语法:\n  // props: [\'type\'],\n  // 精确配置语法:\n  props: {\n    // 属性名: {配置项}\n    type: {\n      // ctrl+i: 查看配置项\n      default: \'default\',\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.my-btn {\n  display: inline-block;\n  // background-color: #409eff;\n  color: white;\n  border-radius: 4px;\n  padding: 10px 20px;\n  user-select: none;\n  cursor: pointer;\n  margin: 2px;\n\n  // 默认样式\n  &.default {\n    color: #333;\n    border: 1px solid #888;\n  }\n\n  &.primary {\n    background-color: #409eff;\n  }\n  &.success {\n    background-color: #67c23a;\n  }\n  &.info {\n    background-color: #909399;\n  }\n  &.warning {\n    background-color: #e6a23c;\n  }\n  &.danger {\n    background-color: #f56c6c;\n  }\n\n  opacity: 0.9;\n\n  &:hover {\n    // background-color: #66b1ff;\n    opacity: 0.7;\n  }\n\n  &:active {\n    // background-color: #3a8ee6;\n    opacity: 1;\n  }\n}\n</style>\n\n```\n\n\n\n```html\n<template>\n  <div :class=\"`my-alert ${type}`\">\n    <span>\n      <slot />\n    </span>\n    <div>sui: {{ sui }}</div>\n    <div>bian: {{ bian }}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // props: 属性选项, 用于为自定义组件 声明 属性\n  props: [\'sui\', \'bian\', \'type\'],\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.my-alert {\n  color: white;\n  padding: 10px 20px;\n  margin: 2px 0;\n  border-radius: 4px;\n\n  &.success {\n    background-color: #67c23a;\n  }\n\n  &.info {\n    background-color: #909399;\n  }\n\n  &.warning {\n    background-color: #e6a23c;\n  }\n\n  &.error {\n    background-color: #f56c6c;\n  }\n}\n</style>\n\n```\n\n```html\n<template>\n  <div :class=\"`my-tag ${bin}`\">\n    <!-- 插槽: 一个占位符; 使用时才会替换成实际的值 -->\n    <slot />\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    bin: {\n      default: \'default\',\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.my-tag {\n  display: inline-block;\n  margin: 2px;\n  border-radius: 4px;\n  // color: #67c23a;\n  // background-color: #f0f9eb;\n  // border: 1px solid #e1f3d8;\n  padding: 8px 10px;\n  color: white;\n\n  &.default {\n    background-color: #409eff;\n  }\n  &.success {\n    background-color: #67c23a;\n  }\n  &.info {\n    background-color: #909399;\n  }\n  &.danger {\n    background-color: #f56c6c;\n  }\n  &.warning {\n    background-color: #e6a23c;\n  }\n}\n</style>\n\n```\n\n\n\n## props组件属性\n\n<img src=\"assets/image-20220919144339221.png\" alt=\"image-20220919144339221\" style=\"zoom: 80%;\" />\n\n\n\n## 插槽\n\n```html\n<template>\n  <div>\n    <!-- 插槽: slot -->\n    <!-- 1. 默认插槽  2. 命名插槽 -->\n    <!-- 插槽: 提前把布局写完, 使用时再存入具体展示的内容 -->\n    <my-slot>\n      <!-- 自定义组件, 双标签写法中的内容 会替换掉默认插槽 -->\n      <a href=\"\">新闻</a>\n      <a href=\"\">地图</a>\n      <a href=\"\">视频</a>\n      <a href=\"\">hao123</a>\n\n      <!-- 放到名字是 suibian 的插槽里 -->\n      <ul slot=\"suibian\">\n        <li>阿斌</li>\n        <li>洋洋</li>\n        <li>元浩</li>\n      </ul>\n\n      <!-- vue2.6版本中, 更新了新的语法 -->\n      <!-- 必须用虚拟的template 标签作为父元素, 此标签不是实际存在的DOM元素, 仅仅代表一个包围 -->\n      <!-- <template v-slot:right>\n        <li>泡泡</li>\n        <li>铭铭</li>\n        <li>亮亮</li>\n      </template> -->\n\n      <!-- 新语法有语法糖: #插槽名 -->\n      <template #right>\n        <li>泡泡</li>\n        <li>铭铭</li>\n        <li>亮亮</li>\n      </template>\n    </my-slot>\n  </div>\n</template>\n\n<script>\nimport MySlot from \'./components/MySlot.vue\'\nexport default {\n  components: { MySlot },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n```html\n<template>\n  <div class=\"my-slot\">\n    <div class=\"header\">\n      <!-- 默认插槽 -->\n      <slot />\n    </div>\n    <div class=\"main\">\n      <div class=\"left\">\n        <!-- 命名插槽: 通过name属性 为 slot 组件添加名字 -->\n        <slot name=\"suibian\" />\n      </div>\n      <div class=\"right\">\n        <slot name=\"right\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style lang=\"scss\" scoped>\na {\n  font-size: 20px;\n  color: white;\n}\n\n.header {\n  background-color: orange;\n  height: 100px;\n}\n.main {\n  display: flex;\n\n  .left {\n    height: 400px;\n    width: 200px;\n    background-color: red;\n  }\n  .right {\n    background-color: blue;\n    height: 400px;\n    // flex: 主轴方向 占据剩余大小\n    flex: 1;\n  }\n}\n</style>\n\n```\n\n\n\n## 生命周期\n\n```html\n<template>\n  <div>\n    <!-- 组件生命周期: 标签从创建到显示 等过程中, 经历的周期 -->\n    <button @click=\"isShow = true\">添加</button>\n    <button @click=\"isShow = false\">删除</button>\n    <hello-world v-if=\"isShow\" />\n  </div>\n</template>\n\n<script>\nimport HelloWorld from \'./components/HelloWorld.vue\'\nexport default {\n  components: { HelloWorld },\n  data() {\n    return {\n      isShow: false, //是否显示\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n```html\n<template>\n  <div>\n    <h1>Hello World!</h1>\n    <button @click=\"num++\">{{ num }}</button>\n  </div>\n</template>\n\n<script>\n// 生命周期的作用:\n\n// 1. 自动发送网络请求?\n// 在组件显示时, mounted中触发请求操作\n\n// 2. 面试问题: 是否可以在创建阶段发送请求?\n// creatd阶段: 能提前几毫秒, 但是一旦小概率挂载到页面上失败, 则请求属于浪费流量\n// mounted: 晚几毫秒(用户不可感知), 请求的数据一定用的上,更稳妥\n\n// 3. 除了 mounted 发请求, 其他周期有什么用?\n// 面试用 -- 生命周期属于常识性问题, 必须要掌握\n\nexport default {\n  data() {\n    return {\n      num: 1,\n    }\n  },\n\n  // 生命周期的钩子函数\n  // 生命周期: 组件从 创建 出生 更新 销毁的过程--组件的一生\n  // 钩子函数: 一类特殊的函数 -- 在固定的时机自动触发\n  // https://v2.cn.vuejs.org/v2/api/\n\n  // 创建阶段: 完成 选项中数据部分的 操作\n  beforeCreate() {\n    // before: 在...之前\n    console.log(\'beforeCreate: 即将创建组件\')\n  },\n  created() {\n    console.log(\'created: 组件创建完毕\')\n  },\n  // 组件出生, 显示到页面上\n  beforeMount() {\n    console.log(\'beforeMount: 即将挂载到页面展示\')\n  },\n  mounted() {\n    console.log(\'mounted: 已经展示到页面\')\n  },\n  // 更新时\n  beforeUpdate() {\n    console.log(\'beforeUpdate: 数据修改 但页面还未更新\')\n  },\n  updated() {\n    console.log(\'updated: 数据修改 页面完成更新\')\n  },\n\n  // 删除组件中的所有数据\n  beforeDestroy() {\n    console.log(\'beforeDestroy: 即将销毁\')\n  },\n  destroyed() {\n    console.log(\'destroyed: 销毁完毕\')\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n## 监听器\n\n```html\n<template>\n  <div>\n    <!-- 监听器: 实时监听属性的变化 -->\n    <button @click=\"num++\">{{ num }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      num: 1,\n    }\n  },\n  // 监听器\n  watch: {\n    // 要监听的属性名: 变化时触发的函数\n    // num: function (to, from) {}\n    num(to, from) {\n      console.log(\'to:\', to) //新值\n      console.log(\'from:\', from) //旧值\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 新闻\n\n```html\n<template>\n  <div>\n    <!-- https://web.codeboy.com/mfresh/data/news_select.php?pageNum=1 -->\n    <!-- 1. methods中 getData方法, 用axios 请求接口中的数据, 打印查看 -->\n    <!-- 2. 在mounted中, 触发getData方法 -->\n    <!-- 3. 在data中声明 data属性, 存储请求到的数据 -->\n    <!-- 4. 把 data中的数据展示出来, 注意: v-if 判断 -->\n    <div v-if=\"data\" class=\"box\">\n      <div\n        v-for=\"{ nid, pubTime, title } in data.data\"\n        :key=\"nid\"\n      >\n        <span>{{ title }}</span>\n        <span>{{ pubTime | date }}</span>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n// 前提: 需要安装axios模块  npm i axios\nimport axios from \'axios\'\n\nexport default {\n  filters: {\n    date(value) {\n      // value是字符串类型 *1 变为数字\n      // Date(): 参数是数字类型 才会当做是 时间戳进行处理\n      const d = new Date(value * 1)\n      let year = d.getFullYear()\n      let month = d.getMonth() + 1\n      if (month < 10) month = \'0\' + month\n\n      let day = d.getDate()\n      if (day < 10) day = \'0\' + day\n\n      return `${year}-${month}-${day}`\n    },\n  },\n\n  data() {\n    return {\n      data: null,\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  methods: {\n    getData() {\n      const url = `https://web.codeboy.com/mfresh/data/news_select.php?pageNum=1`\n\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  width: 700px;\n  div {\n    padding: 10px;\n    display: flex;\n    justify-content: space-between;\n    border-bottom: 1px dashed gray;\n  }\n}\n</style>\n\n```\n\n\n\n## 作业\n\n作业1: 选做: 完成分页操作\n\n- v-for遍历返回值中的 `pageCount`属性来生成页数\n- 制作 now 属性, 保存当前激活页, 完成页数激活状态的切换效果\n- 监听页数 now 的变化, 触发getData方法, 在 url 中 修改pageNum的值为 now;  实现指定页数数据的获取\n\n![image-20220919180536762](assets/image-20220919180536762.png)\n\n\n\n作业2: 自定义 my-link 组件\n\n![image-20220919180950629](assets/image-20220919180950629.png)\n\n效果参考: https://element.eleme.io/#/zh-CN/component/link\n\n- 组件中是 a 标签\n- 颜色值 参考今天的代码\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\"]', 0, 0),
(21, 'Vue基础05', '分页展示、自定义组件、路由、路由传参、路由配置、懒加载、编程式跳转、声明式跳转、', '# Vue05\n\n## 复习\n\n过滤器: filters\n\n- 在`{{}}`中使用的语法  `{{ 值 | 过滤器(参数, 参数) }}`\n\n  ```js\n  filters:{\n      过滤器名(值, 参数, 参数){\n          return ...\n      }\n  }\n  ```\n\n`组件`: 自定义组件\n\n- 组件: 组成页面的零件\n- 分两类\n  - 系统组件: 所有html标签都可以认为是系统组件 - div span h1 ~ h6  im	g...\n  - 自定义组件: 利用系统组件组合出自定义的组件, 标签, 元素\n- `components`: 自定义组件存储在这里\n  - 组件名:大驼峰 至少两个单词  为了与 系统标签名 区分\n  - 非强制: 根组件的class 是 组件名的 破折号语法  `my-nav`\n- 使用组件时: `先引入`  然后 `注册到 components选项` 最后 `使用`\n- 关于组件传参\n  - 插槽: slot\n    - 在组件中书写插槽占位符  默认插槽:`<slot />` 和 命名插槽 `<slot name=\"\"/>`\n    - 使用时, 组件的双标签语法 中的 标签内容, 会替换掉默认插槽\n    - 命名插槽语法\n      - vue2.6前: `<元素 slot=\"插槽名\" />`\n      - vue2.6后: `<template v-slot:插槽名>`\n        - 语法糖 `#`  `<template #插槽名>`\n  - 属性: props\n    - `<标签 属性名=值 >`\n    - 简单语法: `props:[\'属性名\']`\n    - 精确配置语法 : `props: { 属性名 : { 配置项 } }`\n      - 配置项 default: 默认值\n      - 配置项 type: 类型\n      - 配置项 required: 是否为必填项\n      - 配置项 validate: 验证值的格式\n\n- 生命周期\n  - 数据创建阶段  - 负责 data methods computed watch....的创建\n    - beforeCreate\n    - created\n  - 显示到页面阶段 - 组件显示在页面上, 用户可见\n    - beforeMount\n    - mounted  -- `在这里自动触发网络请求`\n  - 更新页面阶段 - 数据变化 导致 页面刷新\n    - beforeUpdate\n    - updated\n  - 销毁数据阶段 - 数据释放\n    - beforeDestroy\n    - destroyed\n\nwatch: 监听器\n\n- 监听任意属性的变化\n\n\n\n## 分页练习\n\n```html\n<template>\n  <div>\n    <!-- https://web.codeboy.com/mfresh/data/news_select.php?pageNum=1 -->\n    <!-- 1. methods中 getData方法, 用axios 请求接口中的数据, 打印查看 -->\n    <!-- 2. 在mounted中, 触发getData方法 -->\n    <!-- 3. 在data中声明 data属性, 存储请求到的数据 -->\n    <!-- 4. 把 data中的数据展示出来, 注意: v-if 判断 -->\n\n    <!-- 多个兄弟标签都采用了 v-if, 可以提取到外部 -->\n    <!-- 新增一个div作为父元素, 会影响DOM的层级, 有可能影响到css的布局 -->\n    <!-- template: 虚拟的容器, 不是真正的DOM元素. 主要配合 v-if 或 v-for 使用 -->\n    <template v-if=\"data\">\n      <div class=\"box\">\n        <div\n          v-for=\"{ nid, pubTime, title } in data.data\"\n          :key=\"nid\"\n        >\n          <span>{{ title }}</span>\n          <span>{{ pubTime | date }}</span>\n        </div>\n      </div>\n\n      <div class=\"pages\">\n        <span v-show=\"now != 1\" @click=\"now--\">上一页</span>\n        <span\n          :class=\"{ active: now == p }\"\n          @click=\"now = p\"\n          v-for=\"p in data.pageCount\"\n          :key=\"p\"\n          >{{ p }}</span\n        >\n        <span @click=\"now++\" v-show=\"now != data.pageCount\"\n          >下一页</span\n        >\n      </div>\n    </template>\n  </div>\n</template>\n\n<script>\n// 前提: 需要安装axios模块  npm i axios\nimport axios from \'axios\'\n\nexport default {\n  filters: {\n    date(value) {\n      // value是字符串类型 *1 变为数字\n      // Date(): 参数是数字类型 才会当做是 时间戳进行处理\n      const d = new Date(value * 1)\n      let year = d.getFullYear()\n      let month = d.getMonth() + 1\n      if (month < 10) month = \'0\' + month\n\n      let day = d.getDate()\n      if (day < 10) day = \'0\' + day\n\n      return `${year}-${month}-${day}`\n    },\n  },\n\n  data() {\n    return {\n      data: null,\n      now: 1, //当前页\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  // 监听器: now变化时, 重新请求数据\n  watch: {\n    now() {\n      this.getData()\n    },\n  },\n\n  methods: {\n    getData() {\n      const url = `https://web.codeboy.com/mfresh/data/news_select.php?pageNum=${this.now}`\n\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  width: 700px;\n  div {\n    padding: 10px;\n    display: flex;\n    justify-content: space-between;\n    border-bottom: 1px dashed gray;\n  }\n}\n\n.pages {\n  display: flex;\n  > span {\n    padding: 10px 10px;\n    background-color: #aaa;\n    user-select: none;\n    cursor: pointer;\n    margin: 3px;\n    border-radius: 3px;\n    color: #333;\n\n    &.active {\n      background-color: orange;\n      color: white;\n    }\n  }\n}\n</style>\n\n```\n\n\n\n分页练习\n\n```html\n<template>\n  <div>\n    <!-- \n      https://web.codeboy.com/xuezi/data/product/list.php?pno=1 \n      返回值中的图片仅仅是相对路径\n      需要人为拼接前缀域名 https://web.codeboy.com/xuezi/\n    -->\n\n    <template v-if=\"data\">\n      <div class=\"box\">\n        <div\n          v-for=\"{ lid, title, price, pic } in data.data\"\n          :key=\"lid\"\n        >\n          <img\n            :src=\"\'https://web.codeboy.com/xuezi/\' + pic\"\n            alt=\"\"\n          />\n          <div>\n            <span>{{ title }}</span>\n            <span>¥{{ price }}</span>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"pages\">\n        <span @click=\"now--\" :class=\"{ disabled: now == 1 }\"\n          >上一页</span\n        >\n        <span\n          :class=\"{ active: now == p }\"\n          @click=\"now = p\"\n          v-for=\"p in data.pageCount\"\n          :key=\"p\"\n          >{{ p }}</span\n        >\n        <span\n          @click=\"now++\"\n          :class=\"{ disabled: now == data.pageCount }\"\n          >下一页</span\n        >\n      </div>\n    </template>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  data() {\n    return {\n      data: null,\n      now: 1,\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  watch: {\n    now() {\n      this.getData()\n    },\n  },\n  methods: {\n    getData() {\n      const url = `https://web.codeboy.com/xuezi/data/product/list.php?pno=${this.now}`\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.box {\n  width: 800px;\n\n  > div {\n    display: inline-flex;\n    flex-direction: column;\n    width: 250px;\n    border: 1px solid #aaa;\n    margin: 0 10px 10px 0;\n\n    > img {\n      width: 100%;\n    }\n\n    > div {\n      display: flex;\n      padding: 10px;\n      flex-direction: column;\n\n      > span:last-child {\n        color: red;\n        font-size: 1.2em;\n      }\n    }\n  }\n}\n\n.pages {\n  display: flex;\n\n  > span {\n    padding: 5px 10px;\n    border: 1px solid gray;\n    color: gray;\n    margin: 3px;\n    user-select: none;\n    cursor: pointer;\n\n    &.active {\n      background-color: #19a9f1;\n      color: white;\n      border-color: #19a9f1;\n    }\n    &.disabled {\n      // 不可用: 删除所有的鼠标事件\n      pointer-events: none;\n      color: #bbb;\n      border-color: #bbb;\n    }\n  }\n}\n</style>\n\n```\n\n\n\n## 自定义组件\n\n```html\n<template>\n  <div>\n    <!-- 作业: 自定义组件 my-link  代表 原生组件 a -->\n    <my-link\n      type=\"primary\"\n      href=\"http://www.baidu.com\"\n      target=\"_blank\"\n      >百度一下</my-link\n    >\n\n    <my-link type=\"warning\">Tmooc</my-link>\n  </div>\n</template>\n\n<script>\nimport MyLink from \'./components/MyLink.vue\'\nexport default {\n  components: { MyLink },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 路由系统\n\n多页项目的制作: 一个大型网站需要由多个页面组成\n\n做法分两种:\n\n- 传统方案: 每个网页是一个`html`文件, 通过超链接的href 来实现页面跳转\n  - 特点: 先清空之前的页面, 然后显示新的页面 -- 页面有闪烁的感觉\n- 新方案: Ajax  局部切换\n  - 特点: 不需要清空整个页面, 只需要把局部内容删除 换成新的即可\n\n新方案的专业名词: `SPA` - Single Page Application  单个页面应用\n\n- 整个网站只有一个 html 页面,  利用局部内容切换来实现多页效果\n\n这套方案依赖一款框架: Vue Router :https://router.vuejs.org/zh/\n\n\n\n## 路由流程\n\n![image-20220920115823193](assets/image-20220920115823193.png)\n\n\n\n![image-20220920120043080](assets/image-20220920120043080.png)\n\n> 举例\n>\n> 1. 先宾参加相亲会, 需要先登记, 获取一个编号, 例如 1003\n> 2. 某某某 到相亲会 -> 和 编号1003 相亲\n> 3. 根据编号找到 对应的 人....\n\n\n\n## 懒加载和非懒加载的差异\n\n> 首页优化: 如何提高首次加载网页时的效率?\n>\n> - 把`非常用`页面做成懒加载的 -- 首次加载时不加载, 使用时临时加载\n> - 把`常用`的页面做成非懒加载的 -- 首次加载时直接加载, 后续可以直接使用 提高体验\n\n![image-20220920144540050](assets/image-20220920144540050.png)\n\n\n\n## 路由系统\n\n```html\n<template>\n  <div>\n    <!-- 路由占位符: 在实际显示时,会切换成对应的组件 -->\n    <!-- \n      自定义组件分两种:\n      1. 组成页面的一部分, 目的是复用: 按钮;标签;超链接;\n           -- 存储在 components 中\n      2. 组成页面的一部分, 目的是整体切换: 路由系统切换的页面\n           -- 存储在 views 中\n     -->\n\n    <!-- 导航栏 -->\n    <div id=\"nav\">\n      <!-- 同之前制作的 my-link 组件, 把超链接a标签做了封装 -->\n      <router-link to=\"/\">首页</router-link>\n      <router-link to=\"/about\">关于</router-link>\n      <router-link to=\"/news\">新闻</router-link>\n      <router-link to=\"/bin\">阿斌</router-link>\n      <router-link to=\"/login\">登录</router-link>\n    </div>\n\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style lang=\"scss\" scoped>\n// router-link 本质是a 标签, 给 a 加样式即可\na {\n  text-decoration: none;\n  display: inline-block;\n  color: #333;\n  margin: 3px;\n  padding: 10px 20px;\n  background-color: #aaa;\n\n  // router-link 会根据路径 自动添加激活状态\n  // 给了两种激活状态\n  // 模糊匹配: router-link-active\n  // 精确匹配: router-link-exact-active\n\n  // 模糊:  路径中只要存在就高亮\n  // 例如 /about  匹配到  / 和 /about;  /news 匹配 / 和 /news\n  &.router-link-active {\n    background-color: orange;\n    color: white;\n  }\n\n  // &.router-link-exact-active {\n  //   background-color: orange;\n  //   color: white;\n  // }\n}\n</style>\n\n```\n\n## 编程式跳转\n\n```html\n<template>\n  <div>\n    <!-- 编程式跳转 -->\n    <!-- 页面跳转方式分两种: 标签式 和 编程式 -->\n    <div id=\"nav\">\n      <!-- 标签式 -->\n      <router-link to=\"/\">首页</router-link>\n      <router-link to=\"/about\">关于</router-link>\n      <button @click=\"goto(\'/news\')\">新闻</button>\n      <button @click=\"goto(\'/login\')\">登录</button>\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    goto(path) {\n      // this: 是当前的vue对象\n      // 路由对象在 router/index.js 中初始化 并 导出\n      // 在 main.js 中被 引入 和 填写到 vue 对象里\n      console.log(this.$router) //从vue中获取 路由对象\n      // push: 用于在路径中推入新的路径\n\n      // 报错: 如果重复跳转,则会抛出错误\n      // 跳转前先判断: 当前路径 和 要跳转到的路径是否相同\n      // 如果相同, 就不跳转\n\n      // 当前路由信息读取: this.$router.currentRoute 太长了\n      // 作者提供了简化的属性 $route, 可以快速读取\n      // 相当于 $route(){return this.$router.currentRoute}\n      console.log(\'$route:\', this.$route)\n      // if (this.$router.currentRoute.path == path) return\n      if (this.$route.path == path) return\n\n      this.$router.push(path)\n\n      // 注意: 数组也有一个push方法, 与这里的push仅仅是同名\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 路由参数\n\n```html\n<template>\n  <div>\n    <div id=\"nav\">\n      <!-- 路由传参 类似于 get的传参 -->\n      <!-- 格式: 路径?参数=值&参数=值... -->\n      <router-link to=\"/about?name=阿斌&age=22&phone=13688778888\"\n        >关于阿斌</router-link\n      >\n      <router-link to=\"/about?name=泡泡&age=18&phone=15788779999\"\n        >关于泡泡</router-link\n      >\n    </div>\n\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n```html\n<template>\n  <div>\n    <h1>关于{{ $route.query.name }}</h1>\n    <div>age: {{ $route.query.age }}</div>\n    <div>phone: {{ $route.query.phone }}</div>\n    <button @click=\"showRoute\">查看路由信息</button>\n    <!-- fullPath: 路径+参数 -->\n    <!-- path: 路径 -->\n    <!-- ?传递的参数保存在query属性里 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    showRoute() {\n      console.log(this.$route)\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n## 路由配置\n\n```javascript\nimport Vue from \'vue\'\nimport VueRouter from \'vue-router\'\nimport HomeView from \'../views/HomeView.vue\'\n//做法1: 先引入组件, 再完成注册\nimport NewsPage from \'../views/NewsPage.vue\'\nimport LoginPage from \'../views/LoginPage.vue\'\n\n// 路由注册方式有两种\n// - 非懒加载: 先import 再使用\n// - 懒加载 : 利用箭头函数引入, 临时调用函数时再引入\n//      -- 未使用前 不引入; 使用时 临时引入\n\nVue.use(VueRouter)\n\nconst routes = [\n  // vroute-named\n  {\n    path: \'/douyu\',\n    name: \'斗鱼页面\', //非必备属性, 起个名字方便查看\n    component: () => import(\'../views/DouYu.vue\'),\n  },\n  {\n    path: \'/login\',\n    component: LoginPage,\n  },\n  // localhost:8080/news\n  {\n    // path: 路径; 必须 / 开头\n    path: \'/news\',\n    // component: 组件;  代表 路径对应的组件\n    component: NewsPage,\n  },\n  {\n    path: \'/\',\n    name: \'home\',\n    component: HomeView,\n  },\n  {\n    path: \'/about\',\n    component: () => import(\'../views/AboutView.vue\'),\n  },\n  {\n    path: \'/bin\',\n    component: () => import(\'../views/BinPage.vue\'),\n  },\n]\n\nconst router = new VueRouter({\n  mode: \'history\',\n  base: process.env.BASE_URL,\n  routes,\n})\n\nexport default router\n\n```\n\n## 斗鱼练习\n\n```html\n<template>\n  <div>\n    <!-- http://douyu.xin88.top/api/cate/recList -->\n    <template v-if=\"data\">\n      <!-- to: 是router-link的必备属性, 不写会爆红 -->\n      <router-link\n        v-for=\"{ cate2Id, name, shortName } in data.data\"\n        :key=\"cate2Id\"\n        :to=\"`/douyu?sn=${shortName}`\"\n      >\n        {{ name }}\n      </router-link>\n    </template>\n    <!-- 占位符: 路由切换的核心 -->\n    <router-view />\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  data() {\n    return {\n      data: null,\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  methods: {\n    getData() {\n      const url = \'http://douyu.xin88.top/api/cate/recList\'\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\na {\n  text-decoration: none;\n  color: #333;\n  display: inline-block;\n  margin: 3px 8px;\n\n  &.router-link-exact-active {\n    color: orange;\n  }\n}\n</style>\n\n```\n\n\n\ndouyu.vue\n\n```html\n<template>\n  <div>\n    <h1>房间列表: {{ $route.query.sn }}</h1>\n    <!-- \n      参数type: 代表请求的具体数据类型, 对应路由参数 sn\n      http://douyu.xin88.top/api/room/list?page=1&type=yz \n      \n      发请求,获取数据进行展示\n      监听到 路由参数变化, 则需要重新发请求 获取最新的数据\n    -->\n    <template v-if=\"data\">\n      <div id=\"box\">\n        <div\n          v-for=\"{ rid, nickname, roomName, roomSrc, hn } in data\n            .data.list\"\n          :key=\"rid\"\n        >\n          <div>\n            <img :src=\"roomSrc\" alt=\"\" />\n            <span>{{ hn }}</span>\n            <span>{{ nickname }}</span>\n          </div>\n          <span>{{ roomName }}</span>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n<script>\nimport axios from \'axios\'\nexport default {\n  data() {\n    return {\n      data: null,\n    }\n  },\n  mounted() {\n    this.getData()\n  },\n  // 监听路由的变化\n  watch: {\n    $route() {\n      this.getData()\n    },\n  },\n  methods: {\n    getData() {\n      const url = `http://douyu.xin88.top/api/room/list?page=1&type=${this.$route.query.sn}`\n      axios.get(url).then(res => {\n        console.log(res)\n        this.data = res.data\n      })\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n#box {\n  width: 800px;\n\n  > div {\n    display: inline-flex;\n    flex-direction: column;\n    margin: 0 10px 10px 0;\n    width: 300px;\n\n    > div {\n      position: relative;\n      > img {\n        width: 100%;\n        display: block;\n      }\n      > span:nth-child(2) {\n        position: absolute;\n        right: 0;\n        top: 0;\n        background-color: rgba(0, 0, 0, 0.5);\n        padding: 2px;\n        color: white;\n      }\n\n      > span:nth-child(3) {\n        position: absolute;\n        left: 0;\n        bottom: 0;\n        background-color: rgba(0, 0, 0, 0.5);\n        padding: 2px;\n        color: white;\n      }\n    }\n  }\n}\n</style>\n\n```\n\n\n\n## 总结\n\n路由系统:\n\n- Vue制作`单页应用 SPA` 的核心模块\n- 整个网页只有一个html文件, 通过局部的内容切换 来模仿`多页的`效果\n- 核心理念: 通过监听地址栏`路径的`变化, 来找到对应的模块, 替换掉占位符\n- router-view: 占位符:  路由操作的发起人\n- `router/index.js`: 完成路由的相关配置, 主要是注册操作\n  - 非懒加载\n    - 通过import 先引入组件, 再完成注册\n    - `适合`: 经常使用的页面, 提前加载 提高用户体验\n  - 懒加载:\n    - 通过箭头函数来引入组件, 在使用时临时触发\n    - `适合`: 不常用的页面. 延迟加载, 提高首次加载的效率\n- views目录: 用于存放 由路由进行切换的组件 -- 属于页面上 一个大型的整体\n- 页面跳转\n  - 标签式跳转: `<router-link to=\"/路径\">`\n    - 最终表现是 `a` 标签, 所以给a 标签添加样式即可\n    - 自带激活样式\n      - 模糊: `router-link-active`\n      - 精确: `router-link-exact-active`\n  - 编程式跳转: 通过代码完成跳转操作\n    - $router: 是vue router对象, 包含所有的路由操作\n    - $route: 是当前路由信息, 本质上是 $router.currentRoute 属性\n- 路由传参\n  - 问号 URL传参:  `/路径?参数=值&参数=值&...`\n  - 参数存储在 : `$route.query` 属性里\n\n\n\n## 作业\n\n- 路由的流程图: 必须手动绘制至少1次\n- 最终的练习: 涉及到今日讲解的所有知识点. 必须做到完整写出来一次\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\",\"axios\"]', 0, 0);
INSERT INTO `blog` (`bid`, `title`, `desc`, `content`, `createTime`, `cid`, `tname`, `watch`, `star`) VALUES
(22, 'Vue基础06', '路由系统、css作用域、外部css、图片资源、Vuex、Vuex辅助函数', '# Vue06\n\n> 淘宝镜像升级, 需要切换后才能生成镜像\n>\n> - 设置镜像: `npm set registry https://registry.npmmirror.com/`\n>\n> - 查看是否设置完毕:  `npm get registry`\n>\n>   ![image-20220921090210212](assets/image-20220921090210212.png)\n>\n> > 原镜像: 此镜像是国外的, 需要`科学上网` 才能访问\n> >\n> > `npm config set registry https://registry.npmjs.org`\n\n## 路由系统\n\n![image-20220921091456434](assets/image-20220921091456434.png)\n\n```html\n<template>\n  <div>\n    <div id=\"nav\">\n      <!-- \n        express传参:\n        - ? :  路径?参数=值&参数=值..    读取从query属性\n        - 先设置 路径/:参数/:参数    \n          -- 使用时: 路径/阿斌/22     读取时从 params 属性\n       -->\n\n      <router-link to=\"/\">Home</router-link>\n      <router-link to=\"/about?name=阿斌&age=22\"\n        >About</router-link\n      >\n      <!-- login -->\n      <router-link to=\"/login/泡泡/18/11111\">登录</router-link>\n    </div>\n\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style lang=\"scss\" scoped>\na {\n  color: #333;\n  margin: 10px;\n  background-color: #eee;\n  padding: 10px 20px;\n  display: inline-block;\n}\n</style>\n\n```\n\n```html\n<template>\n  <div>\n    <button @click=\"showRoute\">查看路由参数</button>\n    <div>name:{{ $route.params.name }}</div>\n    <div>age:{{ $route.params.age }}</div>\n    <div>suibian:{{ $route.params.suibian }}</div>\n    <hr />\n    <div>name:{{ name }}</div>\n    <div>age:{{ age }}</div>\n    <div>suibian:{{ suibian }}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // 作者提供了 用 props 属性来接收路由参数的功能\n  // 隐藏功能, 需要主动开启: 在路由配置中书写 props:true\n  props: [\'name\', \'age\', \'suibian\'],\n  // 必须和路径设置中的参数一模一样\n\n  methods: {\n    showRoute() {\n      console.log(this.$route)\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n路由配置\n\n```js\nimport Vue from \'vue\'\nimport VueRouter from \'vue-router\'\nimport HomeView from \'../views/HomeView.vue\'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    // 传参方案: 在路径中提前配置参数名\n    // /路径/:参数名/:参数名...   利用: 来标识参数\n    path: \'/login/:name/:age/:suibian\',\n    props: true, //代表: 开启组件的props接收路由参数功能\n    name: \'Login\',\n    component: () => import(\'../views/LoginView.vue\'),\n  },\n  {\n    path: \'/\',\n    name: \'home\',\n    component: HomeView,\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(\n        /* webpackChunkName: \"about\" */ \'../views/AboutView.vue\'\n      ),\n  },\n]\n\nconst router = new VueRouter({\n  mode: \'history\',\n  base: process.env.BASE_URL,\n  routes,\n})\n\nexport default router\n\n```\n\n\n\n## 关于css的作用域\n\n```html\n<template>\n  <div>\n    <!-- 关于外部css的使用 -->\n    <hello-world></hello-world>\n\n    <h2>App</h2>\n    <ul>\n      <li>阿斌</li>\n      <li>浩浩</li>\n      <li>洋洋</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport HelloWorld from \'./components/HelloWorld.vue\'\nexport default {\n  components: { HelloWorld },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n// App中 使用了 HelloWorld组件, 所以会称为 父子关系\n// App是父,  HelloWorld是子  <App><HelloWorld/></App>\n// 在局部中书写的代码, 只能影响到 template中书写的标签\nli {\n  background-color: orange;\n}\n\n.hello-world {\n  background-color: #ccc;\n  // li属于hello-world内部的子元素, 无法在父元素中进行修改\n\n  // 样式穿透: 强制修改子元素内部的元素样式\n  // 非常规手段: 需要主动添加 ::deep 前缀才能穿透表层 修改其内部样式\n  ::v-deep li {\n    font-size: 30px;\n  }\n}\n\n// 总结:\n// 1. 带有scoped属性的style标签中, 书写的样式是局部的 -- 只能影响当前组件中书写的标签\n//   -- 样式穿透: 可以强制修改子元素内部的元素的样式\n// 2. 不带scoped属性: 则影响全局所有标签\n</style>\n\n```\n\n```html\n<template>\n  <div class=\"hello-world\">\n    <h1>Hello World</h1>\n    <ul>\n      <li>泡泡</li>\n      <li>铭铭</li>\n      <li>亮亮</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style lang=\"scss\" scoped>\n// scoped: 当前作用域内; 仅限在当前组件中生效\n// 不加 scoped 将会影响全局\nli {\n  color: green;\n}\n\n.hello-world {\n  border: 4px solid purple;\n}\n</style>\n\n```\n\n## 外部css\n\n```html\n<template>\n  <div>\n    <!-- 外部css文件: 存放在assets目录下 -->\n    <h1>App</h1>\n    <my-btn></my-btn>\n  </div>\n</template>\n\n<script>\nimport MyBtn from \'./components/MyBtn.vue\'\n\n// 总: 在JS中引入外部css文件, 将会影响全局\n// JS中引入外部css\n// import \'./assets/css/my.css\'\n// JS中引入外部scss\n// import \'./assets/css/my.scss\'\n\nexport default {\n  components: { MyBtn },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n// 引入外部 scss :  在 scss中 带有scoped属性, 为局部引入\n// @import \'./assets/css/my.scss\';\n\n// 不要用 url() 的写法: 存在问题\n// @import url(\'./assets/css/my.scss\');\n</style>\n\n<style scoped src=\"./assets/css/my.css\">\n/* 没有 lang 属性, 默认为css代码 */\n/* css的引入, 需要src 来引入 */\n</style>\n\n```\n\n## 图片资源\n\n```html\n<template>\n  <div>\n    <!-- 本地图片的存放与使用 -->\n    <!-- public: 静态托管文件夹, 所有放在这里的文件最终都会打包到项目的根目录中 -->\n    <!-- 相当于 localhost:8080/505.jpg -->\n    <img src=\"/505.jpg\" height=\"100\" alt=\"\" />\n    <!-- assets: 智能文件夹 -- 会静态分析代码, 仅把用到的图片资源进行打包 -->\n    <!-- 此目录下的图, 需要用相对路径引入 -->\n    <img src=\"./assets/img/banner1.png\" height=\"200\" alt=\"\" />\n    <hr />\n    <img :src=\"banner2\" alt=\"\" />\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      // JS引擎当阅读到 require 时, 就会知道 这个字符串是一个文件资源  并非 是普通的字符串 -- 进而完成底层的打包处理\n      banner2: require(\'./assets/img/banner2.png\'),\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n## 共享数据Vuex\n\n```html\n<template>\n  <div>\n    <!-- 组件间的状态共享: 不同组件之间传递数据 -->\n    <!-- 方案1: 通过事件实现子传父 -->\n    <!-- 方案2: 通过时间总线 event bus  -->\n    <!-- 方案3: Vuex -->\n\n    <!-- Vuex: 全局状态共享 -->\n    <!-- Vuex的思路: 设置一个公共的对象, 把需要共享的数据存储在这里, 其他组件都从这个对象中读取值即可 -->\n    <!-- 此对象在 store/index.js 中 -->\n    <one-com />\n\n    <h3>App</h3>\n    <!-- 读取共享的属性 -->\n    <!-- $store: 在 main.js 中注入到 new Vue 中的那个 -->\n    <p>num: {{ $store.state.num }}</p>\n    <p>money: {{ $store.state.money }}</p>\n    <p>child: {{ $store.state.child }}</p>\n    <button @click=\"showStore\">查看共享数据</button>\n  </div>\n</template>\n\n<script>\nimport OneCom from \'./components/OneCom.vue\'\nexport default {\n  methods: {\n    showStore() {\n      console.log(this.$store)\n    },\n  },\n  components: { OneCom },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n```html\n<template>\n  <div class=\"one-com\">\n    <!-- 修改共享的数据num -->\n    <h1>one com : {{ $store.state.num }}</h1>\n    <input type=\"text\" v-model=\"$store.state.money\" />\n    <br />\n    <button @click=\"$store.state.num++\">\n      $store.state.num++\n    </button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      num: 1,\n    }\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.one-com {\n  border: 4px solid blue;\n}\n</style>\n\n```\n\n\n\n配置\n\n```js\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n// 在 main.js 文件中, 此对象被注入到 Vue对象中\nexport default new Vuex.Store({\n  // 开启严格模式: 此模式下不可以随意修改state中的值, 如果直接修改 则后台会报错提醒\n  strict: true,\n\n  // 5个核心属性:\n  // state: 用于存放共享数据\n  state: {\n    num: 1,\n    money: 20500,\n    child: \'李薛凝\',\n    x: 10,\n    y: 20,\n    z: 30,\n  },\n  getters: {},\n  // 这里存放用于修改state值的相关方法\n  // 按照规矩: 要想修改state中的值, 必须通过预设定的方法进行才合法\n  mutations: {\n    // 携带额外参数\n    money_n(state, n) {\n      state.money -= n\n    },\n\n    // 固定参数1: 共享数据存储的对象 - state\n    money_500(state) {\n      state.money -= 500\n    },\n\n    num_10(state) {\n      state.num -= 10\n    },\n    x_10(state) {\n      state.x -= 10\n    },\n    y_100(state) {\n      state.y -= 100\n    },\n    z_200(state) {\n      state.z -= 200\n    },\n  },\n  actions: {},\n  modules: {},\n})\n\n```\n\n\n\n## 辅助函数\n\n```html\n<template>\n  <div>\n    <div>x:{{ $store.state.x }}, {{ x }}</div>\n    <div>y:{{ $store.state.y }}, {{ y }}</div>\n    <div>z:{{ $store.state.z }}, {{ z }}</div>\n    <hr />\n    <button @click=\"$store.commit(\'x_10\')\">x-10</button>\n    <button @click=\"$store.commit(\'y_100\')\">y-100</button>\n    <button @click=\"$store.commit(\'z_200\')\">z-200</button>\n    <hr />\n    <button @click=\"x_10\">x-10</button>\n    <button @click=\"y_100\">y-100</button>\n    <button @click=\"z_200\">z-200</button>\n  </div>\n</template>\n\n<script>\nimport { mapMutations, mapState } from \'vuex\'\n// 简化方案: 辅助函数 - 原理在网盘中有视频\nexport default {\n  // state中存放的是属性, 要书写在计算属性中\n  computed: {\n    // 固定语法:  ... 是展开符\n    ...mapState([\'x\', \'y\', \'z\']),\n  },\n  // mutations中存放的是函数, 要书写在methods里\n  methods: {\n    ...mapMutations([\'x_10\', \'y_100\', \'z_200\']),\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n练习\n\n```html\n<template>\n  <div>\n    <div>money:{{ $store.state.money }}</div>\n    <div>money:{{ money }}</div>\n\n    <button @click=\"$store.commit(\'money_n\', 5)\">-5</button>\n\n    <button @click=\"$store.commit(\'money_n\', 100)\">-100</button>\n    <hr />\n    <button @click=\"money_n(1000)\">-1000</button>\n  </div>\n</template>\n\n<script>\nimport { mapMutations, mapState } from \'vuex\'\nexport default {\n  computed: {\n    ...mapState([\'money\']),\n  },\n  methods: {\n    ...mapMutations([\'money_n\']),\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped></style>\n\n```\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\",\"Vuex\"]', 1, 0),
(23, '初步学习Vue3+TypeScript', '学习Vue3的语法以及组合式api、数据监听及代理的原理（proxy)。TypeScript语法及数据类型等……', '# Vue09\n\n## Vue3\n\n- Vue3提倡使用 `Typescript` 代替 `JavaScript` 进行开发\n\n\n\n## TypeScript\n\nhttps://www.tslang.cn/\n\n![image-20220926090912304](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220926090912304.png)\n\n### 编译器的安装\n\n编译器就相当于是 `翻译机`, 例如 把`中文` 翻译成 `英文` 才能与外国人交流\n\n浏览器`只支持JS`, 书写的TS代码要想运行在浏览器, 必须先编译成JS 然后再运行\n\n> `npm i -g typescript`\n>\n> <img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220926091115643.png\" alt=\"image-20220926091115643\" style=\"zoom: 50%;\" />\n>\n> 使用 `tsc -v` 查看已安装的版本\n>\n> <img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220926091154649.png\" alt=\"image-20220926091154649\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220926090937303.png\" alt=\"image-20220926090937303\" style=\"zoom:50%;\" />\n\n\n\n### 强类型\n\n```ts\n// .ts : 代表 TypeScript 代码文件\n// 强类型\n\n// 编程语言按照强弱类型分为两种\n// 弱数据类型: php js python ... 作为代表\n// 强数据类型: C  C++ JAVA ... 作为代表\n\n// 弱数据类型: 声明一个变量, 其中可以存放任意类型的数据\n// var 阿斌的伴侣\n// 阿斌的伴侣 = 电脑\n// 阿斌的伴侣 = 3.14\n// 阿斌的伴侣 = true\n// 阿斌的伴侣 = 阿怡\n\n// 强类型: 在声明变量时, 指定其中存放的数据类型\n// 变量名: 类型名   编程工具就能知道 uname必须存放字符串\nvar uname: string\n\nuname = \'mike\'\nuname = 323\nuname = true\nuname = []\n\n// 好处: 后续使用uname变量时, 可以大胆的认为其是字符串类型, 调用字符串的相关方法\n\nfunction toUpper(str: string) {\n  // vscode能静态分析出  str是字符串类型, 进而给出提示\n  return str.toUpperCase()\n}\n\n//使用\ntoUpper(\'mike\')\n// 静态报错: 无需运行代码, 编程工具就能分析出哪里有错误; 帮助程序员更快的找出bug\ntoUpper(123)\n\n```\n\n\n\n### 重复声明报错\n\n```ts\n// 外部文件重复的变量声明\n\n// 实际开发中, 如果多个文件里有重复的变量. 同时引入到html中, 会产生冲突\nfunction toUpper() {\n  console.log(222)\n}\n\nconst uname = 4444\n\n// vscode可以静态分析: 同时打开的多个 .ts 文件中, 是否有重复声明的变量或函数;  出现报错提示\n\n```\n\n\n\n### 基础类型\n\n```ts\n// 常见数据类型\n\nvar a: string\na = 123\na = \'mike\'\n\nvar b: number\nb = true\nb = 1\n\nvar c: boolean\nc = 123\nc = true\n\n// any: 任意类型; 相当于JS的弱类型\nvar d: any\nd = 1\nd = \'mike\'\nd = true\n\n// 混合类型:  类型名 | 类型名\nvar e: string | number\ne = \'mike\'\ne = 123\ne = true\n\nvar f: string | boolean | number\nf = \'mike\'\nf = 123\nf = true\nf = undefined\nf = null\n\nvar g: string | null\ng = \'mike\'\ng = null\ng = true\n\n```\n\n\n\n### 数组\n\n```ts\n// array\n\n// :Array<类型> : 为数组中的每个元素指定类型\nvar emps: Array<string> = [\'阿斌\', \'泡泡\', \'亮亮\', true, 123]\n\nvar empList: Array<string | number> = [\n  \'阿斌\',\n  \'泡泡\',\n  \'亮亮\',\n  true,\n  123,\n]\n// 简化\nvar names: string[] = [\'mike\', \'lucy\', 123, true]\n\nvar nameList: (string | number)[] = [\'mike\', \'lucy\', 123, true]\n\n// 特殊的数组: 元组类型\nvar bin: [string, number, boolean]\n\n// 定长 + 定类型的数组: 必须按照个数和类型书写的数组\nbin = [\'阿斌\', 22, false]\n\nbin = [22, \'mike\'] //类型不同,报错\nbin = [\'mike\'] //长度错误, 报错\n\n```\n\n\n\n### 对象\n\n```ts\n// 对象类型\n\n// 为对象类型指定 接口/规范/协议\n\n// 未来丈母娘 制定一个女婿规范/接口\n// interface : 接口\ninterface NvXu {\n  che: string\n  fang: string\n  money: number\n}\n\n// 用 接口/规范 来验证阿斌\n// bin 要求符合NvXu 规范\nvar bin: NvXu = {\n  che: \'鬼火少年专属--爆改雅迪\',\n  fang: \'待拆迁棚屋 -- 预计2045年\',\n  money: 500,\n}\n\n```\n\n\n\n### class\n\n```ts\n// 来自Java的class语法: 专精构造函数的制作\n\n// 在TS中, 点语法只允许修改对象的值, 不允许新增; 防止写错属性名导致错误的增加属性\nvar obj = { uname: \'泡泡\' }\n// obj.name = \'亮亮\'\n\n// 矩形\nclass Rect {\n  // TS要求必须提前声明属性, 然后才能使用\n  width: number\n  height: number\n\n  constructor(width: number, height: number) {\n    this.width = width\n    this.height = height\n  }\n}\n\nvar r1 = new Rect(10, 5)\nconsole.log(r1)\n\n// 关于运行ts: 浏览器只能运行JS, 所以需要把TS编译成JS后加载运行\n// 编译的前提: TS文件中不能有报错\n// 编译需要工具: npm i -g typescript\n// 在ts文件所在目录下,打开cmd命令行, 执行编译指令:  tsc 文件名\n\n```\n\n\n\n### 权限\n\n```ts\n// 权限: 可以设定对象中的属性的访问权限\n// public: 公开的\n// protected: 保护的\n// private: 私有的\n\nclass Emp {\n  // 默认不写是 public: 公开的 - 类外可以访问\n  public name = \'阿斌\'\n  // 保护的: 类外无法访问\n  protected money = 500\n  // 私有的: 类外 子类无法使用\n  private wife = \'翠花\'\n}\n\n// 子类: 可以使用父类的属性\nclass Son extends Emp {\n  show() {\n    this.money\n    this.name\n    this.wife\n  }\n}\n\nvar bin = new Emp()\n// 类外: 访问对象中的属性\nbin.name\nbin.money\nbin.wife\n\n```\n\n\n\n## vue2监听器原理\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>vue2 的自动化思想</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <h1 id=\"h1\">5</h1>\n    <button onclick=\"addNum()\">num++</button>\n  </div>\n\n  <script>\n    // vue2: 为data对象中的属性, 添加监听器. 一旦数据变化 就更新相关的DOM元素\n    var data = { num: 5 }\n\n    // 为 data 的 num属性 添加监听器\n    Object.defineProperties(data, {\n      _num: { writable: true, value: 5 },\n      num: {\n        get() { return this._num },\n        set(value) {\n          console.log(\'num变更:\', value)\n          // 变化的值更新给 h1 标签\n          h1.innerHTML = value\n          this._num = value\n        }\n      }\n    })\n\n    function addNum() {\n      data.num++\n      console.log(data.num)\n    }\n\n    // 假设 阿斌 家是开工厂的, 需要防止工人私藏物品, 带出厂区\n    // 1. 阿斌 给每个工人都配一个保安, 盯着干活, 防止偷拿\n    //   -- vue2的做法: 为每个属性配置监听器, 极其消耗资源\n\n    // 2. 阿斌 在门口设置检查站. 每个员工都要检查后 才能通过\n    //  -- vue3的做法: 代理模式 proxy\n  </script>\n</body>\n\n</html>\n```\n\n\n\n## vue3代理原理\n\n代理\n\n<img src=\"assets/image-20220926115430355.png\" alt=\"image-20220926115430355\" style=\"zoom: 67%;\" />\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>vue3的代理模式</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <h1 id=\"h1\">5</h1>\n    <button onclick=\"addNum()\">num++</button>\n  </div>\n\n  <script>\n    var data = { num: 5 }\n\n    // proxy: 来自 ES6提供的新特性, 可以在 对象的外层 包裹一层\n    var proxy_data = new Proxy(data, {\n      // 给对象设置值\n      set(obj, key, value) {\n        // 参数1: 当前管理的对象\n        // 参数2: 要赋值的属性名\n        // 参数3: 要赋的值\n        console.log(`正在给${key}赋值${value}`);\n        obj[key] = value\n\n        h1.innerHTML = value\n      },\n      // 从对象读值\n      get(obj, key) {\n        // 参数1: 当前管理的对象, 即data\n        // 参数2: 读取的属性名\n        return obj[key]\n      }\n    })\n\n    function addNum() {\n      // data.num++\n      // console.log(data.num);\n      // 给代理人赋值 代替 直接给data赋值\n      proxy_data.num++\n    }\n  </script>\n</body>\n\n</html>\n```\n\n## 插件\n\n![image-20220926141306565](assets/image-20220926141306565.png)\n\n\n\n## 关于属性 - data\n\n- vue2 的问题: 自动无偏差的把所有数据项都改为监听器 -- 消耗资源\n- vue3: 把自动改手动 -- 人为判断 给哪些属性加监听器\n  - ref: 给单个值添加监听\n  - reactive: 利用 proxy 给对象类型加监听\n  - toRefs: 把 proxy 转为 多个 ref 组成的对象\n\n```html\n<template>\n  <!-- v3ts:  vbase-3-ts -->\n  <div>Hello</div>\n  <!-- vue3: 支持多个根元素 -->\n  <div>World</div>\n  <div>阿斌666</div>\n  <ul>\n    <li>{{ uname }}</li>\n    <li>{{ age }}</li>\n    <li>{{ money }}</li>\n    <li>\n      <button @click=\"age++\">age++</button>\n      <button @click=\"money++\">money++</button>\n      <button @click=\"count++\">count: {{ count }}</button>\n      <button @click=\"price++\">price: {{ price }}</button>\n    </li>\n  </ul>\n</template>\n\n<script lang=\"ts\">\n// vue2 : 属于选项式编程 - vue对象本身携带着所有的功能, 用户只需要通过选项来开启功能即可\n\n// vue3: 兼容vue2的所有语法 -- 为了用户过渡方便\n// -- 额外增加 组合式语法 composition, 把功能模块化, 用户需要什么功能, 就临时单独引入什么功能\n\n// 要想添加监听器, 必须引入 ref 方法\nimport { defineComponent, ref } from \'vue\'\n// 要想声明组件: 必须临时引入 defineComponent 函数, 调用此函数来声明组件\nexport default defineComponent({\n  // 生命周期: 相当于create -- 即创建数据时\n  // setup:安装,设置 -- 数据\n  setup() {\n    // vue2中的 data watch methods computed 都放在这里生成\n\n    // vue2的监听器原理: 为每个数据项自动添加监听器\n    // -- vue2: 见者有份, 不管属性用不用监听 都会添加--资源浪费\n\n    // vue3: 需要手动为属性添加监听器\n\n    console.log(\'age:\', 22)\n    console.log(\'ref(age):\', ref(22))\n    // ref: 理解为秘书. 可以在数据变化时 完成额外的操作\n\n    return {\n      uname: \'阿斌\',\n      // 相较于vue2的自动化添加监听, 书写繁琐\n      age: ref(22),\n      money: ref(500),\n      count: ref(100),\n      price: ref(400),\n    }\n  },\n})\n</script>\n\n<style scoped lang=\"scss\"></style>\n\n```\n\n\n\n\n\n```html\n<template>\n  <!-- v3ts -->\n  <div>\n    <div>uname:{{ uname }}</div>\n\n    <!-- 代理: 书写时简单, 使用时复杂.  代理.属性名 -->\n\n    <div>age :{{ data.age }}</div>\n    <button @click=\"data.age++\">age++</button>\n\n    <div>count :{{ data.count }}</div>\n    <button @click=\"data.count++\">count++</button>\n\n    <div>price :{{ data.price }}</div>\n    <button @click=\"data.price++\">price++</button>\n\n    <div>num :{{ data.num }}</div>\n    <button @click=\"data.num++\">num++</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n// 引入 reactive 方法: 可以快速把对象类型添加 proxy代理\nimport { defineComponent, reactive } from \'vue\'\n\nexport default defineComponent({\n  setup() {\n    // proxy:\n    var data = reactive({\n      num: 5,\n      count: 100,\n      price: 500,\n      age: 22,\n    })\n\n    console.log(data)\n\n    return {\n      uname: \'阿斌\',\n      data, //必须放在 return 中, 才能在页面上使用\n    }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n```html\n<template>\n  <div>\n    <div>num:{{ num }}</div>\n    <button @click=\"num++\">num++</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n// 引入 reactive 和 toRefs\nimport { defineComponent, reactive, toRefs } from \'vue\'\n\nexport default defineComponent({\n  setup() {\n    // reactive: 优点一次性为大量元素添加监听, 使用时繁琐\n    // ref: 为每个元素单独添加监听, 使用时简单\n    var data = reactive({\n      num: 1,\n      price: 33,\n      count: 44,\n    })\n\n    // toRefs: 把代理中的属性转化成 单个的 ref 监听对象\n    console.log(\'toRefs:\', toRefs(data))\n    // 转换出来的内容类似: {price:ref(33), num:ref(1) ...}\n\n    return {\n      ...toRefs(data),\n    }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n## 计算属性\n\n```html\n<template>\n  <div>\n    <div>num: {{ num }}</div>\n    <div>num*2 : {{ num_db }}</div>\n    <button @click=\"num++\">num++</button>\n    <hr />\n    <div>count:{{ data.count }}</div>\n    <div>count*2: {{ count_2 }}</div>\n    <button @click=\"data.count++\">count++</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\n// 计算属性: computed\nimport { defineComponent, computed, ref, reactive } from \'vue\'\n\nexport default defineComponent({\n  setup() {\n    var num = ref(10)\n    // 计算属性 computed(函数) :函数变为 get 计算属性, 不用()就能触发\n    var num_db = computed(() => {\n      // num是对象类型, 通过 value 属性读取值 才能计算\n      return num.value * 2\n    })\n    console.log(\'num:\', num)\n\n    var data = reactive({ count: 100 })\n\n    const count_2 = computed(() => data.count * 2)\n\n    return { num, num_db, data, count_2 }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n## 监听器\n\n```html\n<template>\n  <div>\n    <div>num:{{ num }}</div>\n    <button @click=\"num++\">num++</button>\n\n    <div>count:{{ data.count }}</div>\n    <button @click=\"data.count++\">count++</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, ref, reactive, watch } from \'vue\'\n\nexport default defineComponent({\n  setup() {\n    var num = ref(1)\n\n    watch(\n      () => num.value, //返回要监听的数据\n      (newValue, oldValue) => {\n        // 参数1: 新值   参数2:旧值\n        console.log(newValue, oldValue)\n      }\n    )\n\n    var data = reactive({ count: 10 })\n\n    watch(\n      () => data.count,\n      (newValue, oldValue) => {\n        console.log(newValue, oldValue)\n      }\n    )\n\n    return { num, data }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n## 方法\n\n```html\n<template>\n  <div>\n    <div>num:{{ num }}</div>\n    <button @click=\"show\">click</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, ref } from \'vue\'\n\nexport default defineComponent({\n  setup() {\n    return {\n      num: ref(10),\n      // 函数不要写 箭头函数, 因为this指向有问题\n      show() {\n        console.log(\'this:\', this)\n\n        // 关于this: 是JS提供的一个灵活多变的关键词, TS语言的静态分析能力 对this很无奈, 经常误报\n        // this是动态运行时才能确定值\n        // 如下写法: 可以让TS忽略这里的检测\n        // @ts-ignore\n        this.num++\n      },\n    }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n## axios\n\n```html\n<template>\n  <div v-if=\"data\">\n    <div>pageNum: {{ data.pageNum }}</div>\n    <!-- vue3插件 不再强制写key -->\n    <div v-for=\"{ title } in data.data\">\n      {{ title }}\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\n// 安装axios模块: npm i axios\n\nimport { defineComponent, onMounted, ref } from \'vue\'\nimport axios from \'axios\'\n// 基础路径\naxios.defaults.baseURL = \'https://web.codeboy.com/mfresh/data/\'\n\nexport default defineComponent({\n  setup() {\n    var url = `news_select.php`\n    // any:代表任意类型, TS会忽略 此变量的类型分析\n    var data: any = ref(null)\n\n    // 挂载时, 发请求\n    onMounted(() => {\n      getData()\n    })\n\n    function getData() {\n      axios.get(url).then(res => {\n        console.log(res)\n\n        data.value = res.data\n      })\n    }\n\n    return { data }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n\n\n## router\n\n```html\n<template>\n  <div>\n    <div id=\"nav\">\n      <router-link to=\"/\">Home</router-link>\n      <router-link to=\"/about\">About</router-link>\n      <router-link to=\"/bin\">Bin</router-link>\n      <router-link to=\"/adsfa\">404</router-link>\n      <button @click=\"goHome\">回到首页</button>\n    </div>\n\n    <router-view />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \'vue\'\nimport { useRouter } from \'vue-router\'\n\nexport default defineComponent({\n  setup() {\n    // vue3: 通过函数来引入非 常用模块\n    // 这些函数都是 use 开头的\n    const $router = useRouter()\n    console.log(\'$router:\', $router)\n\n    return {\n      goHome() {\n        console.log(\'this:\', this)\n        // 在vue3中, 重复的路径跳转 不再报错\n        $router.push(\'/\')\n        // this中没有 $router 可以使用\n        // vue2: 把所有可能用到的 都存储在对象里 -- 臃肿\n      },\n    }\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n#nav {\n  display: flex;\n\n  a {\n    padding: 10px 20px;\n    margin: 4px;\n    background-color: orange;\n  }\n}\n</style>\n\n```\n\n```ts\nimport {\n  createRouter,\n  createWebHistory,\n  RouteRecordRaw,\n} from \'vue-router\'\nimport HomeView from \'../views/HomeView.vue\'\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    //https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html\n    // vue3的通配符书写有变更\n    path: \'/:pathMatch(.*)*\',\n    name: \'404\',\n    component: () => import(\'../views/NotFound.vue\'),\n  },\n  {\n    path: \'/bin\',\n    name: \'Bin\',\n    component: () => import(\'../views/BinView.vue\'),\n  },\n  {\n    path: \'/\',\n    name: \'home\',\n    component: HomeView,\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(\n        /* webpackChunkName: \"about\" */ \'../views/AboutView.vue\'\n      ),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n})\n\nexport default router\n\n```\n\n\n\n## vuex\n\n```html\n<template>\n  <div>\n    <div>num: {{ store.state.num }}</div>\n    <button @click=\"store.commit(\'num_1\')\">点击</button>\n    <div>num:{{ num }}</div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \'vue\'\nimport { mapState, useStore } from \'vuex\'\n\nexport default defineComponent({\n  //vue3兼容vue2\n  computed: {\n    ...mapState([\'num\']),\n  },\n  mounted() {},\n  methods: {},\n\n  setup() {\n    // 正常操作: 用 use 方式把 store 模块引入, 返回到页面上\n    const $store = useStore()\n    // 自定义的属性不推荐用 $ 或 _ 开头, 以为这两个开头是 vue的系统属性专属的\n    return { store: $store }\n  },\n})\n</script>\n\n<style scoped></style>\n\n```\n\n```ts\nimport { createStore } from \'vuex\'\n\nexport default createStore({\n  state: {\n    num: 1,\n  },\n  getters: {},\n  mutations: {\n    num_1(state) {\n      state.num++\n    },\n  },\n  actions: {},\n  modules: {},\n})\n\n```\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 7, '[\"vue\",\"TypeScript\",\"Vuex\",\"axios\"]', 2, 0),
(24, 'HTML5新特性', 'Web存储、音视频及相关操作、canvas、svg、地理定位、文件上传、webSocket、webworker', '# `HTML5新特性` `DAY01`\n\n在首页选择一篇文章，点击后跳转到详情页，在详情页中点击后退，回到首页后，发现首页重新初始化，执行`mounted`加载UI类别的文章列表。**并没有停留在上一次的列表位置**，用户体验不好。\n\n如何在点击返回后，将首页的状态保存下来，不要重新加载首页？\n\n`Vue`中的`keepAlive`提供了**组件保活机制**用来实现这个效果。 这个需求在移动端项目中很常见。\n\n`keepAlive`机制：\n\n若首页设置了保活，则当返回到首页时，将不会执行`mounted`生命周期，将会把页面的数据以及状态保留下来直接显示。\n\n\n\n**如何实现？**\n\n`App.vue`\n\n```html\n<template>\n	<div>\n        <keep-alive>\n        	<router-view />\n        </keep-alive>\n    </div>\n</template>\n```\n\n上述操作可以将`router-view`显示的组件都实现保活效果。但是：\n\n1. 希望`/home/index`实现保活\n2. 不希望`/article`实现保活\n\n```html\n<keep-alive>\n    <router-view v-if=\"$route.meta.keepAlive\" />\n</keep-alive>\n<router-view v-if=\"!$route.meta.keepAlive\"/>\n```\n\n```javascript\n{\n    path: \'\',\n    component: 组件,\n    meta: { keepAlive:true }\n}\n```\n\n\n\n```\ngit工作流\n链接：https://pan.baidu.com/s/1eqTPvU39a1D99Z4SW0NKTQ \n提取码：weth\n```\n\n\n\n发现一个`bug`：对于`mint-ui`提供的`infinitescroll`指令，当跳转到其它页面后，在另外页面进行滚动时，也会不断触发`loadMore`。所以需要处理一下：\n\n1. 当跳转到其它页面时，首页将进入非激活态（后台），需要停用`loadMore`。 \n2. 当返回到首页时，首页将重新进入激活态（回到前台），需要启用`loadMore`。\n\n **`vue`针对`keepAlive`机制，又提供了两个生命周期钩子函数。一旦组件被保活，将会解锁如下两个生命周期：** \n\n1. `activated`    当前页面重新进入激活态时执行（回到当前页，当前页进入前台状态）。\n2. `deactivated`    当前页面进入非激活态时执行（跳转到其它页面，当前页进入后台状态）。\n\n\n\n**实现注册业务**\n\n**实现登录业务**\n\n\n\n以后在处理post请求时，要养成好习惯：\n\n1. 每次请求拿到响应后都要打印。\n2. 每次请求都要看一下Network，看一下请求路径，请求参数，请求方式是否匹配接口文档。\n3. 查看一下数据库，查看是否对数据库有正确的影响。\n\n\n\n#### 当登录成功后，首页显示用户信息\n\n1. 当登录成功后，需要将用户名存入`vuex`。  \n\n   1. 在mutations中声明一个方法：`updateName()`\n\n   2. 当登录成功后调用mutations的方法：\n\n      ```\n      $store.commit(\'updateName\', \'新用户名\')\n      ```\n\n2. 在首页中判断，如果用户名不是空（\'\'或undefined），应该显示欢迎信息。\n\n\n\n### `Vuex`\n\n实现`vue`单页面应用下的全局状态管理。\n\n\n\n将登录用户存入`vuex`后，首页将会出现欢迎信息，但是不能刷新页面。一旦刷新页面，则单页面项目中所有的`vue`环境都会被初始化。`vuex`也不例外。 所以刷新页面后，存储的用户数据将会销毁。\n\n如果希望刷新页面后数据依然保留（甚至关了浏览器，再开还保留），则必须找一个**刷新不销毁的地方**来配合`vuex`存储这些数据。 \n\n\n\n#### `Vant`的基本使用\n\n1. 在项目根目录中，安装`vant`。\n\n   ```\n   npm i vant@latest-v2 -S\n   ```\n\n2. 在`main.js`中引入`vant`。\n\n   ```\n   import Vant from \'vant\';\n   import \'vant/lib/index.css\';\n   Vue.use(Vant);\n   ```\n\n3. 在组件中直接使用。\n\n   根据文档复制粘贴。\n\n\n\n\n\n\n\n## `HTML5`新特性\n\n### `WebStorage`  `Web`存储\n\n包含两大类：`SessionStorage`会话存储   `LocalStorage ` 本地存储\n\n`SessionStorage`:  会话存储仅在浏览器单会话状态下生效。刷新没关系，关闭浏览器的话，`sessionStorage`中存储的数据将会销毁。\n\n`LocalStorage`: 本地存储将会把数据存储在浏览器本地。关了浏览器，下次打开时依然可以访问。\n\n#### `HTML5`提供了这两部分存储区用于在项目实现过程中存储一些网站相关数据。具体需求具体分析。\n\n**如何存储数据？**\n\n```javascript\nwindow.sessionStorage.setItem(key, value)\nwindow.sessionStorage.setItem(\'name\', \'zhangsan\')\nwindow.localStorage.setItem(\'name\', \'zhangsan\')\n```\n\n**如何读取数据？**\n\n```\nlet val = window.sessionStorage.getItem(key)\nlet val = window.localStorage.getItem(key)\n```\n\n**实现**\n\n1. 当登录成功后，不仅要把数据存入state，还需要把数据存入`sessionStorage`。 \n2. 当`f5`刷新页面时，`vuex`将会被初始化，`state.username`也会被初始化为空字符串。这时，就可以为`vuex`的`state.username`提供初始化值：从`sessionStorage`读取。\n\n\n\n**常用`API`：**\n\n```\nsessionStorage.setItem(key, value)\nlocalStorage.setItem(key, value)\n```\n\n```\nsessionStorage.getItem(key)\nlocalStorage.getItem(key)\n```\n\n```\nsessionStorage.removeItem(key)\nlocalStorage.removeItem(key)\n```\n\n```\nsessionStorage.clear()\nlocalStorage.clear()\n```\n\n\n\n### 音频与视频\n\n`HTML5`提供了一些标准（新标签）用于在网页中播放音频与视频。\n\n#### 音频标签\n\n音频标签支持的格式：`mp3` / `ogg` / `wav`  \n\n```html\n<audio src=\"指向音频文件的路径\" controls></audio>\n```\n\n`controls`属性用于设置是否显示播放器控制面板。\n\n**音频标签的常用属性**\n\n```html\n<audio src=\"指向音频文件的路径\" \n       controls 是否显示控制面板\n       autoplay 是否自动播放\n       muted    是否默认静音\n       loop     是否单曲循环\n       preload=\"metadata|auto|none\" \n       ></audio>\n```\n\n`preload` 音频资源的预加载模式\n\n\n\n#### 视频标签\n\n支持的视频格式：`mp4` / `webm` / `ogg` \n\n```html\n<video src=\"视频文件路径\" controls></video>\n```\n\n**视频标签常用的属性**\n\n```html\n<video src=\"指向音频文件的路径\" \n       controls 是否显示控制面板\n       autoplay 是否自动播放\n       muted    是否默认静音\n       loop     是否单曲循环\n       preload=\"metadata|auto|none\" \n       width=\"播放器的宽度\"\n       height=\"播放器的高度\"\n       poster=\"图片路径\"    视频未开始播放时显示的封面图片\n       ></video>\n```\n\n# `HTML5新特性` `DAY02`\n\n### `HTML`音视频相关`DOM`操作\n\n```html\n<audio id=\"audio\" src=\"./assets/1.mp3\"></audio>\n```\n\n```javascript\nlet audio = document.getElementById(\"audio\")   // 获取DOM元素\naudio.src = \"./assets/2.mp3\"    // 修改dom元素的属性\naudio.play()   // 调用dom对象的方法\naudio.onerror = ()=>{   // 为dom对象绑定事件\n    console.log()\n}\n```\n\n#### `HTML5 Audio/Video` 方法\n\n```javascript\nlet audio = document.getElementById(\"audio\")\naudio.play()\naudio.pause()\n```\n\n| 方法                                                         | 描述                    |\n| ------------------------------------------------------------ | ----------------------- |\n| [play()](https://www.w3school.com.cn/tags/av_met_play.asp)   | 开始播放音频/视频       |\n| [pause()](https://www.w3school.com.cn/tags/av_met_pause.asp) | 暂停当前播放的音频/视频 |\n\n#### `HTML5 Audio/Video` 属性  \n\n```html\nlet audio = document.getElementById(\"audio\")\naudio.currentTime\n```\n\n| 属性                                                         | 描述                                          |\n| ------------------------------------------------------------ | --------------------------------------------- |\n| [currentTime](https://www.w3school.com.cn/tags/av_prop_currenttime.asp) | 设置或返回音频/视频中的当前播放位置（以秒计） |\n| [duration](https://www.w3school.com.cn/tags/av_prop_duration.asp) | 返回当前音频/视频的长度（以秒计）             |\n| [ended](https://www.w3school.com.cn/tags/av_prop_ended.asp)  | 返回音频/视频的播放是否已结束                 |\n| [error](https://www.w3school.com.cn/tags/av_prop_error.asp)  | 返回表示音频/视频错误状态的 MediaError 对象   |\n| [loop](https://www.w3school.com.cn/tags/av_prop_loop.asp)    | 设置或返回音频/视频是否应在结束时重新播放     |\n| [muted](https://www.w3school.com.cn/tags/av_prop_muted.asp)  | 设置或返回音频/视频是否静音                   |\n| [paused](https://www.w3school.com.cn/tags/av_prop_paused.asp) | 设置或返回音频/视频是否暂停                   |\n| [playbackRate](https://www.w3school.com.cn/tags/av_prop_playbackrate.asp) | 设置或返回音频/视频播放的速度                 |\n| [src](https://www.w3school.com.cn/tags/av_prop_src.asp)      | 设置或返回音频/视频元素的当前来源             |\n| [volume](https://www.w3school.com.cn/tags/av_prop_volume.asp) | 设置或返回音频/视频的音量                     |\n\n#### `HTML5 Audio/Video` 事件\n\n```javascript\nplayer.onabort = function(){  \n	// 监听音频/视频的加载已放弃时  执行该方法\n}\nplayer.addEventListener(\"abort\", function(){\n    // 监听音频/视频的加载已放弃时  执行该方法\n})\n```\n\n| 事件                                                         | 描述                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| abort                                                        | 当音频/视频的加载已放弃时                    |\n| [canplay](https://www.w3school.com.cn/tags/av_event_canplay.asp) | 当浏览器可以播放音频/视频时                  |\n| [canplaythrough](https://www.w3school.com.cn/tags/av_event_canplaythrough.asp) | 当浏览器可在不因缓冲而停顿的情况下进行播放时 |\n| [durationchange](https://www.w3school.com.cn/tags/av_event_durationchange.asp) | 当音频/视频的时长已更改时                    |\n| emptied                                                      | 当目前的播放列表为空时                       |\n| ended                                                        | 当目前的播放列表已结束时                     |\n| error                                                        | 当在音频/视频加载期间发生错误时              |\n| [loadeddata](https://www.w3school.com.cn/tags/av_event_loadeddata.asp) | 当浏览器已加载音频/视频的当前帧时            |\n| [loadedmetadata](https://www.w3school.com.cn/tags/av_event_loadedmetadata.asp) | 当浏览器已加载音频/视频的元数据时            |\n| [loadstart](https://www.w3school.com.cn/tags/av_event_loadstart.asp) | 当浏览器开始查找音频/视频时                  |\n| pause                                                        | 当音频/视频已暂停时                          |\n| play                                                         | 当音频/视频已开始或不再暂停时                |\n| playing                                                      | 当音频/视频在已因缓冲而暂停或停止后已就绪时  |\n| [progress](https://www.w3school.com.cn/tags/av_event_progress.asp) | 当浏览器正在下载音频/视频时                  |\n| ratechange                                                   | 当音频/视频的播放速度已更改时                |\n| seeked                                                       | 当用户已移动/跳跃到音频/视频中的新位置时     |\n| seeking                                                      | 当用户开始移动/跳跃到音频/视频中的新位置时   |\n| stalled                                                      | 当浏览器尝试获取媒体数据，但数据不可用时     |\n| suspend                                                      | 当浏览器刻意不获取媒体数据时                 |\n| timeupdate                                                   | 当目前的播放位置已更改时                     |\n| volumechange                                                 | 当音量已更改时                               |\n| waiting                                                      | 当视频由于需要缓冲下一帧而停止               |\n\n\n\n### 网易云音乐接口文档\n\n`https://binaryify.github.io/NeteaseCloudMusicApi/#/`\n\n线上接口前缀：\n\n```\nhttp://web.codeboy.com/music\n```\n\n示例：\n\n```\nhttp://web.codeboy.com/music/search?keywords=海阔天空\n```\n\n```\nhttp://web.codeboy.com/music/song/url?id=33894312\n```\n\n\n\n## `Canvas`\n\n`Canvas`意为**画布**，可以实现使用`Javascript`在网页中绘制图形图像。\n\n### 如何基于canvas绘制图形\n\n```html\n<canvas width=\"640\" height=\"360\" id=\"cvs\"></canvas>\n```\n\n基于`Javascript`绘制canvas：\n\n```javascript\nlet ctx = cvs.getContext(\'2d\')\n// 访问ctx的属性，调用ctx的方法来绘制canvas。\n```\n\n案例：02_canvas.html\n\n\n\n#### 基础绘图相关`API`\n\n```javascript\n// 绘制填充矩形\nctx.fillStyle = \'red\'  // 设置填充颜色\nctx.fillRect(100, 50, 150, 250)  // 填充一个矩形\n\n// 绘制描边矩形\nctx.strokeStyle = \'blue\'  // 设置描边颜色\nctx.strokeRect(70, 20, 210, 310) // 对一个矩形绘制描边\n\n// 绘制文本\nctx.font = \'35px 微软雅黑\'  // 设置字体大小与字体\nctx.fillText(\'克里米亚大桥被炸\', 350, 50)\nctx.strokeText(\'克里米亚大桥被炸\', 350, 150)\n```\n\n\n\n案例：绘制一个柱状图。\n\n已知数据：      `data: [120, 200, 150, 80, 70, 110, 130]`\n\n绘制柱状图，必须知道每根柱子的坐标位置、宽高。\n\n无论如何要得到4组数据：\n\n1. xs: 数组   保存7根柱子的x坐标\n2. ys: 数组   保存7根柱子的y坐标\n3. ws: 数组   保存7根柱子的w\n4. hs: 数组   保存7根柱子的h\n\n\n# `HTML5新特性` `DAY03`\n\n### `Canvas` 路径\n\n#### 什么是路径？\n\n路径是将一系列的点按照顺序连接起来所形成的图形。一旦拥有一个路径，可以对该路径进行**描边**，**填充**等操作。\n\n**如何绘制路径？**\n\n```javascript\nctx.beginPath()   // 开启一条路径\nctx.moveTo(x, y)  // 将画笔移动到某一个点\nctx.lineTo(x1, y1)  // 从当前位置向x1，y1位置连线\nctx.lineTo(x2, y2)  // 从当前位置向x2，y2位置连线\n....\nctx.stroke()  // 对现有路径进行描边 \nctx.fill()  // 对现有路径进行填充 \n```\n\n\n\n案例：实现一个移动端手写板。\n\n**实现思路：**\n\n1. 当手指触摸到画布时，开启一条新路径。\n2. 当手指在画布上触摸并移动时，绘制路径。并且描边。这样就可以看到触摸移动的轨迹。\n\n\n\n移动端的触摸相关事件：\n\n`touchstart`:   开始触摸元素时触发\n\n`touchmove`:   在元素上触摸并移动时触发\n\n`touchcancel`:   触摸被打断时触发\n\n`touchend`:   触摸结束时触发（抬手了）\n\n\n\n`canvas`提供了简单的`API`用于绘制常见图形路径\n\n矩形路径\n\n```javascript\n// 绘制矩形路径：（左上角x，左上角y，宽，高）\nctx.rect(40, 50, 100, 60)\nctx.stroke()  \nctx.fill()\n```\n\n圆弧路径\n\n```javascript\nctx.arc(100, 100, 90, 0, 2*Math.PI)\n```\n\n\n\n### `Canvas`动画\n\n#### 动画的本质\n\n每隔一段时间（非常短 1/60秒一次）不间断的重新绘制`UI`界面，而每次绘制的时候`UI`都会有一些不同，由于人眼视觉残留现象，出现流畅的动画效果。\n\n```javascript\nwindow.setInterval(()=>{\n   修改UI属性\n   重新绘制canvas\n}, 1000/60)\n```\n\n\n\n案例：实现一个视频弹幕效果。\n\n**实现思路**\n\n1. 准备一个弹幕列表： `dmlist=[]`用于保存所有弹幕内容。\n\n2. 当点击发送按钮时，发送弹幕：整理一个弹幕对象，`push`到`dmlist`中。\n\n   ```\n   {text:\'弹幕内容\', x:600, y:30}\n   ```\n\n3. 在全局创建一个定时器，每1000/60毫秒不断的遍历`dmlist`，绘制每一条弹幕。\n\n\n\n上述动画效果实现后发现有一些卡顿现象。卡顿的本质：掉帧。原因在于`window.setInterval()` 不适合写流畅动画，该方法并不能保证每秒60帧的刷新率。\n\n\n\n如果希望绘制丝滑动画，保证每秒60帧，推荐使用：\n\n`window.requestAnimationFrame()`，基本使用方式如下：\n\n```javascript\nfunction draw(){\n	修改UI属性，\n    重新绘制UI...\n    window.requestAnimationFrame(draw)\n}\ndraw()\n```\n\n`window.requestAnimationFrame(draw)`方法的作用：\n\n请求浏览器在检测到显示器刷新UI时（`1000/60`），自动调用一次`draw`方法。\n\n\n\n\n\n# `HTML5新特性` `DAY04`\n\n## 地理定位\n\n### 网页中地理定位的原理\n\n1. `IP`定位\n2. 运营商基站定位\n3. `GPS`、北斗卫星定位\n\n#### 如何通过`HTML5`提供的定位相关`API`获取设备的位置？\n\n```javascript\nlet geo = window.navigator.geolocation\n//(成功的回调, 失败的回调, 配置参数)\ngeo.getCurrentPosition((result)=>{}, (error)=>{}, {timeout:5000})\n```\n\n如果成功定位，则返回：\n\n```\ncoords: Coordinates\n    accuracy: 		定位精确度\n    altitude:       海拔高度\n    altitudeAccuracy: 海拔定位精确度\n    heading: \n    latitude:    纬度\n    longitude:   经度\n    speed:       速度\n```\n\n更常用的场景是在地图中显示该经纬度信息。如果需要在网页中显示地图，则必须借助于第三方的地图服务：百度地图、高德地图、腾讯地图\n\n### 高德地图\n\n打开网址：https://lbs.amap.com    高德地图开放平台。\n\n![1665481274876](C:\\Users\\web\\AppData\\Roaming\\Typora\\typora-user-images\\1665481274876.png)\n\n申请key：登录成功后，点击控制台，进入后台管理页面。\n\n点击应用管理 -- 我的应用 -- 新建应用（随便填写应用名称） -- 添加key\n\n![1665482062197](C:\\Users\\web\\AppData\\Roaming\\Typora\\typora-user-images\\1665482062197.png)\n\n\n\n#### 高德地图常见操作\n\n1. 在网页中显示地图。\n2. 在地图中设置中心点坐标，设置`3D`模式等。 \n3. 为地图添加点标记。\n4. 为点标记绑定点击事件，点击后弹窗。\n5. 为地图添加覆盖物：控件。先加载插件，创建对象，添加到地图上。\n\n\n\n#### 访问高德地图常用的`Web`服务\n\n1. `IP`定位查询当前城市\n\n2. 根据关键字搜索地点信息\n3. 地理编码包含正向地理编码和逆向地理编码两种：\n\n- **正向地理编码：** 将地址描述信息转换成地理坐标（经纬度），对应为`AMap.Geocoder`的`getLocation`方法\n- **逆向地理编码：**将地理坐标（经纬度）转换成地址描述信息，对应为`AMap.Geocoder`的`getAddress`方法\n\n\n\n#### 如何在`Vue`脚手架项目中使用高德地图\n\n在`VueCli`项目中使用高德地图`API`，需要依靠`AMapLoader`来获取`AMap`。\n\n1. 准备一个脚手架项目。\n\n   ```\n   http://localhost:8080/component/container\n   ```\n\n2. 在项目根目录安装`AMapLoader`。\n\n   ```shell\n   npm i @amap/amap-jsapi-loader --save\n   ```\n\n3. 在组件中，如果希望使用`AMapLoader`，则需要引入：\n\n   ```javascript\n   import AMapLoader from \'@amap/amap-jsapi-loader\';\n   ```\n\n4. 通过`AMapLoader`获取`AMap`：\n\n   准备好一个`div`容器：`#container`\n\n   ```javascript\n   import AMapLoader from \'@amap/amap-jsapi-loader\';\n   window._AMapSecurityConfig = {\n       securityJsCode:\'0b7fff62bb4d6f79bae15c1a1483e327\',\n   }\n   export default {\n       mounted(){\n           // 加载AMap\n           AMapLoader.load({\n               key:\'7bfbe3ab215345f405c23b5eed760ca8\',\n               version:\'2.0\',\n               plugins:[\'AMap.ToolBar\',\'AMap.PlaceSearch\']\n           }).then(AMap=>{\n               // 将地图显示在#container的div中\n               let map = new AMap.Map(\'container\')\n               map.addControl(new AMap.ToolBar())\n   \n               let searchObj = new AMap.PlaceSearch({\n                   city: \'北京\'\n               })\n               searchObj.search(\'电影院\', function(status, result){\n                   console.log(status, result)\n               })\n           })\n       }\n   }\n   ```\n\n\n## 文件上传\n\n**什么叫文件上传？**\n\n客户端与服务端建立http连接后，由客户端发起请求，且在请求中携带客户端本地的某一个文件一起发送到服务端，服务端接收该请求，将上传上来的文件保存在服务端。这个过程叫做文件上传。\n\n### 文件上传流程\n\n1. 客户端与服务端建立`http`连接。\n2. 客户端选择一个本地文件，通过`http`连接将请求发送给服务器，该请求中将携带本地文件的二进制数据一起发送给服务器。\n3. 服务端接收`http`请求，读取请求中的文件二进制数据，并且边读取，边将这些文件数据写入服务端某文件夹下，生成一个新文件。并且服务端应该同时生成一个可以访问该文件的链接地址。例如：如果用户上传了一个`1.jpg`，则在保存完毕后，需要生成一个：`http://localhost:3000/static/1.jpg`。将该链接地址返回给客户端。\n4. 客户端接收到响应后，发现上传成功，并且可以获取到访问该文件的链接地址，拿着该地址执行后续业务。（回显；再次发请求，将链接地址存入数据库；等）\n\n\n\n#### 发送文件上传请求时的`http`协议规范\n\n1. 请求方式必须是`post`。 \n\n2. 请求数据包需要携带如下`Header`：\n\n   ```\n   Content-Type: multipart/form-data\n   ```\n\n3. 客户端发送请求时传递参数：\n\n   ```\n   name=zs\n   pwd=1234\n   uploadFile=二进制数据\n   ```\n\n4. 服务端接收请求后，发现有`multipart/form-data`消息头，则可以断定请求参数中包含文件数据。就可以有针对性的读取这些数据，从而保存这些数据到服务端磁盘中，完成上传操作。\n\n\n\n#### 基于`VueCli` `ElementUI`组件库实现客户端发送请求上传文件\n\n\n# `HTML5新特性` `DAY05`\n\n#### 基于`VueCli` `ElementUI`组件库实现客户端发送请求上传文件\n\n基于`axios`发送普通post请求\n\n```javascript\n// let params = {name:zhangsan, password:1234, age:15}\n\nlet params = \'name=zhangsan&password=1234&age=15\'\naxios.post(\'/upload\', params).then(res=>{\n    console.log(res)\n})\n```\n\n基于`axios`发送上传文件的post请求\n\n```javascript\nlet params = new FormData()\nparams.append(\'name\', \'zhangsan\')\nparams.append(\'password\', \'1234\')\nparams.append(\'uploadFile\', file对象)\naxios.post(\'/upload\', params).then(res=>{\n    console.log(res)\n})\n```\n\n\n\n### 如何实现头像的上传？\n\n需求：注册用户时填写表单，在表单中需要选择头像，点击注册按钮，注册成功。使用该账号登录时不仅可以看到个人基本信息，还可以看到本人上传的头像图片。\n\n如果希望在任何时候都可以看到个人头像，那么就必须将头像路径与本人信息一起存在数据库中才行：\n\n| id   | name | pwd  | age  | avatar                |\n| ---- | ---- | ---- | ---- | --------------------- |\n| 1    | zs   | 1234 | 15   | http://xxx.com/1.jpg  |\n| 2    | ls   | 1234 | 13   | http:/xxxxx.com/2.jpg |\n| ..   | ..   | ..   | ..   | ..                    |\n\n实现流程如下：\n\n1. 用户填写注册表单。（基础数据）\n\n2. 用户选择头像，执行头像上传，一旦上传成功将会得到一个链接地址。用于访问刚刚上传的图片。\n\n3. 当用户点击注册按钮，注册时，需要发送一个普通的post请求，不仅需要传递基本信息，还要传递头像路径，这样服务端就可以将这些数据存入用户数据库。\n\n   ```\n   let params = \'name=zs&pwd=1234&age=15&avatar=http://com/1.jpg\'\n   axios.post(\'regist\', params).then(res=>{\n       \n   })\n   ```\n\n4. 服务端需要提供一个这样的注册接口，接收该请求，将这些字符串数据存入数据库即可。\n\n5. 下次用户登录时，就可以从数据库中读取用户基本信息（包含头像路径），从而获取头像路径后赋值给`img`的`src`。\n\n\n\n## `WebSocket`\n\n`WebSocket`可以实现浏览器客户端与服务端之间建立**长连接**后的即时通讯业务需求。\n\n### 网络通讯过程中的长连接与短连接\n\n**短连接：** 客户端与服务端建立连接，连接建立成功后，客户端发请求给服务端，服务端接收请求处理请求，返回响应后，连接断开。这种通讯模式称为短连接。\n\n短连接模式可以及时的释放服务端连接资源，让服务端可以为更多的客户端提供服务。\n\n**长连接：** 客户端与服务端建立连接，连接建立成功后，客户端发请求给服务端，服务端接收请求处理请求，返回响应后，连接不断开。双方还可以使用该连接继续通信。这种通讯模式称为长连接。\n\n持续连接的优点就是可以实现客户端服务端之间的实时通信。\n\n**如何在网页中建立客户端与服务端之间的基于`websocket`协议的长连接？**\n\n\n\n### `Socket.io`\n\n`Socket.io`是一个实现了`websocket`通讯协议的网络通讯库。可以基于`socket.io`方便的建立客户端与服务端之间的`websocket`长连接，还可以进行后续的实时通讯。\n\n使用`Socket.io`实现即时通讯的场景主要有如下几种：\n\n1. 基于`Socket.io`框架建立连接。\n2. 基于现有连接，实现客户端发送数据，服务端接收。\n3. 基于现有连接，实现服务端发送数据，客户端接收。\n\n\n\n#### 基于`Socket.io`框架建立连接\n\n##### 服务端：\n\n1. 新建一个项目目录：`socketserver`。作为服务端项目。\n\n2. 安装所需模块：`express,  socket.io`\n\n   ```shell\n   npm  init  -y   # 初始化   生成package.json\n   npm install express  --save\n   npm install socket.io  --save\n   ```\n\n3. 新建`index.js`，编写服务端代码模板：（复制官网模板）\n\n   ```javascript\n   const express = require(\'express\');\n   const app = express();\n   const http = require(\'http\');\n   const server = http.createServer(app);\n   const { Server } = require(\"socket.io\");\n   const io = new Server(server);\n   \n   // 调用io.on()方法，监听客户端向socket.io服务端发起的websocket连接请求\n   // 一旦有客户端试图连接当前服务，将立即监听到该动作\n   // 连接建立成功后执行回调方法    socket就是websocket连接对象\n   io.on(\'connection\', (socket) => {\n     console.log(\'a user connected\');\n   });\n   \n   server.listen(3000, () => {\n     console.log(\'listening on *:3000\');\n   });\n   ```\n\n4. 启动服务器\n\n   ```shell\n   node index.js\n   ```\n\n##### 客户端：\n\n1. 准备好`socket.io.js`。在网页中通过`script src`引入该`js`。\n\n2. 调用`io`方法，试图与服务端建立`websocket`连接。\n\n   ```javascript\n   let socket = io(\'http://localhost:3000\')\n   console.log(socket)\n   ```\n\n客户端与服务端连接一旦创建成功，客户端将会获取一个`socket`对象，服务端也会得到一个`socket`对象，两端就可以使用`socket`对象来完成交互。\n\n\n\n#### 基于现有连接，实现客户端发送数据，服务端接收\n\n##### 客户端发送数据\n\n```javascript\nlet socket = io(\'http://localhost:3000\')\n// 发送消息(消息类型，消息内容)\nsocket.emit(\'textmsg\', \'你瞅啥？！\')\n```\n\n##### 服务端接收数据\n\n```javascript\nio.on(\'connection\', (socket) => {\n    // on方法用于绑定监听，监听接收textmsg类型的消息\n    // 一旦接收到该类型的消息，则立即执行回调方法，将消息内容赋值给data\n    socket.on(\'textmsg\', function(data){\n        // data就是消息内容\n    })\n});\n```\n\n\n\n#### 基于现有连接，实现服务端发送数据，客户端接收\n\n##### 服务端发送消息\n\n```javascript\nio.on(\'connection\', (socket) => {\n    socket.emit(\'textmsg\', \'消息内容\')\n});\n```\n\n##### 客户端接收消息\n\n```javascript\nlet socket = io(\'http://localhost:3000\')\nsocket.on(\'textmsg\', function(data){\n    // data就是接收的消息\n})\n```\n\n\n\n#### 基于现有连接，实现服务端向所有客户端群发消息\n\n```javascript\nio.on(\'connection\', function(socket){\n    // socket.emit()单独给某一个socket发消息\n    // io.emit()将会给所有客户端群发消息\n    io.emit(\'textmsg\', 内容)\n})\n```\n\n\n\n### 案例：实现群聊天室\n\n1. 下载`chatserver.zip`，解压后，`public`下有静态页面。`app.js`为后端代码。\n\n2. 启动`app.js`.\n\n   ```shell\n   node app.js\n   ```\n\n   接收客户端发来的消息，将会给所有在线的客户端都发一遍。\n\n3. 实现前端相关业务逻辑。\n\n   1. 当页面加载时，创建`websocket`连接。 \n\n   2. 在输入框中输入消息内容，点击发表，将消息发给服务端。服务端将会把该消息内容给所有客户端群发一遍。\n\n   3. 客户端接收服务端的消息，显示在聊天记录区。\n\n   4. 实时显示聊天室的在线人数。\n\n      1. 只有服务端可以及时的获取到这些信息：用户连接成功、用户断开连接。\n      2. 在服务端全局声明一个变量`count`，用于描述当前在线人数。\n      3. 如果有新用户连接成功，`count++`\n      4. 如果有用户断开连接，`count--`\n      5. 每当有新用户连接成功或用户断开连接时，count会有变化，需要在修改了count之后，将最新的人数给所有客户端群发一份。\n      6. 客户端接收到更新在线人数的消息，修改`innerHTML`。 \n\n   5. 发消息时需要区分用户。希望在界面中显示发消息的用户的信息：头像、昵称\n\n      1. 发消息时，就不能只发文本，需要带着本人的信息一起发送：\n\n         ```javascript\n         socket.emit(\'textmsg\', {\n             text:\'消息内容\', name:\'昵称\', avatar:\'xx.jpg\'})\n         ```\n\n         接收消息时，也将接收到一个对象：\n\n         ```\n         data =>  {text, name, avatar}\n         ```\n\n\n\n# `HTML5新特性` `DAY06`\n\n### `WebWorker`\n\n`WebWorker`可以实现在网页端启动一条`worker`线程，异步执行耗时任务。 \n\n网页中的`javascript`代码属于单线程模型，即所有的代码都会在主线程中执行。而主线程有一个非常重要的任务：不间断的（1/60秒）重绘浏览器`UI`界面。\n\n如果在主线程运行程序的过程中遇到了一些耗时代码，必然会阻塞主线程，导致影响`UI`的实时绘制，最终出现页面假死现象。\n\n案例：写一个网页，点击按钮计算斐波那契数列的值（耗时），感受主线程卡死的感觉。\n\n```\n1	1	2	3	5	8	13	21	34	55	89  ..... \n```\n\n```javascript\nfunction fb(n){  // 返回第n个斐波那契数列的值\n    return n<3 ? 1 : fb(n-1) + fb(n-2)\n}\n```\n\n\n\n**在网页中如何处理这些耗时代码？**\n\n`WebWorker`可以实现在网页端启动一条`worker`线程，异步执行耗时任务。 \n\n\n\n### 如何使用`WebWorker`？\n\n1. 新建一个文件：`worker.js`，将这些耗时代码放入该文件中等待执行。\n\n2. 在主线程中，通过new的方式创建`Worker`并异步执行`worker`代码。 \n\n   ```javascript\n   let worker = new Worker(\'./worker.js\')\n   ```\n\n   上述代码将会创建一个`worker`工作线程，异步执行`worker.js`中的代码，而不影响主线程的`UI`绘制。 \n\n\n\n通过上述代码可以实现，将耗时代码放入`worker`中执行，这样就不会阻塞主线程绘制`UI`。 但是`worker`不能启动太多，每个`worker`都会占用独立的`cpu`资源，如果不做管理，将会无下限的使用`CPU`资源，影响其他应用程序的运行。所以，`worker`的使用方式如下：（不要创建过多的`worker`） \n\n1. 在`js`的全局中创建`worker`对象。（不执行耗时代码，仅仅只是创建对象而已）\n2. 当需要让worker计算耗时代码时，给这个`worker`发消息。主线程可以无限制的给`worker`发消息，`worker`根据接收到的消息，按顺序执行这些任务。\n\n\n\n#### 主线程向`worker`线程发消息\n\n```\nlet worker = new Worker(\'./worker2.js\')\nworker.postMessage(45)\n```\n\n`worker2.js`\n\n```javascript\nonmessage = function(e){\n    e.data 就是发过来的消息内容\n}\n```\n\n\n\n#### `Worker`的限制\n\n`WebWorker`中是不能直接修改`UI`的。无法获取`document`。 \n\n如果`webworker`需要更新`UI`，则必须将数据发给主线程，让主线程来更新`UI`。 \n\n\n\n#### `worker`线程向主线程发消息\n\n`worker`发消息\n\n```javascript\n// worker2.js\npostMessage(\'结果字符串\')\n```\n\n主线程接收消息\n\n```\nlet worker = new Worker(\'\')\nworker.onmessage = function(e){\n    e.data就是worker发回来的消息\n}\n```\n\n\n\n```\nthis.axios.get(\'url\').then(res=>{\n    xxxxx\n})\n\nwindow.setTimeout(()=>{\n    xxxxx\n}, 1000)\n```\n\n\n\n## `SVG`\n\n`SVG (Scalable Vector Graphic)` 可伸缩的矢量图形。是一种使用XML文本来描述图像的一种图像格式。\n\n```\n定义一个矢量数据，描述一个图像：\nlet rect =  [5, 5, 100, 50, red, blue ......]\nrect * 2\nlet rect2 = [10, 10, 200, 100, red, blue .....]\n```\n\n\n\n### 第一个`svg`图像\n\n案例：`02_svg.html`。\n\n#### 实现步骤\n\n1. 新建一个文件：`circle.svg`。在该`svg`文件中编写代码，绘制图形。\n\n2. 在`svg.html`中引入该图片：\n\n   ```html\n   <img src=\"./circle.svg\">\n   ```\n\n\n#### `svg`的使用场景，使用方式\n\n1. 在`img`标签中使用`src`引入`svg`图片：\n\n   ```html\n   <img src=\"a.svg\">\n   ```\n\n2. 在标签的style中，通过background-image来使用`svg`：\n\n   ``` html\n   <div style=\"background-image: url:(\'a.svg\')\"></div>\n   ```\n\n3. 在body中直接使用`svg`标签绘制图像：\n\n   ```html\n   <body>\n       <svg width=\"400\" height=\"345\">\n           <polygon id=\"v1\"\n                    points=\"0,0 400,0 200,340\" \n                    style=\"fill:#41b784; transition: all 1s;\" />\n           <polygon id=\"v2\" points=\"80,0 320,0 200,205\" \n                    style=\"fill:#33495d; transition: all 1s;\" />\n           <path id=\"v3\" d=\"M155 0 L245 0 L200 80 Z\"\n                 style=\"fill: #fff; transition: all 1s;\"/>\n       </svg>\n   </body>\n   ```\n\n\n若`SVG`直接写入了`body`，则意味着被`DOM`所管理，可以通过`DOM`相关的`API`直接操作`svg`的图像：绑定事件、修改属性、修改样式等。\n\n```javascript\nfunction getColor(){\n    return `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`\n}\nv1.onclick = function(){\n    // 修改v1的样式\n    v1.style.fill = getColor()\n    v2.style.fill = getColor()\n    v3.style.fill = getColor()\n}\n```\n\n\n\n#### `Canvas` 与 `SVG` 的比较\n\n下表列出了 canvas 与 SVG 之间的一些不同之处。\n\n##### `Canvas`\n\n- 依赖分辨率\n- 不支持事件处理器\n- 弱的文本渲染能力\n- 能够以 `.png` 或 `.jpg` 格式保存结果图像\n- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n##### `SVG`\n\n- 不依赖分辨率\n- 支持事件处理器\n- 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n- 不适合游戏应用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-11-27', 6, '[\"HTML\",\"JavaScript\"]', 7, 0);

-- --------------------------------------------------------

--
-- 表的结构 `btag`
--

CREATE TABLE `btag` (
  `tagName` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `btag`
--

INSERT INTO `btag` (`tagName`) VALUES
('React'),
('vue'),
('redux'),
('JavaScript'),
('axios'),
('Vuex'),
('TypeScript'),
('HTML'),
('Node');

-- --------------------------------------------------------

--
-- 表的结构 `comment`
--

CREATE TABLE `comment` (
  `mid` int(11) NOT NULL,
  `bid` int(11) NOT NULL,
  `content` text NOT NULL,
  `createTime` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `comment`
--

INSERT INTO `comment` (`mid`, `bid`, `content`, `createTime`) VALUES
(1, 1, '还可以啊', '2022-11-21 17:03:55');

-- --------------------------------------------------------

--
-- 表的结构 `essay`
--

CREATE TABLE `essay` (
  `eid` int(11) NOT NULL,
  `content` text NOT NULL,
  `createTime` date NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `essay`
--

INSERT INTO `essay` (`eid`, `content`, `createTime`) VALUES
(16, '# 我的个人BLog终于写好啦\n![111.png](http://47.108.228.255:3000/upload/1669544905432.png)', '2022-11-27');

-- --------------------------------------------------------

--
-- 表的结构 `note`
--

CREATE TABLE `note` (
  `nid` int(11) NOT NULL,
  `content` text NOT NULL,
  `createTime` date NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `note`
--

INSERT INTO `note` (`nid`, `content`, `createTime`) VALUES
(8, '好厉害啊', '2022-11-26'),
(16, '还需要继续完善', '2022-11-27'),
(22, '帅帅到此一游\n', '2022-11-27');

-- --------------------------------------------------------

--
-- 表的结构 `project`
--

CREATE TABLE `project` (
  `pid` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `desc` varchar(255) NOT NULL,
  `techStack` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `createTime` date NOT NULL,
  `pic` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

--
-- 转存表中的数据 `project`
--

INSERT INTO `project` (`pid`, `title`, `desc`, `techStack`, `content`, `createTime`, `pic`) VALUES
(4, '个人博客系统', '这是一个个人博客系统，用于记录我的学习笔记以及分享个人项目，实现了个人博客和项目的上传、编辑以及展示。还包括了一些个人简介。可以上传随笔以及给我留言。系统使用了Vue全家桶，后端使用Node+Express实现后台接口，数据库采用MySQL。', 'Vue全家桶、axios、elementUI、Node、Express、MySQL、Multer', '# 个人博客系统\n## 哈哈，空的，没想到吧', '2022-11-27', 'upload/1669544829904.png');

--
-- 转储表的索引
--

--
-- 表的索引 `bcategory`
--
ALTER TABLE `bcategory`
  ADD PRIMARY KEY (`cid`) USING BTREE;

--
-- 表的索引 `blog`
--
ALTER TABLE `blog`
  ADD PRIMARY KEY (`bid`) USING BTREE;

--
-- 表的索引 `comment`
--
ALTER TABLE `comment`
  ADD PRIMARY KEY (`mid`) USING BTREE;

--
-- 表的索引 `essay`
--
ALTER TABLE `essay`
  ADD PRIMARY KEY (`eid`) USING BTREE;

--
-- 表的索引 `note`
--
ALTER TABLE `note`
  ADD PRIMARY KEY (`nid`) USING BTREE;

--
-- 表的索引 `project`
--
ALTER TABLE `project`
  ADD PRIMARY KEY (`pid`) USING BTREE;

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `bcategory`
--
ALTER TABLE `bcategory`
  MODIFY `cid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;

--
-- 使用表AUTO_INCREMENT `blog`
--
ALTER TABLE `blog`
  MODIFY `bid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=28;

--
-- 使用表AUTO_INCREMENT `comment`
--
ALTER TABLE `comment`
  MODIFY `mid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- 使用表AUTO_INCREMENT `essay`
--
ALTER TABLE `essay`
  MODIFY `eid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=17;

--
-- 使用表AUTO_INCREMENT `note`
--
ALTER TABLE `note`
  MODIFY `nid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;

--
-- 使用表AUTO_INCREMENT `project`
--
ALTER TABLE `project`
  MODIFY `pid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
